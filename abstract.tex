% $Log: abstract.tex,v $
% Revision 1.1  93/05/14  14:56:25  starflt
% Initial revision
%
% Revision 1.1  90/05/04  10:41:01  lwvanels
% Initial revision
%
%
%% The text of your abstract and nothing else (other than comments) goes here.
%% It will be single-spaced and the rest of the text that is supposed to go on
%% the abstract page will be generated by the abstractpage environment.  This
%% file should be \input (not \include 'd) from cover.tex.
%%
% Quoting
% http://www.eecs.mit.edu/docs/grad/EECS_Thesis_Proposal_and_Thesis_Guidelines.pdf#page=9
%
% After a thesis has been completed, its further value is largely
% dependent on the extent to which it is read and found useful by
% others.  It is important to supply a well-written abstract, which
% outlines the scope and achievements of the thesis so that
% prospective readers can determine whether or not they should read
% any further. An additional advantage is gained because the abstract
% will in many cases enable the library staff to catalogue the work
% more fully and more accurately.  Accordingly, the Committee on
% Graduate Programs requires that each thesis contain an
% abstract--preferably one typewritten page (single-spaced), but in no
% case more than two such pages--in which is given a description of
% the problem and of the procedure used in the investigation, together
% with a brief statement of the results found or of the conclusions
% reached. Other material may be included in the summar y if you find
% it pertinent. Your objective is to inform another engineer or
% scientist, who is not necessarily a specialist in your field, what
% you worked on, how you did it, and what one may expect to learn
% about the problem by reading further
%
% For submission to MIT library: Abstracts should be no longer than
% 350 words, longer abstracts will be edited by ProQuest
%
% https://libraries.mit.edu/distinctive-collections/thesis-specs/#graduate
\todo{More formal wording}
Formally verified proofs are important.
Unfortunately, large-scale proofs, especially automated ones, in Coq, can be quite slow.

This thesis aims to be a partial guide to resolving the issue of slowness.
We present a survey of the landscape of slowness in Coq, with a number of micro- and macro-benchmarks.
We describe various metrics that allow prediction of slowness, such as term size, goal size, and number of binders, and note the occasional surprise-lack-of-bottleneck for some factors, such as total proof term size.

We identify three main categories of workarounds and partial solutions to slowness: design of APIs of Gallina libraries; changes to Coq's type theory, implementation, or tooling; and automation design patterns, including proof by reflection.
We present lessons drawn from the case-studies of a category-theory library, a proof-producing parser-generator, and a verified compiler and code generator for low-level cryptographic primitives.

\todo{Fix run-on sentence}
The central new contribution presented by this thesis, beyond hopefully providing a roadmap to avoid slowness in large Coq developments, is a reflective framework for partial evaluation and rewriting which, in addition to being used to compile a code-generator for field arithmetic cryptographic primitives which generates the code currently used in Google Chrome, can serve as a template for a possibly replacement for tactics such as \texttt{rewrite}, \texttt{rewrite\_strat}, \texttt{autorewrite}, \texttt{simpl}, and \texttt{cbn} which achieves much better performance by running in Coq's VM while still allowing the flexibility of equational reasoning.


\todo{Maybe instead use the alternative from the thesis-proposal?}
The proposed research is a study of performance issues that come up in engineering large-scale proof-based systems in Coq.
The thesis presents lessons learned about achieving acceptable performance in Coq in the course of case-studies on formalizing category theory, developing a parser synthesizer, and constructing a verified compiler for synthesizing efficient low-level cryptographic primitives.
We also present a novel method of simple and fast reification, and a prototype tool for faster rewriting and customizable reduction which does not require extending Coq's trusted code base.
