\chapter{Design-based fixes} \label{ch:design} \label{ch:api-design}

\todo{this chapter}

\section{Abstraction barriers}
e.g., f (fst x) (snd x) where fst x := let (a, b) := x in a; vs let (a, b) := x in f a b.

\section{When and how to use dependent types painlessly}
The extremes are relatively easy:
\begin{itemize}
\item Total separation between proofs and programs, so that programs are simply typed, works relatively well
\item Pre-existing mathematics, where objects are fully bundled with proofs and never need to be separated from them, also works relatively well
\item The rule of thumb in the middle: it is painful to recombine proofs and programs after you separate them; if you are doing it to define an opaque transformation that acts on proof-carrying code, that is okay, but if you cannot make that abstraction barrier, enormous pain results.
\item For example, if you have length-indexed lists and want to index into them with elements of a finite type, things are fine until you need to divorce the index from its proof of finiteness.  If you, for example, want to index into, say, the concatenation of two lists, with an index into the first of the lists, then you will likely run into trouble, because you are trying to consider the index separately from its proof of finitude, but you have to recombine them to do the indexing.
\end{itemize}

More examples from the rewriter?

\section{more stuff from CT performance paper / presentation}
\todo{this section}
