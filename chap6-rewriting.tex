\chapter{Extended Description of the Rewriter}
\todo{this chapter}
\todo{mention frowned-upon Perl scripts previously in BoringSSL(?) OpenSSL?; (ask Andres for reference?)} Perl scripts were complicated, a number of steps removed from actual running code, hard to maintain and verify.
\section{Rewriter}\label{rewriter}

\subsection{Introduction}\label{introduction}

\begin{itemize}
\tightlist
\item
  The goal of the rewriter is to take an abstract syntax tree and
  perform reduction or rewriting.
\item
  There are three things that happen in rewriting: beta reduction,
  let-lifting, and replacement of rewrite patterns with their
  substitutions
\item
  Beta reduction is replacing \texttt{(λ\ x.\ F)\ y} with
  \texttt{F{[}x\ ⇒\ y{]}}. We do this with a normalization-by-evaluation
  strategy.
\item
  Let-lifting involves replacing \texttt{f\ (let\ x\ :=\ y\ in\ z)} with
  \texttt{let\ x\ :=\ y\ in\ f\ x}. Note that for higher-order
  functions, we push lets under lambads, rather than lifting them; we
  replace \texttt{f\ (let\ x\ :=\ y\ in\ (λ\ z.\ w))} with
  \texttt{f\ (λ\ z.\ let\ x\ :=\ y\ in\ w)}. This is done for the
  convenience of not having to track the let-binding-structure at every
  level of arrow.
\item
  Replacing rewriting patterns with substitutions involves, for example,
  replacing \texttt{x\ +\ 0} with \texttt{x}.
\item
  There's actually a fourth thing, which happens during let-lifting:
  some let binders get inlined: In particular, any let-bound value which
  is a combination of variables, literals, and the identifiers
  \texttt{nil}, \texttt{cons}, \texttt{pair}, \texttt{fst},
  \texttt{snd}, \texttt{Z.opp}, \texttt{Z.cast}, and \texttt{Z.cast2}
  gets inlined. If the let-bound variable contains any lambdas, lets, or
  applications of identifiers other than the above, then it is not
  inlined.
\end{itemize}

\subsection{Beta-Reduction and
Let-Lifting}\label{beta-reduction-and-let-lifting}

\begin{itemize}
\item
  We use the following data-type:

\begin{verbatim}
Fixpoint value' (with_lets : bool) (t : type)
  := match t with
     | type.base t
       => if with_lets then UnderLets (expr t) else expr t
     | type.arrow s d
       => value' false s -> value' true d
     end.
Definition value := value' false.
Definition value_with_lets := value' true.
\end{verbatim}
\item
  Here are some examples:

  \begin{itemize}
  \tightlist
  \item
    \texttt{value\ Z\ :=\ UnderLets\ (expr\ Z)}
  \item
    \texttt{value\ (Z\ -\textgreater{}\ Z)\ :=\ expr\ Z\ -\textgreater{}\ UnderLets\ (expr\ Z)}
  \item
    \texttt{value\ (Z\ -\textgreater{}\ Z\ -\textgreater{}\ Z)\ :=\ expr\ Z\ -\textgreater{}\ expr\ Z\ -\textgreater{}\ UnderLets\ (expr\ Z)}
  \item
    \texttt{value\ ((Z\ -\textgreater{}\ Z)\ -\textgreater{}\ Z)\ :=\ (expr\ Z\ -\textgreater{}\ UnderLets\ (expr\ Z))\ -\textgreater{}\ UnderLets\ (expr\ Z)}
  \end{itemize}
\item
  By converting expressions to values and using
  normalization-by-evaluation, we get beta reduction in the standard
  way.
\item
  We use a couple of splicing combinators to perform let-lifting:

  \begin{itemize}
  \tightlist
  \item
    \texttt{Fixpoint\ splice\ \{A\ B\}\ (x\ :\ UnderLets\ A)\ (e\ :\ A\ -\textgreater{}\ UnderLets\ B)\ :\ UnderLets\ B}
  \item
    \texttt{Fixpoint\ splice\_list\ \{A\ B\}\ (ls\ :\ list\ (UnderLets\ A))\ (e\ :\ list\ A\ -\textgreater{}\ UnderLets\ B)\ :\ UnderLets\ B}
  \item
    \texttt{Fixpoint\ splice\_under\_lets\_with\_value\ \{T\ t\}\ (x\ :\ UnderLets\ T)\ :\ (T\ -\textgreater{}\ value\_with\_lets\ t)\ -\textgreater{}\ value\_with\_lets\ t}
  \item
    \texttt{Definition\ splice\_value\_with\_lets\ \{t\ t\textquotesingle{}\}\ :\ value\_with\_lets\ t\ -\textgreater{}\ (value\ t\ -\textgreater{}\ value\_with\_lets\ t\textquotesingle{})\ -\textgreater{}\ value\_with\_lets\ t\textquotesingle{}}
  \end{itemize}
\item
  There's one additional building block, which is responsible for
  deciding which lets to inline:

  \begin{itemize}
  \tightlist
  \item
    \texttt{Fixpoint\ reify\_and\_let\_binds\_base\_cps\ \{t\ :\ base.type\}\ :\ expr\ t\ -\textgreater{}\ forall\ T,\ (expr\ t\ -\textgreater{}\ UnderLets\ T)\ -\textgreater{}\ UnderLets\ T}
  \end{itemize}
\item
  As is typical for NBE, we make use of a reify-reflect pair of
  functions:
  \texttt{coq\ \ Fixpoint\ reify\ \{with\_lets\}\ \{t\}\ :\ value\textquotesingle{}\ with\_lets\ t\ -\textgreater{}\ expr\ t\ \ with\ reflect\ \{with\_lets\}\ \{t\}\ :\ expr\ t\ -\textgreater{}\ value\textquotesingle{}\ with\_lets\ t}
\item
  The NBE part of the rewriter, responsible for beta reduction and
  let-lifting, is now expressible:

\begin{verbatim}
Local Notation "e <---- e' ; f" := (splice_value_with_lets e' (fun e => f%under_lets)) : under_lets_scope.
Local Notation "e <----- e' ; f" := (splice_under_lets_with_value e' (fun e => f%under_lets)) : under_lets_scope.

Fixpoint rewrite_bottomup {t} (e : @expr value t) : value_with_lets t
  := match e with
     | expr.Ident t idc
       => rewrite_head _ idc
     | expr.App s d f x => let f : value s -> value_with_lets d := @rewrite_bottomup _ f in x <---- @rewrite_bottomup _ x; f x
     | expr.LetIn A B x f => x <---- @rewrite_bottomup A x;
                               xv <----- reify_and_let_binds_cps x _ UnderLets.Base;
                               @rewrite_bottomup B (f (reflect xv))
     | expr.Var t v => Base_value v
     | expr.Abs s d f => fun x : value s => @rewrite_bottomup d (f x)
     end%under_lets.
\end{verbatim}

  \subsection{Rewriting}\label{rewriting}

  \subsubsection{There are three parts and one additional detail to
  rewriting:}\label{there-are-three-parts-and-one-additional-detail-to-rewriting}
\item
  Pattern matching compilation
\item
  Decision tree evaluation
\item
  Rewriting with a particular rewrite rule
\item
  Rewriting again in the output of a rewrite rule \#\#\# Overview
\item
  Rewrite rules are patterns (things like \texttt{??\ +\ \#?} meaning
  ``any variable added to any literal'') paired with dependently typed
  replacement values indexed over the pattern. The replacement value
  takes in types for each type variable, \texttt{value}s for each
  variable (\texttt{??}), and interpreted values for each literal
  wildcard. Additionally, any identifier that takes extra parameters
  will result in the parameters being passed into the rewrite rule. The
  return type for replacement values is an option UnderLets expr of the
  correct type.
\item
  A list of rewrite rules is compiled into (a) a decision tree, and (b)
  a rewriter that functions by evaluating that decision tree. \#\#\# The
  small extra detail: Rewriting again in the output of a rewrite rule
\item
  We tie the entire rewriter together with a fueled repeat\_rewrite; the
  fuel is set to the length of the list of rewrite rules. This means
  that as long as the intended rewrite sequences form a DAG, then the
  rewriter will find all occurrences. ```coq Notation nbe :=
  (@rewrite\_bottomup (fun t idc =\textgreater{} reflect (expr.Ident
  idc))).
\end{itemize}

Fixpoint repeat\_rewrite ~ ~ ~ ~ ~(rewrite\_head : forall (do\_again :
forall t : base.type, @expr value (type.base t) -\textgreater{}
UnderLets (@expr var (type.base t))) ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
t (idc : ident t), value\_with\_lets t) ~ ~ ~ ~ ~(fuel : nat) \{t\} e :
value\_with\_lets t ~ := @rewrite\_bottomup ~ ~ ~ ~(rewrite\_head ~ ~ ~
~ ~ (fun t' e' ~ ~ ~ ~ ~ ~=\textgreater{} match fuel with ~ ~ ~ ~ ~ ~ ~
\textbar{} Datatypes.O =\textgreater{} nbe e' ~ ~ ~ ~ ~ ~ ~ \textbar{}
Datatypes.S fuel' =\textgreater{} @repeat\_rewrite rewrite\_head fuel'
(type.base t') e' ~ ~ ~ ~ ~ ~ ~ end\%under\_lets)) ~ ~ ~ ~t e.
\texttt{-\ This\ feature\ is\ used\ to\ rewrite\ again\ with\ the\ literal-list\ append\ rule\ (appending\ two\ lists\ of\ cons\ cells\ results\ in\ a\ single\ list\ of\ cons\ cells)\ in\ the\ output\ of\ the\ `flat\_map`\ rule\ (`flat\_map`\ on\ a\ literal\ list\ of\ cons\ cells\ maps\ the\ function\ over\ the\ list\ and\ joins\ the\ resulting\ lists\ with\ `List.app`).\ \#\#\#\ Pattern\ matching\ compilation\ -\ This\ part\ of\ the\ rewriter\ does\ not\ need\ to\ be\ verified,\ because\ the\ rewriter-compiler\ is\ proven\ correct\ independent\ of\ the\ decision\ tree\ used.\ \ \ Note\ that\ we\ could\ avoid\ this\ stage\ all\ together,\ and\ simply\ try\ each\ rewrite\ rule\ in\ sequence.\ \ \ We\ include\ this\ for\ efficiency.\ \ \ TODO:\ perf\ comparison\ of\ this\ method.\ -\ We\ follow\ *Compiling\ Pattern\ Matching\ to\ Good\ Decision\ Trees*\ by\ Luc\ Maranget\ (http://moscova.inria.fr/\textasciitilde{}maranget/papers/ml05e-maranget.pdf),\ which\ describes\ compilation\ of\ pattern\ matches\ in\ OCaml\ to\ a\ decision\ tree\ that\ eliminates\ needless\ repeated\ work\ (for\ example,\ decomposing\ an\ expression\ into\ `x\ +\ y\ +\ z`\ only\ once\ even\ if\ two\ different\ rules\ match\ on\ that\ pattern).\ -\ We\ do\ *not*\ bother\ implementing\ the\ optimizations\ that\ they\ describe\ for\ finding\ minimal\ decision\ trees.\ \ \ TODO:\ Mention\ something\ about\ future\ work?\ \ Perf\ testing?\ -\ The\ type\ of\ decision\ trees\ \ \ -\ A\ `decision\_tree`\ describes\ how\ to\ match\ a\ vector\ (or\ list)\ of\ patterns\ against\ a\ vector\ of\ expressions.\ The\ cases\ of\ a\ `decision\_tree`\ are:\ \ \ \ \ -\ `TryLeaf\ k\ onfailure`:\ Try\ the\ kth\ rewrite\ rule;\ if\ it\ fails,\ keep\ going\ with\ `onfailure`\ \ \ \ \ -\ `Failure`:\ Abort;\ nothing\ left\ to\ try\ \ \ \ \ -\ `Switch\ icases\ app\_case\ default`:\ With\ the\ first\ element\ of\ the\ vector,\ match\ on\ its\ kind;\ if\ it\ is\ an\ identifier\ matching\ something\ in\ `icases`,\ remove\ the\ first\ element\ of\ the\ vector\ run\ that\ decision\ tree;\ if\ it\ is\ an\ application\ and\ `app\_case`\ is\ not\ `None`,\ try\ the\ `app\_case`\ decision\_tree,\ replacing\ the\ first\ element\ of\ each\ vector\ with\ the\ two\ elements\ of\ the\ function\ and\ the\ argument\ its\ applied\ to;\ otherwise,\ don\textquotesingle{}t\ modify\ the\ vectors,\ and\ use\ the\ `default`\ decision\ tree.\ \ \ \ \ -\ `Swap\ i\ cont`:\ Swap\ the\ first\ element\ of\ the\ vector\ with\ the\ ith\ element,\ and\ keep\ going\ with\ `cont`\ \ \ -\ The\ inductive\ type:}coq
Inductive decision\_tree := \textbar{} TryLeaf (k : nat) (onfailure :
decision\_tree) \textbar{} Failure \textbar{} Switch (icases : list
(raw\_pident * decision\_tree)) ~ ~ ~ ~ ~(app\_case : option
decision\_tree) ~ ~ ~ ~ ~(default : decision\_tree) \textbar{} Swap (i :
nat) (cont : decision\_tree).
\texttt{-\ Raw\ identifiers\ \ \ -\ Note\ that\ the\ type\ of\ `icases`,\ the\ list\ of\ identifier\ cases\ in\ the\ `Switch`\ constructor\ above,\ maps\ what\ we\ call\ a\ `raw\_pident`\ ("p"\ for\ "pattern")\ to\ a\ decision\ tree.\ \ The\ rewriter\ is\ parameterized\ over\ a\ type\ of\ `raw\_pident`s,\ which\ is\ instantiated\ with\ a\ python-generated\ inductive\ type\ which\ names\ all\ of\ the\ identifiers\ we\ care\ about,\ except\ without\ any\ arguments.\ \ We\ call\ them\ "raw"\ because\ they\ are\ not\ type-indexed.\ \ \ -\ An\ example\ where\ this\ is\ important:\ We\ want\ to\ be\ able\ to\ express\ a\ decision\ tree\ for\ the\ pattern\ `fst\ (x,\ y)`.\ \ This\ involves\ an\ application\ of\ the\ identifier\ `fst`\ to\ a\ pair.\ \ We\ want\ to\ be\ able\ to\ talk\ about\ "`fst`,\ of\ any\ type"\ in\ the\ decision\ tree,\ without\ needing\ to\ list\ out\ all\ of\ the\ possible\ type\ arguments\ to\ `fst`.\ -\ Swap\ vs\ indices\ \ \ -\ One\ design\ decision\ we\ copy\ from\ *Compiling\ Pattern\ Matching\ to\ Good\ Decision\ Trees*\ is\ to\ have\ a\ `Swap`\ case.\ \ We\ could\ instead\ augment\ each\ `Switch`\ with\ the\ index\ in\ the\ vector\ being\ examined.\ \ If\ we\ did\ this,\ we\textquotesingle{}d\ need\ to\ talk\ about\ splicing\ a\ new\ list\ into\ the\ middle\ of\ an\ existing\ list,\ which\ is\ harder\ than\ talking\ about\ swapping\ two\ indices\ of\ a\ list.\ \ \ -\ Note\ that\ swapping\ is\ *significantly*\ more\ painful\ over\ typed\ patterns\ and\ terms\ than\ over\ untyped\ ones.\ \ If\ we\ index\ our\ vectors\ over\ a\ list\ of\ types,\ then\ we\ need\ to\ swap\ the\ types,\ and\ later\ swap\ them\ back\ (when\ reconstructing\ the\ term\ for\ evaluation),\ and\ then\ we\ need\ to\ unswap\ the\ terms\ in\ a\ way\ that\ has\ unswap\ (swap\ ls)\ on\ the\ term\ level\ *judgmentally*\ indexed\ on\ the\ type\ level\ over\ the\ same\ index-list\ as\ ls.\ \ This\ is\ painful,\ and\ is\ an\ example\ of\ pain\ caused\ by\ picking\ the\ wrong\ abstraction,\ in\ a\ way\ that\ causes\ exponential\ blow-up\ with\ each\ extra\ layer\ of\ dependency\ added.\ -\ The\ type\ of\ patterns\ \ \ -\ Patterns\ describe\ the\ LHS\ of\ rewrite\ rules,\ or\ the\ LHS\ of\ cases\ of\ a\ match\ statement.\ \ We\ index\ patterns\ over\ their\ type:}coq
Inductive pattern.base.type := var (p : positive) \textbar{} type\_base
(t : Compilers.base.type.base) \textbar{} prod (A B : type) \textbar{}
list (A : type).
\texttt{-\ The\ type\ of\ a\ pattern\ is\ either\ an\ arrow\ or\ a\ pattern.base.type,\ and\ a\ pattern.base.type\ is\ either\ a\ positive-indexed\ type-variable\ (written\ \textquotesingle{}1,\ \textquotesingle{}2,\ ...),\ or\ a\ product,\ a\ list,\ or\ a\ standard\ base.type\ (with\ no\ type-variables)\ \ \ -\ A\ pattern\ is\ either\ a\ wildcard,\ an\ identifier,\ or\ an\ application\ of\ patterns.\ \ Note\ that\ our\ rewriter\ only\ handles\ fully\ applied\ patterns,\ i.e.,\ only\ things\ of\ type\ `pattern\ (type.base\ t)`,\ not\ things\ of\ type\ `pattern\ t`.\ \ (This\ is\ not\ actually\ true.\ \ The\ rewriter\ can\ kind-of\ handle\ non-fully-applied\ patterns,\ but\ the\ Gallina\ won\textquotesingle{}t\ reduce\ in\ the\ right\ places,\ so\ we\ restrict\ ourselves\ to\ fully-applied\ patterns.)}coq
Inductive pattern \{ident : type -\textgreater{} Type\} : type
-\textgreater{} Type := \textbar{} Wildcard (t : type) : pattern t
\textbar{} Ident \{t\} (idc : ident t) : pattern t \textbar{} App \{s
d\} (f : pattern (s -\textgreater{} d)) (x : pattern s) : pattern d.
\texttt{-\ Pattern\ matching\ *compilation*\ to\ decision\ trees\ actually\ uses\ a\ more\ raw\ version\ of\ patterns,\ which\ come\ from\ these\ patterns:}coq
Module Raw. ~ Inductive pattern \{ident : Type\} := ~ \textbar{}
Wildcard ~ \textbar{} Ident (idc : ident) ~ \textbar{} App (f x :
pattern). End Raw.
\texttt{-\ This\ is\ because\ the\ pattern\ matching\ compilation\ algorithm\ is\ morally\ done\ over\ untyped\ patterns\ and\ terms.\ -\ The\ definitions\ \ \ -\ TODO:\ How\ much\ detail\ should\ I\ include\ about\ intermediate\ things?\ \ \ -\ Pattern\ matching\ compilation\ at\ the\ top-level,\ takes\ in\ a\ list\ of\ patterns,\ and\ spits\ out\ a\ decision\ tree.\ \ Note\ that\ each\ `TryLeaf`\ node\ in\ the\ decision\ tree\ has\ an\ index\ `k`,\ which\ denotes\ the\ index\ in\ this\ initial\ list\ of\ patterns\ of\ the\ chosen\ rewrite\ rule.\ \ \ -\ The\ workhorse\ of\ pattern\ matching\ compilation\ is\ `Fixpoint\ compile\_rewrites\textquotesingle{}\ (fuel\ :\ nat)\ (pattern\_matrix\ :\ list\ (nat\ *\ list\ rawpattern))\ :\ option\ decision\_tree`.\ \ This\ takes\ the\ list\ rows\ of\ the\ matrix\ of\ patterns,\ each\ one\ containing\ a\ list\ (vector\ in\ the\ original\ source\ paper)\ of\ patterns\ to\ match\ against,\ and\ the\ original\ index\ of\ the\ rewrite\ rule\ that\ this\ list\ of\ patterns\ came\ from.\ \ Note\ that\ all\ of\ these\ lists\ are\ in\ fact\ the\ same\ length,\ but\ we\ do\ not\ track\ this\ invariant\ anywhere,\ because\ it\ would\ add\ additional\ overhead\ for\ little-to-no\ gain.\ \ \ \ \ -\ The\ `compile\_rewrites\textquotesingle{}`\ procedure\ operates\ as\ follows:\ \ \ \ \ \ \ -\ If\ we\ are\ out\ of\ fuel,\ then\ we\ fail\ (return\ `None`)\ \ \ \ \ \ \ -\ If\ the\ `pattern\_matrix`\ is\ empty,\ we\ indicate\ `Failure`\ to\ match\ \ \ \ \ \ \ -\ If\ the\ first\ row\ is\ made\ up\ entirely\ of\ wildcards,\ we\ indicate\ to\ `TryLeaf`\ with\ the\ rewrite\ rule\ corresponding\ to\ the\ first\ row,\ and\ then\ to\ continue\ on\ with\ the\ decision\ tree\ corresponding\ to\ the\ rest\ of\ the\ rows.\ \ \ \ \ \ \ -\ If\ the\ first\ element\ of\ the\ first\ row\ is\ a\ wildcard,\ we\ `Swap`\ the\ first\ element\ with\ the\ index\ `i`\ of\ the\ first\ non-wildcard\ pattern\ in\ the\ first\ row.\ \ We\ then\ swap\ the\ first\ element\ with\ the\ `i`th\ element\ in\ every\ row\ of\ the\ matrix,\ and\ continue\ on\ with\ the\ result\ of\ compiling\ that\ matrix.\ \ \ \ \ \ \ -\ If\ the\ first\ element\ of\ the\ first\ row\ is\ not\ a\ wildcard,\ we\ issue\ a\ `Switch`.\ \ We\ first\ split\ the\ pattern\ matrix\ by\ finding\ the\ first\ row\ where\ the\ first\ element\ in\ that\ row\ is\ a\ wildcard,\ and\ aggregating\ that\ row\ and\ all\ rows\ after\ it\ into\ the\ `default\_pattern\_matrix`.\ \ We\ partition\ the\ rows\ before\ that\ row\ into\ the\ ones\ where\ the\ first\ element\ is\ an\ application\ node\ and\ the\ ones\ where\ the\ first\ element\ is\ an\ identifier\ node.\ \ The\ application\ nodes\ get\ split\ into\ the\ pattern\ for\ the\ function,\ and\ the\ pattern\ for\ the\ argument,\ and\ these\ two\ are\ prepended\ to\ the\ row.\ \ We\ group\ the\ rows\ that\ start\ with\ identifier\ patterns\ into\ groups\ according\ to\ the\ pattern\ identifier\ at\ the\ beginning\ of\ the\ row,\ and\ then\ take\ the\ tail\ of\ each\ of\ these\ rows.\ \ We\ then\ compile\ all\ of\ these\ decision\ trees\ to\ make\ up\ the\ Switch\ case.\ \ \ \ \ \ \ -\ In\ code,\ this\ looks\ like:}coq
Definition compile\_rewrites\_step ~ ~ ~ ~ ~ ~(compile\_rewrites : list
(nat * list rawpattern) -\textgreater{} option decision\_tree) ~ ~ ~ ~ ~
~(pattern\_matrix : list (nat * list rawpattern)) ~ : option
decision\_tree ~ := match pattern\_matrix with ~ ~ ~\textbar{} nil
=\textgreater{} Some Failure ~ ~ ~\textbar{} (n1, p1) :: ps ~ ~ ~
~=\textgreater{} match get\_index\_of\_first\_non\_wildcard p1 with ~ ~
~ ~ ~\textbar{} None (* p1 is all wildcards \emph{) ~ ~ ~ ~ ~
~=\textgreater{} (onfailure \textless{}- compile\_rewrites ps; ~ ~ ~ ~ ~
~ ~ ~ Some (TryLeaf n1 onfailure)) ~ ~ ~ ~ ~\textbar{} Some Datatypes.O
~ ~ ~ ~ ~ ~=\textgreater{} let `(pattern\_matrix,
default\_pattern\_matrix) := split\_at\_first\_pattern\_wildcard
pattern\_matrix in ~ ~ ~ ~ ~ ~ ~ default\_case \textless{}-
compile\_rewrites default\_pattern\_matrix; ~ ~ ~ ~ ~ ~ ~ ~ app\_case
\textless{}- (if contains\_pattern\_app pattern\_matrix ~ ~ ~ ~ ~ ~ ~ ~
~ ~ ~ ~ ~ ~ ~then option\_map Some (compile\_rewrites (Option.List.map
filter\_pattern\_app pattern\_matrix)) ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~else
Some None); ~ ~ ~ ~ ~ ~ ~ ~ let pidcs := get\_unique\_pattern\_ident
pattern\_matrix in ~ ~ ~ ~ ~ ~ ~ ~ let icases := Option.List.map ~ ~ ~ ~
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ (fun pidc =\textgreater{} option\_map (pair
pidc) (compile\_rewrites (Option.List.map (filter\_pattern\_pident pidc)
pattern\_matrix))) ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ pidcs in ~ ~ ~ ~ ~ ~
~ ~ Some (Switch icases app\_case default\_case) ~ ~ ~ ~ ~\textbar{}
Some i ~ ~ ~ ~ ~ ~=\textgreater{} let pattern\_matrix' ~ ~ ~ ~ ~ ~ ~ ~
~:= List.map ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ (fun `(n, ps) ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
~=\textgreater{} (n, ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ match swap\_list 0 i ps
with ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ \textbar{} Some ps' =\textgreater{} ps' ~
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ \textbar{} None =\textgreater{} nil (} should be
impossible *) ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ end)) ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
pattern\_matrix in ~ ~ ~ ~ ~ ~ ~d \textless{}- compile\_rewrites
pattern\_matrix'; ~ ~ ~ ~ ~ ~ ~ ~Some (Swap i d) ~ ~ ~ ~ ~end ~ ~
~end\%option.
\texttt{-\ We\ wrap\ `compile\_rewrites\textquotesingle{}`\ in\ a\ definition\ `compile\_rewrites`\ which\ extracts\ the\ well-typed\ patterns\ from\ a\ list\ of\ rewrite\ rules,\ associates\ them\ to\ indices,\ and\ strips\ the\ typing\ information\ off\ of\ the\ patterns\ to\ create\ raw\ (untyped)\ patterns.\ \#\#\#\ Decision\ Tree\ Evaluation\ -\ The\ next\ step\ in\ rewriting\ is\ to\ evaluate\ the\ decision\ tree\ to\ construct\ Gallina\ procedure\ that\ takes\ in\ an\ unknown\ (at\ rewrite-rule-compile-time)\ AST\ and\ performs\ the\ rewrite.\ \ This\ is\ broken\ up\ into\ two\ steps.\ \ The\ first\ step\ is\ to\ create\ the\ `match`\ structure\ that\ exposes\ all\ of\ the\ relevant\ information\ in\ the\ AST,\ and\ picks\ which\ rewrite\ rules\ to\ try\ in\ which\ order,\ and\ glues\ together\ failure\ and\ success\ of\ rewriting.\ \ The\ second\ step\ is\ to\ actually\ try\ to\ rewrite\ with\ a\ given\ rule,\ under\ the\ assumption\ that\ enough\ structure\ has\ been\ exposed.\ -\ Because\ we\ have\ multiple\ phases\ of\ compilation,\ we\ need\ to\ track\ which\ information\ we\ have\ (and\ therefore\ can\ perform\ reduction\ on)\ when\ we\ know\ only\ the\ patterns\ but\ not\ the\ AST\ being\ rewritten\ in,\ and\ which\ reductions\ have\ to\ wait\ until\ we\ know\ the\ AST.\ \ The\ way\ we\ track\ this\ information\ is\ by\ creating\ a\ wrapper\ type\ for\ ASTs.\ \ Note\ that\ the\ wrapper\ type\ is\ not\ indexed\ over\ type\ codes,\ because\ pattern\ matching\ compilation\ naturally\ operates\ over\ untyped\ terms,\ and\ adjusting\ it\ to\ work\ when\ indexed\ over\ a\ vector\ of\ types\ is\ painful.\ -\ The\ wrapper\ type,\ and\ revealing\ structure\ \ \ -\ Because\ different\ rewrite\ rules\ require\ different\ amounts\ of\ structure,\ we\ want\ to\ feed\ in\ only\ as\ much\ structure\ as\ is\ required\ for\ a\ given\ rewrite\ rule.\ \ For\ example,\ if\ we\ have\ one\ rewrite\ rule\ that\ is\ looking\ at\ `(?\ +\ ?)\ +\ ?`,\ and\ another\ that\ is\ looking\ at\ `?\ +\ 0`,\ we\ want\ to\ feed\ in\ the\ argument\ to\ the\ top-level\ `+`\ into\ the\ second\ rewrite\ rule,\ not\ a\ reassembled\ version\ of\ all\ of\ the\ different\ things\ an\ expression\ might\ be\ after\ checking\ for\ `+`-like\ structure\ of\ the\ first\ argument.\ \ If\ we\ did\ not\ do\ this,\ every\ rewrite\ rule\ replacement\ pattern\ would\ end\ up\ being\ as\ complicated\ as\ the\ deepest\ rewrite\ rule\ being\ considered,\ and\ we\ expect\ this\ would\ incur\ performance\ overhead.\ \ TODO:\ Perf\ testing?\ \ \ -\ Because\ we\ want\ our\ rewrite-rule-compilation\ to\ happen\ by\ reduction\ in\ Coq,\ we\ define\ many\ operations\ in\ CPS-style,\ so\ that\ we\ can\ carefully\ manage\ the\ exact\ judgmental\ structures\ of\ the\ discriminees\ of\ `match`\ statements.\ \ \ -\ An\ `Inductive\ rawexpr\ :\ Type`\ is\ one\ of\ the\ following\ things:}coq
Inductive rawexpr : Type := \textbar{} rIdent (known : bool) \{t\} (idc
: ident t) \{t'\} (alt : expr t') \textbar{} rApp (f x : rawexpr) \{t\}
(alt : expr t) \textbar{} rExpr \{t\} (e : expr t) \textbar{} rValue
\{t\} (e : value t).
\texttt{-\ `rIdent\ known\ t\ idc\ t\textquotesingle{}\ alt`\ -\ an\ identifier\ `idc\ :\ ident\ t`,\ whose\ unrevealed\ structure\ is\ `alt\ :\ expr\ t\textquotesingle{}`.\ \ The\ boolean\ `known`\ indicates\ if\ the\ identifier\ is\ known\ to\ be\ simple\ enough\ that\ we\ can\ fully\ reduce\ matching\ on\ its\ type\ arguments\ during\ rewrite-rule-compilation-time.\ \ For\ example,\ if\ we\ know\ an\ identifier\ to\ be\ `Z.add`\ (perhaps\ because\ we\ have\ matched\ on\ it\ already),\ we\ can\ reduce\ equality\ tests\ against\ the\ type.\ \ However,\ if\ an\ identifier\ is\ `nil\ T`,\ we\ are\ not\ guaranteed\ to\ know\ the\ type\ of\ the\ list\ judgmentally,\ and\ so\ we\ do\ not\ want\ to\ reduce\ type-equality\ tests\ against\ the\ list.\ \ Note\ that\ type-equality\ tests\ and\ type-transports\ are\ introduced\ as\ the\ least-evil\ thing\ we\ could\ find\ to\ cross\ the\ broken\ abstraction\ barrier\ between\ the\ untyped\ terms\ of\ pattern\ matching\ compilation,\ and\ the\ typed\ PHOASTs\ that\ we\ are\ operating\ on.\ \ \ \ \ -\ `rApp\ f\ x\ t\ alt`\ is\ the\ application\ of\ the\ `rawexpr`\ `f`\ to\ the\ `rawexpr`\ `x`,\ whose\ unrevealed\ structure\ is\ `alt\ :\ expr\ t`.\ \ \ \ \ -\ `rExpr\ t\ e`\ is\ a\ not-as-yet\ revealed\ expression\ `e\ :\ expr\ t`.\ \ \ \ \ -\ `rValue\ t\ e`\ is\ an\ unrevealed\ value\ `e\ :\ value\ t`.\ \ Such\ NBE-style\ values\ may\ contain\ thunked\ computation,\ such\ as\ deferred\ rewriting\ opportunities.\ \ This\ is\ essential\ for\ fully\ evaluating\ rewriting\ in\ expressions\ such\ as\ `map\ (fun\ x\ =\textgreater{}\ x\ +\ x\ +\ 0)\ ls`,\ where\ you\ want\ to\ rewrite\ away\ the\ `map`\ (when\ `ls`\ is\ a\ concrete\ list\ of\ cons\ cells),\ the\ `+\ 0`\ (always),\ and\ the\ `x\ +\ x`\ whenever\ `x`\ is\ a\ literal\ (which\ you\ do\ not\ know\ until\ you\ have\ distributed\ the\ function\ over\ the\ list).\ \ Allowing\ thunked\ computation\ in\ the\ ASTs\ allows\ us\ to\ do\ all\ of\ this\ rewriting\ in\ a\ single\ pass.\ \ \ -\ Revealing\ structure:\ `Definition\ reveal\_rawexpr\_cps\ (e\ :\ rawexpr)\ :\ \textasciitilde{}\textgreater{}\ rawexpr`\ \ \ \ \ -\ For\ the\ sake\ of\ proofs,\ we\ actually\ define\ a\ slightly\ more\ general\ version\ of\ revealing\ structure,\ which\ allows\ us\ to\ specify\ whether\ or\ not\ we\ have\ already\ matched\ against\ the\ putative\ identifier\ at\ the\ top-level\ of\ the\ `rawexpr`.\ \ \ \ \ -\ The\ code:}coq
Definition reveal\_rawexpr\_cps\_gen (assume\_known : option bool) ~ ~ ~
~ ~ ~(e : rawexpr) : \textasciitilde{}\textgreater{} rawexpr ~ := fun T
k ~ ~ ~=\textgreater{} match e, assume\_known with ~ ~ ~ ~ \textbar{}
rExpr \_ e as r, \emph{ ~ ~ ~ ~ \textbar{} rValue (type.base }) e as r,
\emph{ ~ ~ ~ ~ ~ =\textgreater{} match e with ~ ~ ~ ~ ~ ~ ~\textbar{}
expr.Ident t idc =\textgreater{} k (rIdent (match assume\_known with
Some known =\textgreater{} known \textbar{} } =\textgreater{} false end)
idc e) ~ ~ ~ ~ ~ ~ ~\textbar{} expr.App s d f x =\textgreater{} k (rApp
(rExpr f) (rExpr x) e) ~ ~ ~ ~ ~ ~ ~\textbar{} \_ =\textgreater{} k r ~
~ ~ ~ ~ ~ ~end ~ ~ ~ ~ \textbar{} rIdent \_ t idc t' alt, Some known
=\textgreater{} k (rIdent known idc alt) ~ ~ ~ ~ \textbar{} e', \_
=\textgreater{} k e' ~ ~ ~ ~ end.
\texttt{-\ To\ reveal\ a\ `rawexpr`,\ CPS-style,\ we\ first\ match\ on\ the\ `rawexpr`.\ \ \ \ \ \ \ -\ If\ it\ is\ an\ `rExpr`,\ or\ a\ `rValue`\ at\ a\ base\ type\ (and\ thus\ just\ an\ expression),\ we\ then\ match\ on\ the\ resulting\ expression.\ \ \ \ \ \ \ \ \ -\ If\ it\ is\ an\ identifier\ or\ an\ application\ node,\ we\ encode\ that,\ and\ then\ invoke\ the\ continuation\ \ \ \ \ \ \ \ \ -\ Otherwise,\ we\ invoke\ the\ continuation\ with\ the\ existing\ `rExpr`\ or\ `rValue`,\ because\ there\ was\ no\ more\ accessible\ structure\ to\ reveal;\ we\ do\ not\ allow\ matching\ on\ lambdas\ syntactically.\ \ \ \ \ \ \ -\ If\ it\ is\ an\ identifier\ and\ we\ are\ hard-coding\ the\ `known`\ status\ about\ if\ matches\ on\ the\ type\ of\ the\ identifier\ can\ be\ reduced,\ then\ we\ re-assemble\ the\ `rIdent`\ node\ with\ the\ new\ `known`\ status\ and\ invoke\ the\ continuation.\ \ \ \ \ \ \ -\ Otherwise,\ we\ just\ invoke\ the\ continuation\ on\ the\ reassembled\ `rawexpr`.\ \ \ \ \ -\ Correctness\ conditions\ \ \ \ \ \ \ -\ There\ are\ a\ couple\ of\ properties\ that\ must\ hold\ of\ `reveal\_rawexpr\_cps`.\ \ \ \ \ \ \ -\ The\ first\ is\ a\ `cps\_id`\ rule,\ which\ says\ that\ applying\ `reveal\_rawexpr\_cps`\ to\ any\ continuation\ is\ the\ same\ as\ invoking\ the\ continuation\ with\ `reveal\_rawexpr\_cps`\ applied\ to\ the\ identity\ continuation.\ \ \ \ \ \ \ -\ The\ next\ rule\ talks\ about\ a\ property\ we\ call\ `rawexpr\_types\_ok`.\ \ To\ say\ that\ this\ property\ holds\ is\ to\ say\ that\ the\ `rawexper`s\ are\ well-typed\ in\ accordance\ with\ the\ unrevealed\ expressions\ stored\ in\ the\ tree.\ \ \ \ \ \ \ \ \ -\ Code:}coq
Fixpoint rawexpr\_types\_ok (r : @rawexpr var) (t : type) : Prop ~ :=
match r with ~ ~ ~\textbar{} rExpr t' \emph{ ~ ~ ~\textbar{} rValue t' }
~ ~ ~ ~=\textgreater{} t' = t ~ ~ ~\textbar{} rIdent \_ t1 \_ t2 \emph{
~ ~ ~ ~=\textgreater{} t1 = t /~t2 = t ~ ~ ~\textbar{} rApp f x t' alt ~
~ ~ ~=\textgreater{} t' = t ~ ~ ~ ~ ~ /~match alt with ~ ~ ~ ~ ~ ~
~\textbar{} expr.App s d } \emph{ ~ ~ ~ ~ ~ ~ ~ ~=\textgreater{}
rawexpr\_types\_ok f (type.arrow s d) ~ ~ ~ ~ ~ ~ ~ ~ ~
/~rawexpr\_types\_ok x s ~ ~ ~ ~ ~ ~ ~\textbar{} } =\textgreater{} False
~ ~ ~ ~ ~ ~ ~end ~ ~ ~end.
\texttt{-\ We\ must\ then\ have\ that\ a\ `rawexpr`\ is\ `rawexpr\_types\_ok`\ if\ and\ only\ if\ the\ result\ of\ revealing\ one\ layer\ of\ structure\ via\ `reveal\_rawexpr\_cps`\ is\ `rawexpr\_types\_ok`.\ \ \ \ \ \ \ -\ We\ also\ define\ a\ relation\ `rawexpr\_equiv`\ which\ says\ that\ two\ `rawexpr`s\ represent\ the\ same\ expression,\ up\ to\ different\ amounts\ of\ revealed\ structure.\ \ \ \ \ \ \ \ \ -\ Code:}coq
Local Notation \texttt{e1\ ===\ e2} := (existT expr \_ e1 = existT expr
\_ e2) : type\_scope.

\begin{verbatim}
      Fixpoint rawexpr_equiv_expr {t0} (e1 : expr t0) (r2 : rawexpr) {struct r2} : Prop
        := match r2 with
           | rIdent _ t idc t' alt
             => alt === e1 /\ expr.Ident idc === e1
           | rApp f x t alt
             => alt === e1
                /\ match e1 with
                   | expr.App _ _ f' x'
                     => rawexpr_equiv_expr f' f /\ rawexpr_equiv_expr x' x
                   | _ => False
                   end
           | rExpr t e
           | rValue (type.base t) e
             => e === e1
           | rValue t e => False
           end.

      Fixpoint rawexpr_equiv (r1 r2 : rawexpr) : Prop
        := match r1, r2 with
           | rExpr t e, r
           | r, rExpr t e
           | rValue (type.base t) e, r
           | r, rValue (type.base t) e
             => rawexpr_equiv_expr e r
           | rValue t1 e1, rValue t2 e2
             => existT _ t1 e1 = existT _ t2 e2
           | rIdent _ t1 idc1 t'1 alt1, rIdent _ t2 idc2 t'2 alt2
             => alt1 === alt2
                /\ (existT ident _ idc1 = existT ident _ idc2)
           | rApp f1 x1 t1 alt1, rApp f2 x2 t2 alt2
             => alt1 === alt2
                /\ rawexpr_equiv f1 f2
                /\ rawexpr_equiv x1 x2
           | rValue _ _, _
           | rIdent _ _ _ _ _, _
           | rApp _ _ _ _, _
             => False
           end.
      ```
    - The relation `rawexpr_equiv` is effectively the recursive closure of `reveal_rawexpr_cps`, and we must prove that `reveal_rawexpr e` and `e` are `rawexpr_equiv`.
  <!---
  - Finally, we define a notation of `wf` for `rawexpr`s called `wf_rawexpr`, and we prove that if two `rawexpr`s are `wf_rawexpr`-related, then the results of calling `reveal_rawexpr` on both of them are `wf_rawexpr`-related.
    - The definition of `wf_rawexpr` is:
      ```coq
      Inductive wf_rawexpr : list { t : type & var1 t * var2 t }%type -> forall {t}, @rawexpr var1 -> @expr var1 t -> @rawexpr var2 -> @expr var2 t -> Prop :=
      | Wf_rIdent {t} G known (idc : ident t) : wf_rawexpr G (rIdent known idc (expr.Ident idc)) (expr.Ident idc) (rIdent known idc (expr.Ident idc)) (expr.Ident idc)
      | Wf_rApp {s d} G
                f1 (f1e : @expr var1 (s -> d)) x1 (x1e : @expr var1 s)
                f2 (f2e : @expr var2 (s -> d)) x2 (x2e : @expr var2 s)
        : wf_rawexpr G f1 f1e f2 f2e
          -> wf_rawexpr G x1 x1e x2 x2e
          -> wf_rawexpr G
                        (rApp f1 x1 (expr.App f1e x1e)) (expr.App f1e x1e)
                        (rApp f2 x2 (expr.App f2e x2e)) (expr.App f2e x2e)
      | Wf_rExpr {t} G (e1 e2 : expr t)
        : expr.wf G e1 e2 -> wf_rawexpr G (rExpr e1) e1 (rExpr e2) e2
      | Wf_rValue {t} G (v1 v2 : value t)
        : wf_value G v1 v2
          -> wf_rawexpr G (rValue v1) (reify v1) (rValue v2) (reify v2).
      ``` --->
\end{verbatim}

\begin{itemize}
\item
  Evaluating the decision tree
\item
  Decision tree evaluation is performed by a single monolithic recursive
  function:
  \texttt{Fixpoint\ eval\_decision\_tree\ \{T\}\ (ctx\ :\ list\ rawexpr)\ (d\ :\ decision\_tree)\ (cont\ :\ nat\ -\textgreater{}\ list\ rawexpr\ -\textgreater{}\ option\ T)\ \{struct\ d\}\ :\ option\ T}

\begin{verbatim}
Fixpoint eval_decision_tree {T} (ctx : list rawexpr) (d : decision_tree) (cont : nat -> list rawexpr -> option T) {struct d} : option T
  := match d with
     | TryLeaf k onfailure
       => let res := cont k ctx in
          match onfailure with
          | Failure => res
          | _ => res ;; (@eval_decision_tree T ctx onfailure cont)
          end
     | Failure => None
     | Switch icases app_case default_case
       => match ctx with
          | nil => None
          | ctx0 :: ctx'
            => let res
                   := reveal_rawexpr_cps
                        ctx0 _
                        (fun ctx0'
                         => match ctx0' with
                            | rIdent known t idc t' alt
                              => fold_right
                                   (fun '(pidc, icase) rest
                                    => let res
                                           := if known
                                              then
                                                (args <- invert_bind_args _ idc pidc;
                                                   @eval_decision_tree
                                                     T ctx' icase
                                                     (fun k ctx''
                                                      => cont k (rIdent
                                                                   (raw_pident_is_simple pidc)
                                                                   (raw_pident_to_typed pidc args) alt :: ctx'')))
                                              else
                                                @eval_decision_tree
                                                  T ctx' icase
                                                  (fun k ctx''
                                                   => option_bind'
                                                        (invert_bind_args_unknown _ idc pidc)
                                                        (fun args
                                                         => cont k (rIdent
                                                                      (raw_pident_is_simple pidc)
                                                                      (raw_pident_to_typed pidc args) alt :: ctx'')))
                                       in
                                       match rest with
                                       | None => Some res
                                       | Some rest => Some (res ;; rest)
                                       end)
                                   None
                                   icases;;;
                                   None
                            | rApp f x t alt
                              => match app_case with
                                 | Some app_case
                                   => @eval_decision_tree
                                        T (f :: x :: ctx') app_case
                                        (fun k ctx''
                                         => match ctx'' with
                                            | f' :: x' :: ctx'''
                                              => cont k (rApp f' x' alt :: ctx''')
                                            | _ => None
                                            end)
                                 | None => None
                                 end
                            | rExpr t e
                            | rValue t e
                              => None
                            end) in
               match default_case with
               | Failure => res
               | _ => res ;; (@eval_decision_tree T ctx default_case cont)
               end
          end
     | Swap i d'
       => match swap_list 0 i ctx with
          | Some ctx'
            => @eval_decision_tree
                 T ctx' d'
                 (fun k ctx''
                  => match swap_list 0 i ctx'' with
                     | Some ctx''' => cont k ctx'''
                     | None => None
                     end)
          | None => None
          end
     end%option.
\end{verbatim}
\item
  This function takes a list (vector in the original source paper)
  \texttt{ctx} of \texttt{rawexpr}s to match against, a
  \texttt{decision\_tree} \texttt{d} to evaluate, and a ``continuation''
  \texttt{cont} which tries a given rewrite rule based on the index of
  the rewrite rule (in the original list of rewrite rules) and the list
  of \texttt{rawexpr}s to feed into the rewrite rule. This continuation
  is threaded through the decision tree evaluation procedure, and each
  time we split up the structure of the pattern matrix (virtually, in
  the decision tree) and the list of \texttt{rawexpr}s (concretely, as
  an argument), we add a bit to the continuation that ``undoes'' the
  splitting. In the end, the top-level ``continuation'' gets fed a
  singleton list containing a \texttt{rawexpr} with enough structure for
  the rewrite rule it is trying. TODO: Figure out how to be more clear
  here; I anticipate this is unclear, and I'm not sure how to fix it
  except by randomly throwing more sentences in to try to explain it in
  various different ways.
\item
  Correctness conditions

  \begin{itemize}
  \tightlist
  \item
    There are two correctness conditions for
    \texttt{eval\_decision\_tree}: one for \texttt{wf}, and the other
    for \texttt{Interp}.
  \item
    The interpretation-correctness rule says that either
    \texttt{eval\_decision\_tree} returns \texttt{None}, or it returns
    the result of calling the continuation on some index and with some
    list of \texttt{rawexpr}s which is element-wise
    \texttt{rawexpr\_equiv} to the input list. In other words,
    \texttt{eval\_decision\_tree} does nothing more than revealing some
    structure, and then eventually calling the continuation (which is to
    be filled in with ``rewrite with this rule'') on the revealed
    \texttt{rawexpr}.
  \item
    The \texttt{wf} correctness condition is significantly more verbose
    to state, but it boils down to saying that as long as the
    continuation behaves ``the same'' (for some parameterized notion of
    ``the same'') on \texttt{wf\_rawexpr}-related \texttt{rawexpr}s,
    then \texttt{eval\_decision\_tree} will similarly behave ``the
    same'' on element-wise \texttt{wf\_rawexpr}-related lists of
    \texttt{rawexpr}s.
  \end{itemize}
\item
  Definition

  \begin{itemize}
  \tightlist
  \item
    The \texttt{eval\_decision\_tree} procedure proceeds recursively on
    the structure of the \texttt{decision\_tree}.
  \item
    If the decision tree is a \texttt{TryLeaf\ k\ onfailure}, then we
    try the continuation on the \texttt{k}th rewrite rule. If it fails
    (by returning \texttt{None}), we proceed with \texttt{onfailure}. In
    the code, there is a bit of extra care taken to simplify the
    resulting output code when \texttt{onfailure} is just
    \texttt{Failure}, i.e., no remaining matches to try. This probably
    does not impact performance, but it makes the output of the
    rewrite-rule-compilation procedure slightly easier to read and
    debug.
  \item
    If the decision tree is \texttt{Failure} return \texttt{None}, i.e.,
    we did not succeed in rewriting.
  \item
    If the decision tree starts with
    \texttt{Swap\ i\ d\textquotesingle{}}, we swap the first element
    with the \texttt{i}th element in the list of \texttt{rawexpr}s we
    are matching on (to mirror the swapping in the pattern matrix that
    happened when compiling the decision tree), and then continue on
    evaluating \texttt{d\textquotesingle{}}. We augment the continuation
    by reversing the swap in the list of \texttt{rawexpr}s passed in at
    the beginning, to cancel out the swap we did ``on the outside''
    before continuing with evaluation of the decision tree. Note that
    here we are jumping through some extra hoops to get the right
    reduction behavior at rewrite-rule-compilation time.
  \item
    If none of the above match, the decision tree must begin with
    \texttt{Switch\ icases\ app\_case\ default\_case}. In this case, we
    start by revealing the structure of the first element of the list of
    \texttt{rawexpr}s. (If there is no first element, which should never
    happen, we indicate failure by returning \texttt{None}.) In the
    continuation of \texttt{reveal\_rawexpr\_cps}, we check which sort
    of \texttt{rawexpr} we have. Note that in all cases of failure
    below, we try again with the \texttt{default\_case}.

    \begin{itemize}
    \tightlist
    \item
      If we have no accessible structure (\texttt{rExpr} or
      \texttt{rValue}), then we fail with \texttt{None}.
    \item
      If we have an application, we take the two arguments of
      \texttt{rApp}, the function and its argument, and prepend them to
      the tail of the list of \texttt{rawexpr}s. We then continue
      evaluation with \texttt{app\_case} (if it is non-\texttt{None}),
      and, in the continuation, we reassemble the \texttt{rawexpr} by
      taking the first two elements of the passed-in-list, and combining
      them in a new \texttt{rApp} node. We keep the unrevealed structure
      in \texttt{alt} the same as it was in the \texttt{rApp} that we
      started with.
    \item
      If we have an identifier, then we look at \texttt{icases}. We fold
      through the list of identifiers, looking to see if any of them
      match the identifier that we have. If the identifier is
      \texttt{known}, then we perform the match before evaluating the
      corresponding decision tree, because we want to avoid revealing
      useless structure. If the identifier is not \texttt{known}, then
      first we reveal all of the necessary structure for this identifier
      by continuing decision tree evaluation, and only then in the
      continuation do we try to match against the identifier.
    \item
      In both cases, we drop the first element of the list of
      \texttt{rawexpr}s being matched against when continuing
      evaluation, to mirror the dropping that happens in compilation of
      the decision tree. We then prepend a re-built identifier onto the
      head of the list inside the continuation. We have a table of which
      pattern identifiers have \texttt{known} types, and we have
      conversion functions between pattern identifiers and PHOAST
      identifiers (autogenerated in Python) which allow us to extract
      the arguments from the PHOAST identifier and re-insert them into
      the pattern identifier. For example, this will extract the list
      type from \texttt{nil} (because the pattern-identifier version
      does not specify what the type of the list is---we will say more
      about this in the next section), or the literal value from the
      \texttt{Literal} identifier, and allow recreating the fully-typed
      identifier from the pattern-identifier with these arguments. This
      allows more rewriter-compile-time reduction opportunities which
      allows us to deduplicate matches against the same identifier. Note
      that we have two different constants that we use for binding these
      arguments; they do the same thing, but one is reduced away
      completely at rewrite-rule-compilation time, and the other is
      preserved. \#\#\# Rewriting with a particular rewrite rule
    \end{itemize}
  \end{itemize}
\item
  The final big piece of the rewriter is to rewrite with a particular
  rule, given a \texttt{rawexpr} with enough revealed structure, a
  \texttt{pattern} against which we bind arguments, and a replacement
  rule which is a function indexed over the \texttt{pattern}. We saw
  above the inductive type of patterns. Let us now discuss the structure
  of the replacement rules.
\item
  Replacement rule types
\item
  The data for a replacement rule is indexed over a pattern-type
  \texttt{t} and a \texttt{p\ :\ pattern\ t}. It has three options, in
  addition to the actual replacement rule:

\begin{verbatim}
Record rewrite_rule_data {t} {p : pattern t} :=
  { rew_should_do_again : bool;
    rew_with_opt : bool;
    rew_under_lets : bool;
    rew_replacement : @with_unif_rewrite_ruleTP_gen value t p rew_should_do_again rew_with_opt rew_under_lets }.
\end{verbatim}

  \begin{itemize}
  \tightlist
  \item
    \texttt{rew\_should\_do\_again} determines whether or not to rewrite
    again in the output of this rewrite rule. For example, the rewrite
    rule for \texttt{flat\_map} on a concrete list of cons cells maps
    the function over the list, and joins the resulting list of lists
    with append. We want to rewrite again with the rule for
    \texttt{List.app} in the output of this replacement.
  \item
    \texttt{rew\_with\_opt} determines whether or not the rewrite rule
    might fail. For example, rewrite rules like
    \texttt{x\ +\ 0\ \textasciitilde{}\textgreater{}\ x} are encoded by
    talking about the pattern of a wildcard added to a literal, and say
    that the rewrite only succeeds if the literal is 0. Additionally, as
    another example, all rewrite rules involving casts fail if bounds on
    the input do not line up; in the pattern
    \texttt{Z.cast\ @\ ((Z.cast\ @\ ??)\ +\ (Z.cast\ @\ ??))} the cast
    node in front of an addition must be loose enough to hold the sum of
    the ranges taken from the two cast nodes in front of each of the
    wildcards.
  \item
    \texttt{rew\_under\_lets} determines whether or not the replacement
    rule returns an explicit \texttt{UnderLets} structure. This can be
    used for let-binding a part of the replacement value.
  \end{itemize}
\item
  The rewrite rule replacement itself is a function. It takes in first
  all type variables which are mentioned in the pattern, and then, in an
  in-order traversal of the pattern syntax tree, the non-type arguments
  for each identifier (e.g., interpreted values of literals, ranges of
  cast nodes) and a
  \texttt{value\ (pattern.type.subst\_default\ t\ evm)} for each
  wildcard of type \texttt{t} (that is, we plug in the known type
  variables into the pattern-type, and use \texttt{unit} for any unknown
  type variables). It may return a thing in the \texttt{option} and/or
  \texttt{UnderLets} monads, depending on \texttt{rew\_with\_opt} and
  \texttt{rew\_under\_lets}. Underneath these possible monads, it
  returns an \texttt{expr} of the correct type (we substitute the type
  variables we take in into the type of the pattern), whose \texttt{var}
  type is either \texttt{@value\ var} (if
  \texttt{rew\_should\_do\_again}) or \texttt{var} (if not
  \texttt{rew\_should\_do\_again}). The different \texttt{var} types are
  primarily to make the type of the output of the rewrite rule line up
  with the expression type that is fed into the rewriter as a whole. We
  have a number of definitions that describe this in a dependently typed
  mess:

  \begin{itemize}
  \tightlist
  \item
    We aggregate the type variables into a \texttt{PositiveSet.t} with
    \texttt{Fixpoint\ pattern.base.collect\_vars\ (t\ :\ base.type)\ :\ PositiveSet.t}
    and
    \texttt{Fixpoint\ pattern.type.collect\_vars\ (t\ :\ type)\ :\ PositiveSet.t}:
    \texttt{coq\ \ \ Module\ base.\ \ \ ~\ Fixpoint\ collect\_vars\ (t\ :\ type)\ :\ PositiveSet.t\ \ \ ~\ ~\ :=\ match\ t\ with\ \ \ ~\ ~\ ~\ ~\textbar{}\ type.var\ p\ =\textgreater{}\ PositiveSet.add\ p\ PositiveSet.empty\ \ \ ~\ ~\ ~\ ~\textbar{}\ type.type\_base\ t\ =\textgreater{}\ PositiveSet.empty\ \ \ ~\ ~\ ~\ ~\textbar{}\ type.prod\ A\ B\ =\textgreater{}\ PositiveSet.union\ (collect\_vars\ A)\ (collect\_vars\ B)\ \ \ ~\ ~\ ~\ ~\textbar{}\ type.list\ A\ =\textgreater{}\ collect\_vars\ A\ \ \ ~\ ~\ ~\ ~end.\ \ \ End\ base.\ \ \ Module\ type.\ \ \ ~\ ~\ Fixpoint\ collect\_vars\ (t\ :\ type)\ :\ PositiveSet.t\ \ \ ~\ ~\ ~\ :=\ match\ t\ with\ \ \ ~\ ~\ ~\ ~\ ~\textbar{}\ type.base\ t\ =\textgreater{}\ base.collect\_vars\ t\ \ \ ~\ ~\ ~\ ~\ ~\textbar{}\ type.arrow\ s\ d\ =\textgreater{}\ PositiveSet.union\ (collect\_vars\ s)\ (collect\_vars\ d)\ \ \ ~\ ~\ ~\ ~\ ~end.\ \ \ End\ type.}
  \item
    We quantify over type variables for each of the numbers in the
    \texttt{PositiveSet.t} and aggregate the bound types into a
    \texttt{PositiveMap.t} with \texttt{pattern.type.forall\_vars}. Note
    that we use the possibly ill-chosen abbreviation \texttt{EvarMap}
    for \texttt{PositiveMap.t\ Compilers.base.type}. ```coq Local
    Notation forall\_vars\_body K LS EVM0 ~ := (fold\_right ~ ~ ~ ~ (fun
    i k evm =\textgreater{} forall t : Compilers.base.type, k
    (PositiveMap.add i t evm)) ~ ~ ~ ~ K ~ ~ ~ ~ LS ~ ~ ~ ~ EVM0).
  \end{itemize}

  Definition forall\_vars (p : PositiveSet.t) (k : EvarMap
  -\textgreater{} Type) ~ := forall\_vars\_body k (List.rev
  (PositiveSet.elements p)) (PositiveMap.empty \_).
  \texttt{-\ We\ take\ in\ the\ context\ variable\ `pident\_arg\_types\ :\ forall\ t,\ pident\ t\ -\textgreater{}\ list\ Type`\ which\ describes\ the\ arguments\ bound\ for\ a\ given\ pattern\ identifier.\ -\ We\ then\ quantify\ over\ identifier\ arguments\ and\ wildcard\ values\ with\ `with\_unification\_resultT`:}coq
  Local Notation type\_of\_list\_cps ~ := (fold\_right (fun a K
  =\textgreater{} a -\textgreater{} K)).

  Fixpoint with\_unification\_resultT' \{var\} \{t\} (p : pattern t)
  (evm : EvarMap) (K : Type) : Type ~ := match p return Type with ~ ~
  ~\textbar{} pattern.Wildcard t =\textgreater{} var
  (pattern.type.subst\_default t evm) -\textgreater{} K ~ ~ ~\textbar{}
  pattern.Ident t idc =\textgreater{} type\_of\_list\_cps K
  (pident\_arg\_types t idc) ~ ~ ~\textbar{} pattern.App s d f x ~ ~ ~
  ~=\textgreater{} @with\_unification\_resultT`var \_ f evm
  (@with\_unification\_resultT' var \_ x evm K) ~ ~ ~end\%type.

  Definition with\_unification\_resultT \{var t\} (p : pattern t) (K :
  type -\textgreater{} Type) : Type ~ := pattern.type.forall\_vars ~ ~ ~
  ~(@pattern.collect\_vars \_ t p) ~ ~ ~ ~(fun evm =\textgreater{}
  @with\_unification\_resultT`var t p evm (K
  (pattern.type.subst\_default t evm))).
  \texttt{-\ Finally,\ we\ can\ define\ the\ type\ of\ rewrite\ replacement\ rules:}coq
  Local Notation deep\_rewrite\_ruleTP\_gen' should\_do\_again with\_opt
  under\_lets t ~ := (match (@expr.expr base.type ident (if
  should\_do\_again then value else var) t) with ~ ~ ~ \textbar{} x0
  =\textgreater{} match (if under\_lets then UnderLets x0 else x0) with
  ~ ~ ~ ~ ~ ~ ~ \textbar{} x1 =\textgreater{} if with\_opt then option
  x1 else x1 ~ ~ ~ ~ ~ ~ ~ end ~ ~ ~ end).

  Definition deep\_rewrite\_ruleTP\_gen (should\_do\_again : bool)
  (with\_opt : bool) (under\_lets : bool) t ~ :=
  deep\_rewrite\_ruleTP\_gen' should\_do\_again with\_opt under\_lets t.

  Definition with\_unif\_rewrite\_ruleTP\_gen \{var t\} (p : pattern t)
  (should\_do\_again : bool) (with\_opt : bool) (under\_lets : bool) ~
  := @with\_unification\_resultT var t p (fun t =\textgreater{}
  deep\_rewrite\_ruleTP\_gen' should\_do\_again with\_opt under\_lets
  t). \texttt{Whence\ we\ have}coq rew\_replacement :
  @with\_unif\_rewrite\_ruleTP\_gen value t p rew\_should\_do\_again
  rew\_with\_opt rew\_under\_lets ```
\item
  There are two steps to rewriting with a rule, both conceptually simple
  but in practice complicated by dependent types. We must unify a
  pattern with an expression, gathering binding data for the replacement
  rule as we go; and we must apply the replacement rule to the binding
  data (which is non-trivial because the rewrite rules are expressed as
  curried dependently-typed towers indexed over the rewrite rule
  pattern). In order to state the correctness conditions for gathering
  binding data, we must first talk about applying replacement rules to
  binding data.
\item
  Applying binding data
\item
  The general strategy for applying binding data is to define an
  uncurried package (sigma type, or dependent pair) holding all of the
  arguments, and to define an application function that applies the
  replacement rule (at various stages of construction) to the binding
  data package.
\item
  The uncurried package types

  \begin{itemize}
  \tightlist
  \item
    To turn a list of Types into a Type, we define
    \texttt{Local\ Notation\ type\_of\_list\ :=\ (fold\_right\ (fun\ a\ b\ =\textgreater{}\ prod\ a\ b)\ unit)}.
  \item
    The type \texttt{unification\_resultT\textquotesingle{}} describes
    the binding data for a pattern, given a map of pattern type
    variables to types:
    \texttt{coq\ \ \ Fixpoint\ unification\_resultT\textquotesingle{}\ \{var\}\ \{t\}\ (p\ :\ pattern\ t)\ (evm\ :\ EvarMap)\ :\ Type\ \ \ ~\ :=\ match\ p\ return\ Type\ with\ \ \ ~\ ~\ ~\textbar{}\ pattern.Wildcard\ t\ =\textgreater{}\ var\ (pattern.type.subst\_default\ t\ evm)\ \ \ ~\ ~\ ~\textbar{}\ pattern.Ident\ t\ idc\ =\textgreater{}\ type\_of\_list\ (pident\_arg\_types\ t\ idc)\ \ \ ~\ ~\ ~\textbar{}\ pattern.App\ s\ d\ f\ x\ \ \ ~\ ~\ ~\ ~=\textgreater{}\ @unification\_resultT\textquotesingle{}\ var\ \_\ f\ evm\ *\ @unification\_resultT\textquotesingle{}\ var\ \_\ x\ evm\ \ \ ~\ ~\ ~end\%type.}
  \item
    A \texttt{unification\_resultT} packages up the type variable
    replacement map with the bound values:
    \texttt{coq\ \ \ Definition\ unification\_resultT\ \{var\ t\}\ (p\ :\ pattern\ t)\ :\ Type\ \ \ ~\ :=\ \{\ evm\ :\ EvarMap\ \&\ @unification\_resultT\textquotesingle{}\ var\ t\ p\ evm\ \}.}
  \end{itemize}
\item
  The application functions

  \begin{itemize}
  \tightlist
  \item
    The definition \texttt{app\_type\_of\_list} applies a CPS-type
    \texttt{type\_of\_list\_cps} function to uncurried arguments:
    \texttt{coq\ \ \ Definition\ app\_type\_of\_list\ \{K\}\ \{ls\ :\ list\ Type\}\ (f\ :\ type\_of\_list\_cps\ K\ ls)\ (args\ :\ type\_of\_list\ ls)\ :\ K\ \ \ ~\ :=\ list\_rect\ \ \ ~\ ~\ ~\ ~(fun\ ls\ \ \ ~\ ~\ ~\ ~\ =\textgreater{}\ type\_of\_list\_cps\ K\ ls\ -\textgreater{}\ type\_of\_list\ ls\ -\textgreater{}\ K)\ \ \ ~\ ~\ ~\ ~(fun\ v\ \_\ =\textgreater{}\ v)\ \ \ ~\ ~\ ~\ ~(fun\ T\ Ts\ rec\ f\ x\ \ \ ~\ ~\ ~\ ~\ =\textgreater{}\ rec\ (f\ (fst\ x))\ (snd\ x))\ \ \ ~\ ~\ ~\ ~ls\ \ \ ~\ ~\ ~\ ~f\ args.}
  \item
    Given two different maps of type variables (another instance of
    abstraction-barrier-breaking), we can apply a
    \texttt{with\_unification\_resultT\textquotesingle{}} to a
    \texttt{unification\_resultT\textquotesingle{}} by inserting casts
    in the appropriate places:
    \texttt{coq\ \ \ (**\ TODO:\ Maybe\ have\ a\ fancier\ version\ of\ this\ that\ doesn\textquotesingle{}t\ \ \ ~\ ~\ ~actually\ need\ to\ insert\ casts,\ by\ doing\ a\ fixpoint\ on\ the\ \ \ ~\ ~\ ~list\ of\ elements\ /\ the\ evar\ map\ *)\ \ \ Fixpoint\ app\_transport\_with\_unification\_resultT\textquotesingle{}\_cps\ \{var\ t\ p\ evm1\ evm2\ K\}\ \{struct\ p\}\ \ \ ~\ :\ @with\_unification\_resultT\textquotesingle{}\ var\ t\ p\ evm1\ K\ -\textgreater{}\ @unification\_resultT\textquotesingle{}\ var\ t\ p\ evm2\ -\textgreater{}\ forall\ T,\ (K\ -\textgreater{}\ option\ T)\ -\textgreater{}\ option\ T\ \ \ ~\ :=\ fun\ f\ x\ T\ k\ \ \ ~\ ~\ ~=\textgreater{}\ match\ p\ return\ with\_unification\_resultT\textquotesingle{}\ p\ evm1\ K\ -\textgreater{}\ unification\_resultT\textquotesingle{}\ p\ evm2\ -\textgreater{}\ option\ T\ with\ \ \ ~\ ~\ ~\ ~\ \textbar{}\ pattern.Wildcard\ t\ \ \ ~\ ~\ ~\ ~\ ~\ =\textgreater{}\ fun\ f\ x\ \ \ ~\ ~\ ~\ ~\ ~\ ~\ ~=\textgreater{}\ (tr\ \textless{}-\ type.try\_make\_transport\_cps\ base.try\_make\_transport\_cps\ var\ \_\ \_;\ \ \ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~(tr\ \textless{}-\ tr;\ \ \ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ k\ (f\ (tr\ x)))\%option)\%cps\ \ \ ~\ ~\ ~\textbar{}\ pattern.Ident\ t\ idc\ =\textgreater{}\ fun\ f\ x\ =\textgreater{}\ k\ (app\_type\_of\_list\ f\ x)\ \ \ ~\ ~\ ~\textbar{}\ pattern.App\ s\ d\ f\ x\ \ \ ~\ ~\ ~\ ~=\textgreater{}\ fun\ F\ (xy\ :\ unification\_resultT\textquotesingle{}\ f\ \_\ *\ unification\_resultT\textquotesingle{}\ x\ \_)\ \ \ ~\ ~\ ~\ ~\ ~\ =\textgreater{}\ @app\_transport\_with\_unification\_resultT\textquotesingle{}\_cps\ \ \ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\_\ \_\ f\ \_\ \_\ \_\ F\ (fst\ xy)\ T\ \ \ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~(fun\ F\textquotesingle{}\ \ \ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ =\textgreater{}\ @app\_transport\_with\_unification\_resultT\textquotesingle{}\_cps\ \ \ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\_\ \_\ x\ \_\ \_\ \_\ F\textquotesingle{}\ (snd\ xy)\ T\ \ \ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~(fun\ x\textquotesingle{}\ =\textgreater{}\ k\ x\textquotesingle{}))\ \ \ ~\ ~\ ~end\%option\ f\ x.}
  \item
    We can apply a \texttt{forall\_vars} tower over the type variables
    in a pattern to a particular mapping of type variables to types,
    with a headache of dependently typed code: ```coq Fixpoint
    app\_forall\_vars\_gen \{k : EvarMap -\textgreater{} Type\} ~ ~ ~ ~
    ~ ~(evm : EvarMap) ~ ~ ~ ~ ~ ~(ls : list PositiveMap.key) ~ : forall
    evm0, forall\_vars\_body k ls evm0 ~ ~ ~ ~ ~ ~ ~ ~ ~-\textgreater{}
    option (k (fold\_right (fun i k evm' ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    ~ ~ ~ ~ ~ ~=\textgreater{} k (match PositiveMap.find i evm with Some
    v =\textgreater{} PositiveMap.add i v evm' \textbar{} None
    =\textgreater{} evm' end)) ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    (fun evm =\textgreater{} evm) ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    ~ ~ ls ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ evm0)) ~ := match
    ls return forall evm0, forall\_vars\_body k ls evm0 ~ ~ ~ ~ ~ ~ ~ ~
    ~ ~ ~ ~ ~ ~ ~ ~ ~ -\textgreater{} option (k (fold\_right (fun i k
    evm' ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    =\textgreater{} k (match PositiveMap.find i evm with Some v
    =\textgreater{} PositiveMap.add i v evm' \textbar{} None
    =\textgreater{} evm' end)) ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    ~ ~ ~ ~ ~ ~ ~ ~ ~(fun evm =\textgreater{} evm) ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ls ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~evm0)) with ~ ~ ~\textbar{} nil
    =\textgreater{} fun evm0 val =\textgreater{} Some val ~ ~
    ~\textbar{} cons x xs ~ ~ ~ ~=\textgreater{} match PositiveMap.find
    x evm as xt ~ ~ ~ ~ ~ ~ ~ ~ return (forall evm0, ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    ~ ~ ~ ~(forall t, fold\_right \_ k xs (PositiveMap.add x t evm0)) ~
    ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~-\textgreater{} option (k (fold\_right ~ ~
    ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~\_ \_ xs ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~match xt with ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    ~ ~ ~ ~ ~ ~\textbar{} Some v =\textgreater{} PositiveMap.add x v
    evm0 ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~\textbar{} None
    =\textgreater{} evm0 ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    ~end))) ~ ~ ~ ~ ~ with ~ ~ ~ ~ ~ \textbar{} Some v =\textgreater{}
    fun evm0 val =\textgreater{} @app\_forall\_vars\_gen k evm xs \_
    (val v) ~ ~ ~ ~ ~ \textbar{} None =\textgreater{} fun evm0 val
    =\textgreater{} None ~ ~ ~ ~ ~ end ~ ~ ~end.
  \end{itemize}

  Definition app\_forall\_vars \{p : PositiveSet.t\} \{k : EvarMap
  -\textgreater{} Type\} ~ ~ ~ ~ ~ ~(f : forall\_vars p k) ~ ~ ~ ~ ~
  ~(evm : EvarMap) ~ : option (k (fold\_right (fun i k evm' ~ ~ ~ ~ ~ ~
  ~ ~ ~ ~ ~ ~ ~ ~=\textgreater{} k (match PositiveMap.find i evm with
  Some v =\textgreater{} PositiveMap.add i v evm' \textbar{} None
  =\textgreater{} evm' end)) ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ (fun evm
  =\textgreater{} evm) ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ (List.rev
  (PositiveSet.elements p)) ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ (PositiveMap.empty
  \emph{))) ~ := @app\_forall\_vars\_gen ~ ~ ~ ~k evm ~ ~ ~ ~(List.rev
  (PositiveSet.elements p)) ~ ~ ~ ~(PositiveMap.empty }) ~ ~ ~ ~f.
  \texttt{-\ Finally,\ we\ can\ apply\ a\ `with\_unification\_resultT`\ to\ a\ `unification\_resultT`\ package\ in\ the\ obvious\ way,\ inserting\ casts\ as\ needed:}coq
  Definition app\_with\_unification\_resultT\_cps \{var t p K\} ~ :
  @with\_unification\_resultT var t p K -\textgreater{}
  @unification\_resultT var t p -\textgreater{} forall T, (\{ evm' : \_
  \& K (pattern.type.subst\_default t evm') \} -\textgreater{} option T)
  -\textgreater{} option T ~ := fun f x T k ~ ~ ~=\textgreater{} (f'
  \textless{}- pattern.type.app\_forall\_vars f (projT1 x); ~ ~ ~ ~ ~
  ~app\_transport\_with\_unification\_resultT'\emph{cps ~ ~ ~ ~ ~ ~ ~f'
  (projT2 x) } ~ ~ ~ ~ ~ ~ ~(fun fx ~ ~ ~ ~ ~ ~ ~ =\textgreater{} k
  (existT \_ \_ fx)))\%option. ```
\item
  Unifying patterns with expressions
\item
  First, we unify the types, in continuation-passing-style, returning an
  optional \texttt{PositiveMap.t} from type variable indices to types.

  \begin{itemize}
  \item
    This is actually done in two steps, so that rewrite-rule-compilation
    can reduce away all occurrences of patterns. First, we check that
    the expression has the right structure, and extract all of the
    relevant types both from the pattern and from the expression. Then
    we connect the types with \texttt{type.arrow} (used simply for
    convenience, so we don't have to unify lists of types, only
    individual types), and we unify the two resulting types, extracting
    a \texttt{PositiveMap.t} describing the assignments resulting from
    the unification problem.
  \item
    We first define a few helper definitions that should be
    self-explanatory:

    \begin{itemize}
    \tightlist
    \item
      The function \texttt{type\_of\_rawexpr} gets the type of a
      \texttt{rawexpr}:
      \texttt{coq\ \ \ Definition\ type\_of\_rawexpr\ (e\ :\ rawexpr)\ :\ type\ \ \ ~\ :=\ match\ e\ with\ \ \ ~\ ~\ ~\textbar{}\ rIdent\ \_\ t\ idc\ t\textquotesingle{}\ alt\ =\textgreater{}\ t\textquotesingle{}\ \ \ ~\ ~\ ~\textbar{}\ rApp\ f\ x\ t\ alt\ =\textgreater{}\ t\ \ \ ~\ ~\ ~\textbar{}\ rExpr\ t\ e\ =\textgreater{}\ t\ \ \ ~\ ~\ ~\textbar{}\ rValue\ t\ e\ =\textgreater{}\ t\ \ \ ~\ ~\ ~end.}
    \item
      The functions \texttt{pattern.base.relax} and
      \texttt{pattern.type.relax} take a PHOAST type and turn it into a
      pattern type, which just happens to have no pattern type
      variables.
      \texttt{Module\ base.\ \ \ ~\ Fixpoint\ relax\ (t\ :\ Compilers.base.type)\ :\ type\ \ \ ~\ ~\ :=\ match\ t\ with\ \ \ ~\ ~\ ~\ ~\textbar{}\ Compilers.base.type.type\_base\ t\ =\textgreater{}\ type.type\_base\ t\ \ \ ~\ ~\ ~\ ~\textbar{}\ Compilers.base.type.prod\ A\ B\ =\textgreater{}\ type.prod\ (relax\ A)\ (relax\ B)\ \ \ ~\ ~\ ~\ ~\textbar{}\ Compilers.base.type.list\ A\ =\textgreater{}\ type.list\ (relax\ A)\ \ \ ~\ ~\ ~\ ~end.\ \ \ End\ base.\ \ \ Module\ type.\ \ \ ~\ Fixpoint\ relax\ (t\ :\ type.type\ Compilers.base.type)\ :\ type\ \ \ ~\ ~\ :=\ match\ t\ with\ \ \ ~\ ~\ ~\ ~\textbar{}\ type.base\ t\ =\textgreater{}\ type.base\ (base.relax\ t)\ \ \ ~\ ~\ ~\ ~\textbar{}\ type.arrow\ s\ d\ =\textgreater{}\ type.arrow\ (relax\ s)\ (relax\ d)\ \ \ ~\ ~\ ~\ ~end.\ \ \ End\ type.}
    \end{itemize}
  \item
    The function responsible for checking the structure of patterns and
    extracting the types to be unified is
    \texttt{preunify\_types\ \{t\}\ (e\ :\ rawexpr)\ (p\ :\ pattern\ t)\ :\ \ option\ (option\ (ptype\ *\ type))}.
    It will return \texttt{None} if the structure does not match,
    \texttt{Some\ None} if the type of an identifier of known type in
    the \texttt{rawexpr} does not match the type of the identifier in
    the pattern (which is guaranteed to always be known, and thus this
    comparison is safe to perform at rewriter-rule-compilation time),
    and will return \texttt{Some\ (Some\ (t1,\ t2))} if the structures
    match, where \texttt{t1} and \texttt{t2} are the types to be
    unified.

\begin{verbatim}
Fixpoint preunify_types {t} (e : rawexpr) (p : pattern t) {struct p}
  : option (option (ptype * type))
  := match p, e with
     | pattern.Wildcard t, _
       => Some (Some (t, type_of_rawexpr e))
     | pattern.Ident pt pidc, rIdent known t idc _ _
       => if andb known (type.type_beq _ pattern.base.type.type_beq pt (pattern.type.relax t)) (* relies on evaluating to `false` if `known` is `false` *)
          then Some None
          else Some (Some (pt, t))
     | pattern.App s d pf px, rApp f x _ _
       => (resa <- @preunify_types _ f pf;
             resb <- @preunify_types _ x px;
             Some match resa, resb with
                  | None, None => None
                  | None, Some t
                  | Some t, None => Some t
                  | Some (a, a'), Some (b, b')
                    => Some (type.arrow a b, type.arrow a' b')
                  end)
     | pattern.Ident _ _, _
     | pattern.App _ _ _ _, _
       => None
     end%option.
\end{verbatim}
  \item
    We have two correctness conditions on \texttt{preunify\_types}.

    \begin{itemize}
    \tightlist
    \item
      The \texttt{wf} correctness condition says that if two
      \texttt{rawexpr}s are \texttt{wf\_rawexpr}-related, then the
      result of pre-unifying one of them with a pattern \texttt{p} is
      the same as the result of pre-unifying the other with the same
      pattern \texttt{p}.
    \item
      Second, for interpretation-correctness, we define a recursive
      proposition encoding the well-matching of patterns with
      \texttt{rawexpr}s under a given map of pattern type variables to
      types:
      \texttt{coq\ \ \ Fixpoint\ types\_match\_with\ (evm\ :\ EvarMap)\ \{t\}\ (e\ :\ rawexpr)\ (p\ :\ pattern\ t)\ \{struct\ p\}\ :\ Prop\ \ \ ~\ :=\ match\ p,\ e\ with\ \ \ ~\ ~\ ~\textbar{}\ pattern.Wildcard\ t,\ e\ \ \ ~\ ~\ ~\ ~=\textgreater{}\ pattern.type.subst\ t\ evm\ =\ Some\ (type\_of\_rawexpr\ e)\ \ \ ~\ ~\ ~\textbar{}\ pattern.Ident\ t\ idc,\ rIdent\ known\ t\textquotesingle{}\ \_\ \_\ \_\ \ \ ~\ ~\ ~\ ~=\textgreater{}\ pattern.type.subst\ t\ evm\ =\ Some\ t\textquotesingle{}\ \ \ ~\ ~\ ~\textbar{}\ pattern.App\ s\ d\ f\ x,\ rApp\ f\textquotesingle{}\ x\textquotesingle{}\ \_\ \_\ \ \ ~\ ~\ ~\ ~=\textgreater{}\ @types\_match\_with\ evm\ \_\ f\textquotesingle{}\ f\ \ \ ~\ ~\ ~\ ~\ ~\ /\textbackslash{}\ @types\_match\_with\ evm\ \_\ x\textquotesingle{}\ x\ \ \ ~\ ~\ ~\textbar{}\ pattern.Ident\ \_\ \_,\ \_\ \ \ ~\ ~\ ~\textbar{}\ pattern.App\ \_\ \_\ \_\ \_,\ \_\ \ \ ~\ ~\ ~\ ~=\textgreater{}\ False\ \ \ ~\ ~\ ~end.}
    \item
      Then we prove that for any map \texttt{evm} of pattern type
      variables to types, if \texttt{preunify\_types\ re\ p} returns
      \texttt{Some\ (Some\ (pt,\ t\textquotesingle{}))}, and the result
      of substituting into \texttt{pt} the pattern type variables in the
      given map is \texttt{t\textquotesingle{}}, then
      \texttt{types\_match\_with\ evm\ re\ p} holds. Symbolically, this
      is
      \texttt{coq\ \ \ Lemma\ preunify\_types\_to\_match\_with\ \{t\ re\ p\ evm\}\ \ \ ~\ :\ match\ @preunify\_types\ ident\ var\ pident\ t\ re\ p\ with\ \ \ ~\ ~\ \textbar{}\ Some\ None\ =\textgreater{}\ True\ \ \ ~\ ~\ \textbar{}\ Some\ (Some\ (pt,\ t\textquotesingle{}))\ =\textgreater{}\ pattern.type.subst\ pt\ evm\ =\ Some\ t\textquotesingle{}\ \ \ ~\ ~\ \textbar{}\ None\ =\textgreater{}\ False\ \ \ ~\ ~\ end\ \ \ ~\ ~\ -\textgreater{}\ types\_match\_with\ evm\ re\ p.}
    \end{itemize}
  \item
    In a possibly-gratuitous use of dependent typing to ensure that no
    uses of \texttt{PositiveMap.t} remain after
    rewrite-rule-compilation, we define a dependently typed data
    structure indexed over the pattern type which holds the mapping of
    each pattern type variable to a corresponding type. This step cannot
    be fully reduced at rewrite-rule-compilation time, because we may
    not know enough type structure in the \texttt{rawexpr}. We then
    collect these variables into a \texttt{PositiveMap.t}; this step
    \emph{can} be fully reduced at rewrite-rule-compilation time,
    because the pattern always has a well-defined type structure, and so
    we know \emph{which} type variables will have assignments in the
    \texttt{PositiveMap.t}, even if we don't necessarily know concretely
    (at rewrite-rule-compilation time) \emph{what} those type variables
    will be assigned to. We must also add a final check that
    substituting into the pattern type according the resulting
    \texttt{PositiveMap.t} actually does give the expected type; we do
    not want
    \texttt{\textquotesingle{}1\ -\textgreater{}\ \textquotesingle{}1}
    and \texttt{nat\ -\textgreater{}\ bool} to unify. We could check at
    each addition to the \texttt{PositiveMap.t} that we are not
    replacing one type with a different type. However, the proofs are
    much simpler if we simply do a wholesale check at the very end. We
    eventually perform this check in \texttt{unify\_types}.

    \begin{itemize}
    \tightlist
    \item
      We thus define the dependently typed structures: ``` Module base.
      ~ Fixpoint var\_types\_of (t : type) : Set ~ ~ := match t with ~ ~
      ~ ~\textbar{} type.var \_ =\textgreater{} Compilers.base.type ~ ~
      ~ ~\textbar{} type.type\_base \_ =\textgreater{} unit ~ ~ ~
      ~\textbar{} type.prod A B =\textgreater{} var\_types\_of A *
      var\_types\_of B ~ ~ ~ ~\textbar{} type.list A =\textgreater{}
      var\_types\_of A ~ ~ ~ ~end\%type.
    \end{itemize}

    ~ Fixpoint add\_var\_types\_cps \{t : type\} (v : var\_types\_of t)
    (evm : EvarMap) : \textasciitilde{}\textgreater{} EvarMap ~ ~ := fun
    T k ~ ~ ~ ~=\textgreater{} match t return var\_types\_of t
    -\textgreater{} T with ~ ~ ~ ~ ~ \textbar{} type.var p ~ ~ ~ ~ ~ ~
    =\textgreater{} fun t =\textgreater{} k (PositiveMap.add p t evm) ~
    ~ ~ ~ ~ \textbar{} type.prod A B ~ ~ ~ ~ ~ ~ =\textgreater{} fun
    '(a, b) =\textgreater{} @add\_var\_types\_cps A a evm \_ (fun evm
    =\textgreater{} @add\_var\_types\_cps B b evm \_ k) ~ ~ ~ ~ ~
    \textbar{} type.list A =\textgreater{} fun t =\textgreater{}
    @add\_var\_types\_cps A t evm \_ k ~ ~ ~ ~ ~ \textbar{}
    type.type\_base \_ =\textgreater{} fun \_ =\textgreater{} k evm ~ ~
    ~ ~ ~ end v. End base. Module type. ~ Fixpoint var\_types\_of (t :
    type) : Set ~ ~ := match t with ~ ~ ~ ~\textbar{} type.base t
    =\textgreater{} base.var\_types\_of t ~ ~ ~ ~\textbar{} type.arrow s
    d =\textgreater{} var\_types\_of s * var\_types\_of d ~ ~ ~
    ~end\%type.

    ~ Fixpoint add\_var\_types\_cps \{t : type\} (v : var\_types\_of t)
    (evm : EvarMap) : \textasciitilde{}\textgreater{} EvarMap ~ ~ := fun
    T k ~ ~ ~ ~=\textgreater{} match t return var\_types\_of t
    -\textgreater{} T with ~ ~ ~ ~ ~ \textbar{} type.base t
    =\textgreater{} fun v =\textgreater{} @base.add\_var\_types\_cps t v
    evm \_ k ~ ~ ~ ~ ~ \textbar{} type.arrow A B ~ ~ ~ ~ ~ ~
    =\textgreater{} fun `(a, b) =\textgreater{} @add\_var\_types\_cps A
    a evm \_ (fun evm =\textgreater{} @add\_var\_types\_cps B b evm \_
    k) ~ ~ ~ ~ ~ end v. End type.
    \texttt{-\ We\ can\ now\ write\ down\ the\ unifier\ that\ produces\ `var\_types\_of`\ from\ a\ unification\ problem;\ it\ is\ straightforward:}
    Module base. ~ Fixpoint unify\_extracted ~ ~ ~ ~ ~ ~(ptype : type)
    (etype : Compilers.base.type) ~ ~ : option (var\_types\_of ptype) ~
    ~ := match ptype, etype return option (var\_types\_of ptype) with ~
    ~ ~ ~\textbar{} type.var p, \_ =\textgreater{} Some etype ~ ~ ~
    ~\textbar{} type.type\_base t, Compilers.base.type.type\_base t' ~ ~
    ~ ~ ~=\textgreater{} if base.type.base\_beq t t' ~ ~ ~ ~ ~ ~ then
    Some tt ~ ~ ~ ~ ~ ~ else None ~ ~ ~ ~\textbar{} type.prod A B,
    Compilers.base.type.prod A' B' ~ ~ ~ ~ ~=\textgreater{} a
    \textless{}- unify\_extracted A A'; ~ ~ ~ ~ ~ ~ ~ b \textless{}-
    unify\_extracted B B'; ~ ~ ~ ~ ~ ~ ~ Some (a, b) ~ ~ ~ ~\textbar{}
    type.list A, Compilers.base.type.list A' ~ ~ ~ ~ ~=\textgreater{}
    unify\_extracted A A' ~ ~ ~ ~\textbar{} type.type\_base \emph{, } ~
    ~ ~ ~\textbar{} type.prod \_ \emph{, } ~ ~ ~ ~\textbar{} type.list
    \emph{, } ~ ~ ~ ~ ~=\textgreater{} None ~ ~ ~ ~end\%option. End
    base. Module type. ~ Fixpoint unify\_extracted ~ ~ ~ ~ ~ ~(ptype :
    type) (etype : type.type Compilers.base.type) ~ ~ : option
    (var\_types\_of ptype) ~ ~ := match ptype, etype return option
    (var\_types\_of ptype) with ~ ~ ~ ~\textbar{} type.base t, type.base
    t' ~ ~ ~ ~ ~=\textgreater{} base.unify\_extracted t t' ~ ~ ~
    ~\textbar{} type.arrow A B, type.arrow A' B' ~ ~ ~ ~
    ~=\textgreater{} a \textless{}- unify\_extracted A A'; ~ ~ ~ ~ ~ ~ ~
    b \textless{}- unify\_extracted B B'; ~ ~ ~ ~ ~ ~ ~ Some (a, b) ~ ~
    ~ ~\textbar{} type.base \emph{, } ~ ~ ~ ~\textbar{} type.arrow \_
    \emph{, } ~ ~ ~ ~ ~=\textgreater{} None ~ ~ ~ ~end\%option. End
    type. ```
  \item
    Finally, we can write down the type-unifier for patterns and
    \texttt{rawexpr}s. Note that the final equality check, described and
    motivated above, is performed in this function.

\begin{verbatim}
(* for unfolding help *)
Definition option_type_type_beq := option_beq (type.type_beq _ base.type.type_beq).

Definition unify_types {t} (e : rawexpr) (p : pattern t) : ~> option EvarMap
  := fun T k
     => match preunify_types e p with
        | Some (Some (pt, t))
          => match pattern.type.unify_extracted pt t with
             | Some vars
               => pattern.type.add_var_types_cps
                    vars (PositiveMap.empty _) _
                    (fun evm
                     => (* there might be multiple type variables which map to incompatible types; we check for that here *)
                       if option_type_type_beq (pattern.type.subst pt evm) (Some t)
                       then k (Some evm)
                       else k None)
             | None => k None
             end
        | Some None
          => k (Some (PositiveMap.empty _))
        | None => k None
        end.
\end{verbatim}
  \end{itemize}
\item
  Now that we have unified the types and gotten a \texttt{PositiveMap.t}
  of pattern type variables to types, we are ready to unify the
  patterns, and extract the identifier arguments and \texttt{value}s
  from the \texttt{rawexpr}. Because it would be entirely too painful to
  track at the type-level that the type unifier guarantees a match on
  structure and types, we instead sprinkle type transports all over this
  definition to get the types to line up. Here we pay the price of an
  imperfect abstraction barrier (that we have types lying around, and we
  rely in some places on types lining up, but do not track everywhere
  that types line up). Most of the other complications in this function
  come from (a) working in continuation-passing-style (for getting the
  right reduction behavior) or (b) tracking the differences between
  things we can reduce at rewrite-rule-compilation time, and things we
  can't.

  \begin{itemize}
  \item
    We first describe some helper definitions and context variables.
  \item
    The context variable
    \texttt{pident\_arg\_types\ :\ forall\ t,\ pident\ t\ -\textgreater{}\ list\ Type}
    describes for each pattern identifier what arguments should be bound
    for it.
  \item
    The context variables
    \texttt{(pident\_unify\ pident\_unify\_unknown\ :\ forall\ t\ t\textquotesingle{}\ (idc\ :\ pident\ t)\ (idc\textquotesingle{}\ :\ ident\ t\textquotesingle{}),\ option\ (type\_of\_list\ (pident\_arg\_types\ t\ idc)))}
    are the to-be-unfolded and not-to-be-unfolded versions of unifying a
    pattern identifier with a PHOAST identifier.
  \item
    We can convert a \texttt{rawexpr} into a \texttt{value} or an
    \texttt{expr}:

\begin{verbatim}
Definition expr_of_rawexpr (e : rawexpr) : expr (type_of_rawexpr e)
  := match e with
     | rIdent _ t idc t' alt => alt
     | rApp f x t alt => alt
     | rExpr t e => e
     | rValue t e => reify e
     end.
Definition value_of_rawexpr (e : rawexpr) : value (type_of_rawexpr e)
  := Eval cbv `expr_of_rawexpr` in
      match e with
      | rValue t e => e
      | e => reflect (expr_of_rawexpr e)
      end.
\end{verbatim}
  \item
    We can now write down the pattern-expression-unifier: ```coq
    Definition option\_bind' \{A B\} := @Option.bind A B. (* for help
    with unfolding *)
  \end{itemize}

  Fixpoint unify\_pattern' \{t\} (e : rawexpr) (p : pattern t) (evm :
  EvarMap) \{struct p\} ~ : forall T, (unification\_resultT' p evm
  -\textgreater{} option T) -\textgreater{} option T ~ := match p, e
  return forall T, (unification\_resultT' p evm -\textgreater{} option
  T) -\textgreater{} option T with ~ ~ ~\textbar{} pattern.Wildcard t',
  \emph{ ~ ~ ~ ~=\textgreater{} fun T k ~ ~ ~ ~ ~ =\textgreater{} (tro
  \textless{}- type.try\_make\_transport\_cps
  (@base.try\_make\_transport\_cps) value (type\_of\_rawexpr e)
  (pattern.type.subst\_default t' evm); ~ ~ ~ ~ ~ ~ ~ ~ (tr \textless{}-
  tro; ~ ~ ~ ~ ~ ~ ~ ~ ~ ~} \textless{}- pattern.type.subst t' evm; (*
  ensure that we did not fall into the default case *) ~ ~ ~ ~ ~ ~ ~ ~ ~
  ~(k (tr (value\_of\_rawexpr e))))\%option)\%cps ~ ~ ~\textbar{}
  pattern.Ident t pidc, rIdent known \_ idc \_ \emph{ ~ ~ ~
  ~=\textgreater{} fun T k ~ ~ ~ ~ ~ =\textgreater{} (if known ~ ~ ~ ~ ~
  ~ ~ then Option.bind (pident\_unify } \_ pidc idc) ~ ~ ~ ~ ~ ~ ~ else
  option\_bind' (pident\_unify\_unknown \_ \_ pidc idc)) ~ ~ ~ ~ ~ ~ ~
  ~k ~ ~ ~\textbar{} pattern.App s d pf px, rApp f x \_ \emph{ ~ ~ ~
  ~=\textgreater{} fun T k ~ ~ ~ ~ ~ =\textgreater{} @unify\_pattern`~ ~
  ~ ~ ~ ~ ~ ~\_ f pf evm T ~ ~ ~ ~ ~ ~ ~ ~(fun fv ~ ~ ~ ~ ~ ~ ~ ~
  =\textgreater{} @unify\_pattern' ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~} x px evm T ~ ~
  ~ ~ ~ ~ ~ ~ ~ ~ ~(fun xv ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ =\textgreater{} k (fv,
  xv))) ~ ~ ~\textbar{} pattern.Ident \_ \emph{, } ~ ~ ~\textbar{}
  pattern.App \_ \_ \_ \emph{, } ~ ~ ~ ~=\textgreater{} fun \_ k
  =\textgreater{} None ~ ~ ~end\%option.
  \texttt{-\ We\ have\ three\ correctness\ conditions\ on\ `unify\_pattern\textquotesingle{}`:\ \ \ \ \ -\ It\ must\ be\ the\ case\ that\ if\ we\ invoke\ `unify\_pattern\textquotesingle{}`\ with\ any\ continuation,\ the\ result\ is\ the\ same\ as\ invoking\ it\ with\ the\ continuation\ `Some`,\ binding\ the\ result\ in\ the\ option\ monad,\ and\ then\ invoking\ the\ continuation\ on\ the\ bound\ value.\ \ \ \ \ -\ There\ is\ the\ `wf`\ correctness\ condition,\ which\ says\ that\ if\ two\ `rawexpr`s\ are\ `wf\_rawexpr`-related,\ then\ invoking\ `unify\_pattern\textquotesingle{}`\ with\ the\ continuation\ `Some`\ either\ results\ in\ `None`\ on\ both\ of\ them,\ or\ it\ results\ in\ two\ `wf\_unification\_resultT\textquotesingle{}`-related\ results.\ \ We\ define\ `wf\_unification\_resultT\textquotesingle{}`\ as}coq
  Fixpoint wf\_value' \{with\_lets : bool\} G \{t : type\} : value'1
  with\_lets t -\textgreater{} value'2 with\_lets t -\textgreater{} Prop
  ~ := match t, with\_lets with ~ ~ ~\textbar{} type.base t, true
  =\textgreater{} UnderLets.wf (fun G' =\textgreater{} expr.wf G') G ~ ~
  ~\textbar{} type.base t, false =\textgreater{} expr.wf G ~ ~
  ~\textbar{} type.arrow s d, \_ ~ ~ ~ ~=\textgreater{} fun f1 f2 ~ ~ ~
  ~ ~ =\textgreater{} (forall seg G' v1 v2, ~ ~ ~ ~ ~ ~ ~ ~ ~G' = (seg
  ++ G)\%list ~ ~ ~ ~ ~ ~ ~ ~ ~-\textgreater{} @wf\_value`false seg s v1
  v2 ~ ~ ~ ~ ~ ~ ~ ~ ~-\textgreater{} @wf\_value' true G' d (f1 v1) (f2
  v2)) ~ ~ ~end.

\begin{verbatim}
  Definition wf_value G {t} : value1 t -> value2 t -> Prop := @wf_value' false G t.
  Definition wf_value_with_lets G {t} : value_with_lets1 t -> value_with_lets2 t -> Prop := @wf_value' true G t.

  Fixpoint related_unification_resultT' {var1 var2} (R : forall t, var1 t -> var2 t -> Prop) {t p evm}
    : @unification_resultT' var1 t p evm -> @unification_resultT' var2 t p evm -> Prop
    := match p in pattern.pattern t return @unification_resultT' var1 t p evm -> @unification_resultT' var2 t p evm -> Prop with
       | pattern.Wildcard t => R _
       | pattern.Ident t idc => eq
       | pattern.App s d f x
         => fun (v1 : unification_resultT' f evm * unification_resultT' x evm)
                (v2 : unification_resultT' f evm * unification_resultT' x evm)
            => @related_unification_resultT' _ _ R _ _ _ (fst v1) (fst v2)
               /\ @related_unification_resultT' _ _ R _ _ _ (snd v1) (snd v2)
       end.

  Definition wf_unification_resultT' (G : list {t1 : type & (var1 t1 * var2 t1)%type}) {t p evm}
    : @unification_resultT' value t p evm -> @unification_resultT' value t p evm -> Prop
    := @related_unification_resultT' _ _ (fun _ => wf_value G) t p evm.
  ```
- The interp-correctness condition is (a bit more than) a bit of a mouthful, and requires some auxiliary definitions.
  - It is a bit hard to say what makes an expression interp-related to an interpreted value.  Under the assumption of function extensionality, an expression is interp-related to a interpreted value if and only if the interpretation of the expression is equal to the interpreted value.  Thus `expr.interp_related` is an attempt to avoid function extensionality that is not fully successful, likely because I cannot say in words what exactly it is supposed to mean.  The definition is
    ```coq
    Section with_interp.
      Context {base_type : Type}
              {ident : type base_type -> Type}
              {interp_base_type : base_type -> Type}
              (interp_ident : forall t, ident t -> type.interp interp_base_type t).

      Fixpoint interp_related_gen
               {var : type base_type -> Type}
               (R : forall t, var t -> type.interp interp_base_type t -> Prop)
               {t} (e : @expr base_type ident var t)
        : type.interp interp_base_type t -> Prop
        := match e in expr t return type.interp interp_base_type t -> Prop with
           | expr.Var t v1 => R t v1
           | expr.App s d f x
             => fun v2
                => exists fv xv,
                    @interp_related_gen var R _ f fv
                    /\ @interp_related_gen var R _ x xv
                    /\ fv xv = v2
           | expr.Ident t idc
             => fun v2 => interp_ident _ idc == v2
           | expr.Abs s d f1
             => fun f2
                => forall x1 x2,
                    R _ x1 x2
                    -> @interp_related_gen var R d (f1 x1) (f2 x2)
           | expr.LetIn s d x f (* combine the App rule with the Abs rule *)
             => fun v2
                => exists fv xv,
                    @interp_related_gen var R _ x xv
                    /\ (forall x1 x2,
                           R _ x1 x2
                           -> @interp_related_gen var R d (f x1) (fv x2))
                    /\ fv xv = v2
           end.

      Definition interp_related {t} (e : @expr base_type ident (type.interp interp_base_type) t) : type.interp interp_base_type t -> Prop
        := @interp_related_gen (type.interp interp_base_type) (@type.eqv) t e.
    End with_interp.
    ```
  - A term in the `UnderLets` monad is `UnderLets.interp_related` to an interpreted value `v` if and only if converting the `UnderLets` expression to an `expr` (by replacing all of the `UnderLets`-let-binders with `expr`-let-binders) results in an expression that is `expr.interp_related` to `v`.
  - A `value` is `value_interp_related` to an interpreted value `v` whenever it sends `interp_related` things to `interp_related` things (the arrow case), and satisfies the appropriate notion of `interp_related` in the base case:
    ```coq
    Fixpoint value_interp_related {t with_lets} : @value' var with_lets t -> type.interp base.interp t -> Prop
      := match t, with_lets with
         | type.base _, true => UnderLets_interp_related
         | type.base _, false => expr_interp_related
         | type.arrow s d, _
           => fun (f1 : @value' _ _ s -> @value' _ _ d) (f2 : type.interp _ s -> type.interp _ d)
              => forall x1 x2,
                  @value_interp_related s _ x1 x2
                  -> @value_interp_related d _ (f1 x1) (f2 x2)
         end.
    ```
  - A `rawexpr` is `rawexpr_interp_related` to an interpreted value `v` if both the revealed and unrevealed structures are appropriately `interp_related` to `v`.  This one, too, is a bit hard to explain in any detail without simply displaying the code:
    ```coq
    Fixpoint rawexpr_interp_related (r1 : rawexpr) : type.interp base.interp (type_of_rawexpr r1) -> Prop
      := match r1 return type.interp base.interp (type_of_rawexpr r1) -> Prop with
         | rExpr _ e1
         | rValue (type.base _) e1
           => expr_interp_related e1
         | rValue t1 v1
           => value_interp_related v1
         | rIdent _ t1 idc1 t'1 alt1
           => fun v2
              => expr.interp ident_interp alt1 == v2
                 /\ existT expr t1 (expr.Ident idc1) = existT expr t'1 alt1
         | rApp f1 x1 t1 alt1
           => match alt1 in expr.expr t return type.interp base.interp t -> Prop with
              | expr.App s d af ax
                => fun v2
                   => exists fv xv (pff : type.arrow s d = type_of_rawexpr f1) (pfx : s = type_of_rawexpr x1),
                       @expr_interp_related _ af fv
                       /\ @expr_interp_related _ ax xv
                       /\ @rawexpr_interp_related f1 (rew pff in fv)
                       /\ @rawexpr_interp_related x1 (rew pfx in xv)
                       /\ fv xv = v2
              | _ => fun _ => False
              end
         end.
    ```
  - We can say when a `unification_resultT'` returning an `expr` whose `var` type is `@value (type.interp base.interp)` is interp-related to a `unification_resultT'` returning an `expr` whose `var` type is `type.interp base.interp` in the semi-obvious way:
    ```coq
    Local Notation var := (type.interp base.interp) (only parsing).

    Definition unification_resultT'_interp_related {t p evm}
      : @unification_resultT' (@value var) t p evm -> @unification_resultT' var t p evm -> Prop
      := related_unification_resultT' (fun t => value_interp_related).
    ```

  - We say that a `rawexpr`'s types are ok if the revealed and unrevealed structure match on the type level:
    ```coq
    Fixpoint rawexpr_types_ok (r : @rawexpr var) (t : type) : Prop
      := match r with
         | rExpr t' _
         | rValue t' _
           => t' = t
         | rIdent _ t1 _ t2 _
           => t1 = t /\ t2 = t
         | rApp f x t' alt
           => t' = t
              /\ match alt with
                 | expr.App s d _ _
                   => rawexpr_types_ok f (type.arrow s d)
                      /\ rawexpr_types_ok x s
                 | _ => False
                 end
         end.
    ```
  - We can define a transformation that takes in a `PositiveMap.t` of pattern type variables to types, together with a `PositiveSet.t` of type variables that we care about, and re-creates a new `PositiveMap.t` in accordance with the `PositiveSet.t`.  This is required to get some theorem types to line up, and is possibly an indication of a leaky abstraction barrier.
    ```coq
    Local Notation mk_new_evm0 evm ls
      := (fold_right
            (fun i k evm'
             => k match PositiveMap.find i evm with
                  | Some v => PositiveMap.add i v evm'
                  | None => evm'
                  end) (fun evm' => evm')
            (List.rev ls)) (only parsing).

    Local Notation mk_new_evm' evm ps
      := (mk_new_evm0
            evm
            (PositiveSet.elements ps)) (only parsing).

    Local Notation mk_new_evm evm ps
      := (mk_new_evm' evm ps (PositiveMap.empty _)) (only parsing).
    ```
  - Given a proof of `@types_match_with evm t re p` that the types of `re : rawexpr` and `p : pattern t` line up under the mapping `evm`, and a proof of `rawexpr_types_ok re (type_of_rawexpr re)`, we can prove that `type_of_rawexpr re = pattern.type.subst_default t mk_new_evm evm (pattern_collect_vars p)`.  We call this theorem `eq_type_of_rawexpr_of_types_match_with'`.
  - The final and perhaps most important auxiliary component is the notation of the default interpretation of a pattern.  This is a `with_unification_resultT'` which returns the obvious interpreted value after getting all of its data; application nodes become applications, identifiers get interpreted, wildcards are passed through.
    - This definition itself needs a few auxiliary definitions and context variables.
    - We have a context variable `(pident_to_typed : forall t (idc : pident t) (evm : EvarMap), type_of_list (pident_arg_types t idc) -> ident (pattern.type.subst_default t evm))` which takes in a pattern identifier, a mapping of type variables to types, and the arguments bound for that identifier, and returns a PHOAST identifier of the correct type.  We require that all type-instantiations of type variables of pattern identifiers be valid; this means that it doesn't matter if some type variables are missing from the mapping and we fill them in with `unit` instead.
    - We define `lam_type_of_list` to convert between the `cps` and non-cps versions of type lists:
      ```coq
      Local Notation type_of_list
        := (fold_right (fun a b => prod a b) unit).
      Local Notation type_of_list_cps
        := (fold_right (fun a K => a -> K)).

      Definition lam_type_of_list {ls K} : (type_of_list ls -> K) -> type_of_list_cps K ls
        := list_rect
             (fun ls => (type_of_list ls -> K) -> type_of_list_cps K ls)
             (fun f => f tt)
             (fun T Ts rec k t => rec (fun ts => k (t, ts)))
             ls.
      ```
    - We may now define the default interpretation:
      ```coq
      Fixpoint pattern_default_interp' {K t} (p : pattern t) evm {struct p} : (var (pattern.type.subst_default t evm) -> K) -> @with_unification_resultT' var t p evm K
        := match p in pattern.pattern t return (var (pattern.type.subst_default t evm) -> K) -> @with_unification_resultT' var t p evm K with
           | pattern.Wildcard t => fun k v => k v
           | pattern.Ident t idc
             => fun k
                => lam_type_of_list (fun args => k (ident_interp _(pident_to_typed _ idc _ args)))
           | pattern.App s d f x
             => fun k
                => @pattern_default_interp'
                     _ _ f evm
                     (fun ef
                      => @pattern_default_interp'
                           _ _ x evm
                           (fun ex
                            => k (ef ex)))
           end.
      ```
    - To define the unprimed version, which also accounts for the type variables, we must first define the lambda of `forall_vars`:
      ```coq
      Fixpoint lam_forall_vars_gen {k : EvarMap -> Type}
               (f : forall evm, k evm)
               (ls : list PositiveMap.key)
        : forall evm0, forall_vars_body k ls evm0
        := match ls return forall evm0, forall_vars_body k ls evm0 with
           | nil => f
           | cons x xs => fun evm t => @lam_forall_vars_gen k f xs _
           end.

      Definition lam_forall_vars {p : PositiveSet.t} {k : EvarMap -> Type}
                 (f : forall evm, k evm)
        : forall_vars p k
        := @lam_forall_vars_gen k f _ _.
      ```
    - Now we can define the default interpretation as a `with_unification_resultT`:
      ```coq
      Definition pattern_default_interp {t} (p : pattern t)
        : @with_unification_resultT var t p var
        := pattern.type.lam_forall_vars
             (fun evm
              => pattern_default_interp' p evm id).
      ```
  - Now, finally, we may state the interp-correctness condition of the pattern unifier:
    ```coq
    Lemma interp_unify_pattern' {t re p evm res v}
          (Hre : rawexpr_interp_related re v)
          (H : @unify_pattern' t re p evm _ (@Some _) = Some res)
          (Ht : @types_match_with evm t re p)
          (Ht' : rawexpr_types_ok re (type_of_rawexpr re))
          (evm' := mk_new_evm evm (pattern_collect_vars p))
          (Hty : type_of_rawexpr re = pattern.type.subst_default t evm'
           := eq_type_of_rawexpr_of_types_match_with' Ht Ht')
      : exists resv : _,
          unification_resultT'_interp_related res resv
          /\ app_transport_with_unification_resultT'_cps
               (pattern_default_interp' p evm' id) resv _ (@Some _)
             = Some (rew Hty in v).
    ```
\end{verbatim}

  \begin{itemize}
  \tightlist
  \item
    We can now glue the type pattern-unifier with the expression
    pattern-unifier in a straightforward way. Note that this pattern
    unifier also has three correctness conditions.
    \texttt{coq\ \ \ Definition\ unify\_pattern\ \{t\}\ (e\ :\ rawexpr)\ (p\ :\ pattern\ t)\ \ \ ~\ :\ forall\ T,\ (unification\_resultT\ p\ -\textgreater{}\ option\ T)\ -\textgreater{}\ option\ T\ \ \ ~\ :=\ fun\ T\ cont\ \ \ ~\ ~\ ~=\textgreater{}\ unify\_types\ \ \ ~\ ~\ ~\ ~\ ~\ e\ p\ \_\ \ \ ~\ ~\ ~\ ~\ ~\ (fun\ evm\ \ \ ~\ ~\ ~\ ~\ ~\ ~=\textgreater{}\ evm\ \textless{}-\ evm;\ \ \ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ unify\_pattern\textquotesingle{}\ \ \ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ e\ p\ evm\ T\ (fun\ v\ =\textgreater{}\ cont\ (existT\ \_\ \_\ v)))\%option.}
  \item
    The first correctness condition is again the cps-identity rule: if
    you invoke \texttt{unify\_pattern} with any continuation, that must
    be the same as invoking it with \texttt{Some}, binding the value in
    the option monad, and then invoking the continuation on the bound
    value.
  \item
    The \texttt{wf} correctness condition requires us to define a notion
    of \texttt{wf} for \texttt{unification\_resultT}.

    \begin{itemize}
    \tightlist
    \item
      We say that two \texttt{unification\_resultT}s are
      \texttt{wf}-related if their type-variable-maps are equal, and
      their identifier-arguments and wildcard binding values are
      appropriately \texttt{wf}-related: ```coq Definition
      related\_sigT\_by\_eq \{A P1 P2\} (R : forall x : A, P1 x
      -\textgreater{} P2 x -\textgreater{} Prop) ~ ~ ~ ~ ~ ~(x : @sigT A
      P1) (y : @sigT A P2) ~ : Prop ~ := \{ pf : projT1 x = projT1 y ~ ~
      ~\textbar{} R \_ (rew pf in projT2 x) (projT2 y) \}.
    \end{itemize}

    ~ ~ ~ ~ ~ Definition related\_unification\_resultT \{var1 var2\} (R
    : forall t, var1 t -\textgreater{} var2 t -\textgreater{} Prop) \{t
    p\} ~ ~ ~ ~ ~ ~ : @unification\_resultT \_ t p -\textgreater{}
    @unification\_resultT \_ t p -\textgreater{} Prop ~ ~ ~ ~ ~ ~ :=
    related\_sigT\_by\_eq (@related\_unification\_resultT' \_ \_ R t p).

    ~ ~ ~ ~ ~ Definition wf\_unification\_resultT (G : list \{t1 : type
    \& (var1 t1 * var2 t1)\%type\}) \{t p\} ~ ~ ~ ~ ~ ~ :
    @unification\_resultT (@value var1) t p -\textgreater{}
    @unification\_resultT (@value var2) t p -\textgreater{} Prop ~ ~ ~ ~
    ~ ~ := @related\_unification\_resultT \_ \_ (fun \_ =\textgreater{}
    wf\_value G) t p.
    \texttt{-\ The\ `wf`\ correctness\ condition\ is\ then\ that\ if\ we\ have\ two\ `wf\_rawexpr`-related\ `rawexpr`s,\ invoking\ `unify\_pattern`\ on\ each\ `rawexpr`\ to\ unify\ it\ with\ a\ singular\ pattern\ `p`,\ with\ continuation\ `Some`,\ results\ either\ in\ `None`\ in\ both\ cases,\ or\ in\ two\ `unification\_resultT`s\ which\ are\ `wf\_unification\_resultT`-related.\ -\ The\ interpretation\ correctness\ condition\ is\ a\ bit\ of\ a\ mouthful.\ \ \ -\ We\ say\ that\ two\ `unification\_resultT`s\ are\ interp-related\ if\ their\ mappings\ of\ type\ variables\ to\ types\ are\ equal,\ and\ their\ packages\ of\ non-type\ binding\ data\ are\ appropriately\ interp-related.}coq
    Local Notation var := (type.interp base.interp) (only parsing).

\begin{verbatim}
Definition unification_resultT_interp_related {t p}
  : @unification_resultT (@value var) t p -> @unification_resultT var t p -> Prop
  := related_unification_resultT (fun t => value_interp_related).
```
\end{verbatim}

    \begin{itemize}
    \item
      We can now state the interpretation correctness condition, which
      is a bit hard for me to meaningfully talk about in English words
      except by saying ``it does the right thing for a good notion of
      `right'\,'':

\begin{verbatim}
Lemma interp_unify_pattern {t re p v res}
      (Hre : rawexpr_interp_related re v)
      (Ht' : rawexpr_types_ok re (type_of_rawexpr re))
      (H : @unify_pattern t re p _ (@Some _) = Some res)
      (evm' := mk_new_evm (projT1 res) (pattern_collect_vars p))
  : exists resv,
    unification_resultT_interp_related res resv
    /\ exists Hty, (app_with_unification_resultT_cps (@pattern_default_interp t p) resv _ (@Some _) = Some (existT (fun evm => type.interp base.interp (pattern.type.subst_default t evm)) evm' (rew Hty in v))).
\end{verbatim}
    \end{itemize}
  \end{itemize}
\item
  Plugging in the arguments to a rewrite rule: Take 2
\item
  There is one more definition before we put all of the rewrite
  replacement rule pieces together: we describe a way to handle the fact
  that we are underneath zero, one, or two monads. The way we handle
  this is by just assuming that we are underneath two monads, and
  issuing monad-return statements as necessary to correct:

\begin{verbatim}
Definition normalize_deep_rewrite_rule {should_do_again with_opt under_lets t}
  : deep_rewrite_ruleTP_gen should_do_again with_opt under_lets t
    -> deep_rewrite_ruleTP_gen should_do_again true true t
  := match with_opt, under_lets with
     | true , true  => fun x => x
     | false, true  => fun x => Some x
     | true , false => fun x => (x <- x; Some (UnderLets.Base x))%option
     | false, false => fun x => Some (UnderLets.Base x)
     end%cps.
\end{verbatim}

  \begin{itemize}
  \tightlist
  \item
    The \texttt{wf} correctness condition, unsurprisingly, just says
    that if two rewrite replacement rules are appropriately
    \texttt{wf}-related, then their normalizations are too. This is
    quite verbose to state, though, because it requires traversing
    multiple layers of monads and pesky dependent types. TODO: should
    this code actually be included? ```coq Definition
    wf\_maybe\_do\_again\_expr ~ ~ ~ ~ ~ ~\{t\} ~ ~ ~ ~ ~
    ~\{rew\_should\_do\_again1 rew\_should\_do\_again2 : bool\} ~ ~ ~ ~
    ~ ~(G : list \{t : \_ \& (var1 t * var2 t)\%type\}) ~ : expr
    (var:=if rew\_should\_do\_again1 then @value var1 else var1) t ~ ~
    -\textgreater{} expr (var:=if rew\_should\_do\_again2 then @value
    var2 else var2) t ~ ~ -\textgreater{} Prop ~ := match
    rew\_should\_do\_again1, rew\_should\_do\_again2 ~ ~ ~ ~ ~ ~return
    expr (var:=if rew\_should\_do\_again1 then @value var1 else var1) t
    ~ ~ ~ ~ ~ ~ ~ ~ ~ -\textgreater{} expr (var:=if
    rew\_should\_do\_again2 then @value var2 else var2) t ~ ~ ~ ~ ~ ~ ~
    ~ ~ -\textgreater{} Prop ~ ~ ~with ~ ~ ~\textbar{} true, true ~ ~ ~
    ~=\textgreater{} fun e1 e2 ~ ~ ~ ~ ~ =\textgreater{} exists G', ~ ~
    ~ ~ ~ ~ ~ (forall t' v1' v2', List.In (existT \_ t' (v1', v2')) G'
    -\textgreater{} wf\_value G v1' v2') ~ ~ ~ ~ ~ ~ ~ /~expr.wf G' e1
    e2 ~ ~ ~\textbar{} false, false =\textgreater{} expr.wf G ~ ~
    ~\textbar{} \emph{, } =\textgreater{} fun \_ \_ =\textgreater{}
    False ~ ~ ~end.
  \end{itemize}

  Definition wf\_maybe\_under\_lets\_expr ~ ~ ~ ~ ~ ~\{T1 T2\} ~ ~ ~ ~ ~
  ~(P : list \{t : \_ \& (var1 t * var2 t)\%type\} -\textgreater{} T1
  -\textgreater{} T2 -\textgreater{} Prop) ~ ~ ~ ~ ~ ~(G : list \{t : \_
  \& (var1 t * var2 t)\%type\}) ~ ~ ~ ~ ~ ~\{rew\_under\_lets1
  rew\_under\_lets2 : bool\} ~ : (if rew\_under\_lets1 then UnderLets
  var1 T1 else T1) ~ ~ -\textgreater{} (if rew\_under\_lets2 then
  UnderLets var2 T2 else T2) ~ ~ -\textgreater{} Prop ~ := match
  rew\_under\_lets1, rew\_under\_lets2 ~ ~ ~ ~ ~ ~return (if
  rew\_under\_lets1 then UnderLets var1 T1 else T1) ~ ~ ~ ~ ~ ~ ~ ~ ~
  -\textgreater{} (if rew\_under\_lets2 then UnderLets var2 T2 else T2)
  ~ ~ ~ ~ ~ ~ ~ ~ ~ -\textgreater{} Prop ~ ~ ~with ~ ~ ~\textbar{} true,
  true ~ ~ ~ ~=\textgreater{} UnderLets.wf P G ~ ~ ~\textbar{} false,
  false ~ ~ ~ ~=\textgreater{} P G ~ ~ ~\textbar{} \emph{, }
  =\textgreater{} fun \_ \_ =\textgreater{} False ~ ~ ~end.

  Definition maybe\_option\_eq \{A B\} \{opt1 opt2 : bool\} (R : A
  -\textgreater{} B -\textgreater{} Prop) ~ : (if opt1 then option A
  else A) -\textgreater{} (if opt2 then option B else B) -\textgreater{}
  Prop ~ := match opt1, opt2 with ~ ~ ~\textbar{} true, true
  =\textgreater{} option\_eq R ~ ~ ~\textbar{} false, false
  =\textgreater{} R ~ ~ ~\textbar{} \emph{, } =\textgreater{} fun \_ \_
  =\textgreater{} False ~ ~ ~end.

  Definition wf\_deep\_rewrite\_ruleTP\_gen ~ ~ ~ ~ ~ ~(G : list \{t :
  \_ \& (var1 t * var2 t)\%type\}) ~ ~ ~ ~ ~ ~\{t\} ~ ~ ~ ~ ~
  ~\{rew\_should\_do\_again1 rew\_with\_opt1 rew\_under\_lets1 : bool\}
  ~ ~ ~ ~ ~ ~\{rew\_should\_do\_again2 rew\_with\_opt2 rew\_under\_lets2
  : bool\} ~ : deep\_rewrite\_ruleTP\_gen1 rew\_should\_do\_again1
  rew\_with\_opt1 rew\_under\_lets1 t ~ ~ -\textgreater{}
  deep\_rewrite\_ruleTP\_gen2 rew\_should\_do\_again2 rew\_with\_opt2
  rew\_under\_lets2 t ~ ~ -\textgreater{} Prop ~ := maybe\_option\_eq ~
  ~ ~ ~(wf\_maybe\_under\_lets\_expr ~ ~ ~ ~ ~
  wf\_maybe\_do\_again\_expr ~ ~ ~ ~ ~ G).

  Lemma wf\_normalize\_deep\_rewrite\_rule ~ ~ ~ \{G\} ~ ~ ~ \{t\} ~ ~ ~
  \{should\_do\_again1 with\_opt1 under\_lets1\} ~ ~ ~
  \{should\_do\_again2 with\_opt2 under\_lets2\} ~ ~ ~ \{r1 r2\} ~ ~ ~
  (Hwf : @wf\_deep\_rewrite\_ruleTP\_gen G t should\_do\_again1
  with\_opt1 under\_lets1 should\_do\_again2 with\_opt2 under\_lets2 r1
  r2) ~ : option\_eq ~ ~ ~ (UnderLets.wf (fun G' =\textgreater{}
  wf\_maybe\_do\_again\_expr G') G) ~ ~ ~
  (normalize\_deep\_rewrite\_rule r1) (normalize\_deep\_rewrite\_rule
  r2).
  ``\texttt{-\ We\ do\ not\ require\ any\ interp-correctness\ condition\ on}normalize\_deep\_rewrite\_rule\texttt{.\ \ Instead,\ we\ bake}normalize\_deep\_rewrite\_rule`
  into the per-rewrite-rule correctness conditions that a user must
  prove of every individual rewrite rule.
\item
  Actually, I lied. We need to define the type of a rewrite rule before
  we can say what it means for one to be correct.

  \begin{itemize}
  \tightlist
  \item
    An \texttt{anypattern} is a dynamically-typed pattern. This is used
    so that we can talk about \texttt{list}s of rewrite rules.
    \texttt{coq\ \ \ Record\ \textgreater{}\ anypattern\ \{ident\ :\ type\ -\textgreater{}\ Type\}\ \ \ ~\ :=\ \{\ type\_of\_anypattern\ :\ type;\ \ \ ~\ ~\ ~\ ~pattern\_of\_anypattern\ :\textgreater{}\ @pattern\ ident\ type\_of\_anypattern\ \}.}
  \item
    A \texttt{rewrite\_ruleT} is just a sigma of a pattern of any type,
    with \texttt{rewrite\_rule\_data} over that pattern:
    \texttt{coq\ \ \ Definition\ rewrite\_ruleTP\ \ \ ~\ :=\ (fun\ p\ :\ anypattern\ =\textgreater{}\ @rewrite\_rule\_data\ \_\ (pattern.pattern\_of\_anypattern\ p)).\ \ \ Definition\ rewrite\_ruleT\ :=\ sigT\ rewrite\_ruleTP.\ \ \ Definition\ rewrite\_rulesT\ \ \ ~\ :=\ (list\ rewrite\_ruleT).}
  \end{itemize}
\item
  We now define a helper definition to support rewriting again in the
  output of a rewrite rule. This is a separate definition mostly to make
  dependent types slightly less painful.

\begin{verbatim}
Definition maybe_do_againT (should_do_again : bool) (t : base.type)
  := ((@expr.expr base.type ident (if should_do_again then value else var) t) -> UnderLets (expr t)).
Definition maybe_do_again
           (do_again : forall t : base.type, @expr.expr base.type ident value t -> UnderLets (expr t))
           (should_do_again : bool) (t : base.type)
  := if should_do_again return maybe_do_againT should_do_again t
     then do_again t
     else UnderLets.Base.
\end{verbatim}

  \begin{itemize}
  \tightlist
  \item
    You might think that the correctness condition for this is trivial.
    And, indeed, the \texttt{wf} correctness condition is
    straightforward. In fact, we have already seen it above in
    \texttt{wf\_maybe\_do\_again\_expr}, as there is no proof, only a
    definition of what it means for things to be related depending on
    whether or not we are rewriting again.
  \item
    The interpretation correctness rule, on the other hand, is
    surprisingly subtle. You may have noticed above that
    \texttt{expr.interp\_related} is parameterized on an arbitrary
    \texttt{var} type, and an arbitrary relation between the
    \texttt{var} type and \texttt{type.interp\ base.interp}. I said that
    it is equivalent to equality of interpretation under the assumption
    of function extensionality, but that is only the case if
    \texttt{var} is instantiated to \texttt{type.interp} and the
    relation is equality or pointwise/extensional equivalence. Here, we
    must instantiate the \texttt{var} type with \texttt{@value\ var},
    and the relation with \texttt{value\_interp\_related}. We then prove
    that for any ``good'' notion of rewriting again, if our input value
    is interp-related to an interpreted value, the result of maybe
    rewriting again is also interp-related to that interpreted value.
    \texttt{coq\ \ \ Lemma\ interp\_maybe\_do\_again\ \ \ ~\ ~\ ~\ (do\_again\ :\ forall\ t\ :\ base.type,\ @expr.expr\ base.type\ ident\ value\ t\ -\textgreater{}\ UnderLets\ (expr\ t))\ \ \ ~\ ~\ ~\ (Hdo\_again\ :\ forall\ t\ e\ v,\ \ \ ~\ ~\ ~\ ~\ ~\ expr.interp\_related\_gen\ ident\_interp\ (fun\ t\ =\textgreater{}\ value\_interp\_related)\ e\ v\ \ \ ~\ ~\ ~\ ~\ ~\ -\textgreater{}\ UnderLets\_interp\_related\ (do\_again\ t\ e)\ v)\ \ \ ~\ ~\ ~\ \{should\_do\_again\ :\ bool\}\ \{t\ e\ v\}\ \ \ ~\ ~\ ~\ (He\ :\ (if\ should\_do\_again\ return\ @expr.expr\ \_\ \_\ (if\ should\_do\_again\ then\ \_\ else\ \_)\ \_\ -\textgreater{}\ \_\ \ \ ~\ ~\ ~\ ~\ ~\ ~\ ~then\ expr.interp\_related\_gen\ ident\_interp\ (fun\ t\ =\textgreater{}\ value\_interp\_related)\ \ \ ~\ ~\ ~\ ~\ ~\ ~\ ~else\ expr\_interp\_related)\ e\ v)\ \ \ ~\ :\ UnderLets\_interp\_related\ (@maybe\_do\_again\ \_\ \_\ do\_again\ should\_do\_again\ t\ e)\ v.}
  \end{itemize}
\item
  For the purposes of ensuring that reduction does not get blocked where
  it should not, we only allow rewrite rules to match on fully applied
  patterns, and to return base-typed expressions. We patch this broken
  abstraction barrier with

\begin{verbatim}
Local Notation base_type_of t
  := (match t with type.base t' => t' | type.arrow _ __ => base.type.unit end).
\end{verbatim}
\item
  Finally, we can define what it means to rewrite with a particular
  rewrite rule. It is messy primarily due to continuation passing style,
  optional values, and type casts. Note that we use
  \texttt{\textless{}-} to mean ``bind in whatever monad is the top-most
  scope''. Other than these complications, it just unifies the pattern
  with the \texttt{rawexpr} to get binding data, applies the rewrite
  replacement rule to the binding data, normalizes the applied rewrite
  replacement rule, calls the rewriter again on the output if it should,
  and returns the result.
  \texttt{coq\ Definition\ rewrite\_with\_rule\ \{t\}\ e\textquotesingle{}\ (pf\ :\ rewrite\_ruleT)\ ~\ :\ option\ (UnderLets\ (expr\ t))\ ~\ :=\ let\ \textquotesingle{}existT\ p\ f\ :=\ pf\ in\ ~\ ~\ ~let\ should\_do\_again\ :=\ rew\_should\_do\_again\ f\ in\ ~\ ~\ ~unify\_pattern\ ~\ ~\ ~\ ~e\textquotesingle{}\ (pattern.pattern\_of\_anypattern\ p)\ \_\ ~\ ~\ ~\ ~(fun\ x\ ~\ ~\ ~\ ~\ =\textgreater{}\ app\_with\_unification\_resultT\_cps\ ~\ ~\ ~\ ~\ ~\ ~\ ~(rew\_replacement\ f)\ x\ \_\ ~\ ~\ ~\ ~\ ~\ ~\ ~(fun\ f\textquotesingle{}\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ =\textgreater{}\ (tr\ \textless{}-\ type.try\_make\_transport\_cps\ (@base.try\_make\_transport\_cps)\ \_\ \_\ \_;\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ (tr\ \textless{}-\ tr;\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~(tr\textquotesingle{}\ \textless{}-\ type.try\_make\_transport\_cps\ (@base.try\_make\_transport\_cps)\ \_\ \_\ \_;\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ (tr\textquotesingle{}\ \textless{}-\ tr\textquotesingle{};\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~option\_bind\textquotesingle{}\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~(normalize\_deep\_rewrite\_rule\ (projT2\ f\textquotesingle{}))\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~(fun\ fv\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ =\textgreater{}\ Some\ (fv\ \textless{}-\/-\ fv;\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~fv\ \textless{}-\/-\ maybe\_do\_again\ should\_do\_again\ (base\_type\_of\ (type\_of\_rawexpr\ e\textquotesingle{}))\ (tr\ fv);\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~\ ~UnderLets.Base\ (tr\textquotesingle{}\ fv))\%under\_lets))\%option)\%cps)\%option)\%cps)\%cps).}

  \begin{itemize}
  \item
    We once again do not have any \texttt{wf} correctness condition for
    \texttt{rewrite\_with\_rule}; we merely unfold it as needed.
  \item
    To write down the correctness condition for
    \texttt{rewrite\_with\_rule}, we must first define what it means for
    \texttt{rewrite\_rule\_data} to be ``good''.
  \item
    Here is where we use \texttt{normalize\_deep\_rewrite\_rule}.
    Replacement rule data is good with respect to an interpretation
    value if normalizing it gives an appropriately interp-related thing
    to that interpretation value:

\begin{verbatim}
Local Notation var := (type.interp base.interp) (only parsing).

Definition deep_rewrite_ruleTP_gen_good_relation
           {should_do_again with_opt under_lets : bool} {t}
           (v1 : @deep_rewrite_ruleTP_gen should_do_again with_opt under_lets t)
           (v2 : var t)
  : Prop
  := let v1 := normalize_deep_rewrite_rule v1 in
     match v1 with
     | None => True
     | Some v1 => UnderLets.interp_related
                    ident_interp
                    (if should_do_again
                        return (@expr.expr base.type ident (if should_do_again then @value var else var) t) -> _
                     then expr.interp_related_gen ident_interp (fun t => value_interp_related)
                     else expr_interp_related)
                    v1
                    v2
     end.
\end{verbatim}
  \item
    Rewrite rule data is good if, for any interp-related binding data,
    the replacement function applied to the value-binding-data is
    interp-related to the default interpretation of the pattern applied
    to the interpreted-value-binding-data:

\begin{verbatim}
Definition rewrite_rule_data_interp_goodT
           {t} {p : pattern t} (r : @rewrite_rule_data t p)
  : Prop
  := forall x y,
    related_unification_resultT (fun t => value_interp_related) x y
    -> option_eq
         (fun fx gy
          => related_sigT_by_eq
               (fun evm
                => @deep_rewrite_ruleTP_gen_good_relation
                     (rew_should_do_again r) (rew_with_opt r) (rew_under_lets r) (pattern.type.subst_default t evm))
               fx gy)
         (app_with_unification_resultT_cps (rew_replacement r) x _ (@Some _))
         (app_with_unification_resultT_cps (pattern_default_interp p) y _ (@Some _)).
\end{verbatim}
  \item
    The interpretation correctness condition then says that if the
    rewrite rule is good, the \texttt{rawexpr} \texttt{re} has ok types,
    the ``rewrite again'' function is good, and
    \texttt{rewrite\_with\_rule} succeeds and outputs an expression
    \texttt{v1}, then \texttt{v1} is interp-related to any interpreted
    value which \texttt{re} is interp-related to:

\begin{verbatim}
Lemma interp_rewrite_with_rule
      (do_again : forall t : base.type, @expr.expr base.type ident value t -> UnderLets (expr t))
      (Hdo_again : forall t e v,
          expr.interp_related_gen ident_interp (fun t => value_interp_related) e v
          -> UnderLets_interp_related (do_again t e) v)
      (rewr : rewrite_ruleT)
      (Hrewr : rewrite_rule_data_interp_goodT (projT2 rewr))
      t e re v1 v2
      (Ht : t = type_of_rawexpr re)
      (Ht' : rawexpr_types_ok re (type_of_rawexpr re))
  : @rewrite_with_rule do_again t re rewr = Some v1
    -> rawexpr_interp_related re (rew Ht in v2)
    -> UnderLets_interp_related v1 v2.
\end{verbatim}

    \subsubsection{Tying it all together}\label{tying-it-all-together}
  \end{itemize}
\item
  We can now say what it means to rewrite with a decision tree in a
  given \texttt{rawexpr} \texttt{re}. We evaluate the decision tree, and
  whenever we are asked to try the \texttt{k}th rewrite rule, we look
  for it in our list of rewrite rules, and invoke
  \texttt{rewrite\_with\_rule}. By default, if rewriting fails, we will
  eventually return \texttt{expr\_of\_rawexpr\ re}.
  \texttt{coq\ \ \ Definition\ eval\_rewrite\_rules\ \ \ ~\ ~\ ~\ ~\ ~\ ~(d\ :\ decision\_tree)\ \ \ ~\ ~\ ~\ ~\ ~\ ~(rews\ :\ rewrite\_rulesT)\ \ \ ~\ ~\ ~\ ~\ ~\ ~(e\ :\ rawexpr)\ \ \ ~\ :\ UnderLets\ (expr\ (type\_of\_rawexpr\ e))\ \ \ ~\ :=\ let\ defaulte\ :=\ expr\_of\_rawexpr\ e\ in\ \ \ ~\ ~\ ~(eval\_decision\_tree\ \ \ ~\ ~\ ~\ ~\ (e::nil)\ d\ \ \ ~\ ~\ ~\ ~\ (fun\ k\ ctx\ \ \ ~\ ~\ ~\ ~\ ~=\textgreater{}\ match\ ctx\ return\ option\ (UnderLets\ (expr\ (type\_of\_rawexpr\ e)))\ with\ \ \ ~\ ~\ ~\ ~\ ~\ ~\ \textbar{}\ e\textquotesingle{}::nil\ \ \ ~\ ~\ ~\ ~\ ~\ ~\ ~\ =\textgreater{}\ (pf\ \textless{}-\ nth\_error\ rews\ k;\ rewrite\_with\_rule\ e\textquotesingle{}\ pf)\%option\ \ \ ~\ ~\ ~\ ~\ ~\ ~\ \textbar{}\ \_\ =\textgreater{}\ None\ \ \ ~\ ~\ ~\ ~\ ~\ ~\ end);;;\ \ \ ~\ ~\ ~\ ~\ (UnderLets.Base\ defaulte))\%option.}
\item
  To define the correctness conditions, we must first define what it
  means for lists of rewrite rules to be good.

  \begin{itemize}
  \tightlist
  \item
    For \texttt{wf}, we need to catch up a bit before getting to lists
    of rewrite rules. These say the obvious things: ```coq ~ ~ ~ ~ ~
    Definition wf\_with\_unif\_rewrite\_ruleTP\_gen ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    ~(G : list \{t : \_ \& (var1 t * var2 t)\%type\}) ~ ~ ~ ~ ~ ~ ~ ~ ~
    ~ ~\{t\} \{p : pattern t\} ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    ~\{rew\_should\_do\_again1 rew\_with\_opt1 rew\_under\_lets1\} ~ ~ ~
    ~ ~ ~ ~ ~ ~ ~ ~\{rew\_should\_do\_again2 rew\_with\_opt2
    rew\_under\_lets2\} ~ ~ ~ ~ ~ ~ : with\_unif\_rewrite\_ruleTP\_gen1
    p rew\_should\_do\_again1 rew\_with\_opt1 rew\_under\_lets1 ~ ~ ~ ~
    ~ ~ ~ -\textgreater{} with\_unif\_rewrite\_ruleTP\_gen2 p
    rew\_should\_do\_again2 rew\_with\_opt2 rew\_under\_lets2 ~ ~ ~ ~ ~
    ~ ~ -\textgreater{} Prop ~ ~ ~ ~ ~ ~ := fun f g ~ ~ ~ ~ ~ ~ ~
    ~=\textgreater{} forall x y, ~ ~ ~ ~ ~ ~ ~ ~ ~
    ~wf\_unification\_resultT G x y ~ ~ ~ ~ ~ ~ ~ ~ ~ ~-\textgreater{}
    option\_eq ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ (fun (fx : \{ evm : \_ \&
    deep\_rewrite\_ruleTP\_gen1 rew\_should\_do\_again1 rew\_with\_opt1
    rew\_under\_lets1 \_ \}) ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~(gy : \{ evm :
    \_ \& deep\_rewrite\_ruleTP\_gen2 rew\_should\_do\_again2
    rew\_with\_opt2 rew\_under\_lets2 \_ \}) ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    ~=\textgreater{} related\_sigT\_by\_eq ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    (fun \_ =\textgreater{} wf\_deep\_rewrite\_ruleTP\_gen G) fx gy) ~ ~
    ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ (app\_with\_unification\_resultT\_cps f x \_
    (@Some \emph{)) ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    (app\_with\_unification\_resultT\_cps g y } (@Some \_)).
  \end{itemize}

  ~ ~ ~ ~ ~ Definition wf\_rewrite\_rule\_data ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~(G :
  list \{t : \_ \& (var1 t * var2 t)\%type\}) ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~\{t\}
  \{p : pattern t\} ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~(r1 : @rewrite\_rule\_data1 t
  p) ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~(r2 : @rewrite\_rule\_data2 t p) ~ ~ ~ ~ ~ ~ :
  Prop ~ ~ ~ ~ ~ ~ := wf\_with\_unif\_rewrite\_ruleTP\_gen G
  (rew\_replacement r1) (rew\_replacement r2).

  \texttt{-\ Two\ lists\ of\ rewrite\ rules\ are\ `wf`\ related\ if\ they\ have\ the\ same\ length,\ and\ if\ any\ pair\ of\ rules\ in\ their\ zipper\ (`List.combine`)\ have\ equal\ patterns\ and\ `wf`-related\ data:}coq
  Definition rewrite\_rules\_goodT ~ ~ ~ ~ ~ ~(rew1 : rewrite\_rulesT1)
  (rew2 : rewrite\_rulesT2) ~ : Prop ~ := length rew1 = length rew2 ~ ~
  ~/~(forall p1 r1 p2 r2, ~ ~ ~ ~ ~ ~ List.In (existT \_ p1 r1, existT
  \_ p2 r2) (combine rew1 rew2) ~ ~ ~ ~ ~ ~ -\textgreater{} \{ pf : p1 =
  p2 ~ ~ ~ ~ ~ ~ ~ ~\textbar{} forall G, ~ ~ ~ ~ ~ ~ ~ ~ ~
  ~wf\_rewrite\_rule\_data ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~G ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
  ~(rew {[}fun tp =\textgreater{} @rewrite\_rule\_data1 \_
  (pattern.pattern\_of\_anypattern tp){]} pf in r1) ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
  ~r2 \}).
  \texttt{-\ A\ list\ of\ rewrite\ rules\ is\ good\ for\ interpretation\ if\ every\ rewrite\ rule\ in\ that\ list\ is\ good\ for\ interpretation:}coq
  Definition rewrite\_rules\_interp\_goodT ~ ~ ~ ~ ~ ~(rews :
  rewrite\_rulesT) ~ : Prop ~ := forall p r, ~ ~ List.In (existT \_ p r)
  rews ~ ~ -\textgreater{} rewrite\_rule\_data\_interp\_goodT r.
  \texttt{-\ The\ `wf`-correctness\ condition\ for\ `eval\_rewrite\_rules`\ says\ the\ obvious\ thing:\ for\ `wf`-related\ "rewrite\ again"\ functions,\ `wf`-related\ lists\ of\ rewrite\ rules,\ and\ `wf`-related\ `rawexpr`s,\ the\ output\ of\ `eval\_rewrite\_rules`\ is\ `wf`-related:}coq
  Lemma wf\_eval\_rewrite\_rules ~ ~ ~ (do\_again1 : forall t :
  base.type, @expr.expr base.type ident (@value var1) t -\textgreater{}
  @UnderLets var1 (@expr var1 t)) ~ ~ ~ (do\_again2 : forall t :
  base.type, @expr.expr base.type ident (@value var2) t -\textgreater{}
  @UnderLets var2 (@expr var2 t)) ~ ~ ~ (wf\_do\_again : forall G (t :
  base.type) e1 e2, ~ ~ ~ ~ ~ (exists G', (forall t v1 v2, List.In
  (existT \_ t (v1, v2)) G' -\textgreater{} Compile.wf\_value G v1 v2)
  /~expr.wf G' e1 e2) ~ ~ ~ ~ ~ -\textgreater{} UnderLets.wf (fun G'
  =\textgreater{} expr.wf G') G (@do\_again1 t e1) (@do\_again2 t e2)) ~
  ~ ~ (d : @decision\_tree raw\_pident) ~ ~ ~ (rew1 : rewrite\_rulesT1)
  (rew2 : rewrite\_rulesT2) ~ ~ ~ (Hrew : rewrite\_rules\_goodT rew1
  rew2) ~ ~ ~ (re1 : @rawexpr var1) (re2 : @rawexpr var2) ~ ~ ~ \{t\} G
  e1 e2 ~ ~ ~ (Hwf : @wf\_rawexpr G t re1 e1 re2 e2) ~ : UnderLets.wf ~
  ~ ~ (fun G' =\textgreater{} expr.wf G') ~ ~ ~ G ~ ~ ~ (rew {[}fun t
  =\textgreater{} @UnderLets var1 (expr t){]} (proj1
  (eq\_type\_of\_rawexpr\_of\_wf Hwf)) in (eval\_rewrite\_rules1
  do\_again1 d rew1 re1)) ~ ~ ~ (rew {[}fun t =\textgreater{} @UnderLets
  var2 (expr t){]} (proj2 (eq\_type\_of\_rawexpr\_of\_wf Hwf)) in
  (eval\_rewrite\_rules2 do\_again2 d rew2 re2)).
  \texttt{-\ The\ interpretation\ correctness\ is\ also\ the\ expected\ one:\ for\ a\ "rewrite\ again"\ function\ that\ preserves\ interp-relatedness,\ a\ good-for-interp\ list\ of\ rewrite\ rules,\ a\ `rawexpr`\ whose\ types\ are\ ok\ and\ which\ is\ interp-related\ to\ a\ value\ `v`,\ the\ result\ of\ `eval\_rewrite\_rules`\ is\ interp-related\ to\ `v`:}coq
  Lemma interp\_eval\_rewrite\_rules ~ ~ ~ (do\_again : forall t :
  base.type, @expr.expr base.type ident value t -\textgreater{}
  UnderLets (expr t)) ~ ~ ~ (d : decision\_tree) ~ ~ ~ (rew\_rules :
  rewrite\_rulesT) ~ ~ ~ (re : rawexpr) v ~ ~ ~ (Hre :
  rawexpr\_types\_ok re (type\_of\_rawexpr re)) ~ ~ ~ (res :=
  @eval\_rewrite\_rules do\_again d rew\_rules re) ~ ~ ~ (Hdo\_again :
  forall t e v, ~ ~ ~ ~ ~ expr.interp\_related\_gen ident\_interp (fun t
  =\textgreater{} value\_interp\_related) e v ~ ~ ~ ~ ~ -\textgreater{}
  UnderLets\_interp\_related (do\_again t e) v) ~ ~ ~ (Hr :
  rawexpr\_interp\_related re v) ~ ~ ~ (Hrew\_rules :
  rewrite\_rules\_interp\_goodT rew\_rules) ~ :
  UnderLets\_interp\_related res v. ```
\item
  Only one piece remains (other than defining particular rewrite rules
  and proving them good). If you were following carefully, you might
  note that \texttt{eval\_rewrite\_rules} takes in a \texttt{rawexpr}
  and produces an \texttt{UnderLets\ expr}, while
  \texttt{rewrite\_bottomup} expects a function
  \texttt{rewrite\_head\ :\ forall\ t\ (idc\ :\ ident\ t),\ value\_with\_lets\ t}.
  From a PHOAST identifier, we must construct a
  \texttt{value\_with\_lets} which collects all of the \texttt{value}
  arguments to the identifier and performs \texttt{eval\_rewrite\_rules}
  once the identifier is fully applied. We call this function
  \texttt{assemble\_identifier\_rewriters}, and it is built out of a
  small number of pieces.
\item
  We define a convenience function that takes a \texttt{value} and an
  \texttt{expr} at the same type, and produces a \texttt{rawexpr} by
  using \texttt{rExpr} on the expr if the type is a base type, and
  \texttt{rValue} on the \texttt{value} otherwise. Morally, the
  \texttt{expr} and the \texttt{value} should be the same term, modulo
  \texttt{reify} and/or \texttt{reflect}:

\begin{verbatim}
Definition rValueOrExpr2 {t} : value t -> expr t -> rawexpr
  := match t with
     | type.base _ => fun v e => @rExpr _ e
     | type.arrow _ _ => fun v e => @rValue _ v
     end.
\end{verbatim}
\item
  We take in a context variable (eventually autogenerated by python)
  which eta-iota-expands a function over an identifier by producing a
  \texttt{match} on the identifier. Its specification is that it is
  pointwise-equal to function application; it exists entirely so that we
  can perform rewrite-rule-compilation time reduction on the rewrite
  rules by writing down the cases for every head identifier separately.
  The context variable is
  \texttt{eta\_ident\_cps\ :\ forall\ \{T\ :\ type.type\ base.type\ -\textgreater{}\ Type\}\ \{t\}\ (idc\ :\ ident\ t)\ (f\ :\ forall\ t\textquotesingle{},\ ident\ t\textquotesingle{}\ -\textgreater{}\ T\ t\textquotesingle{}),\ T\ t},
  and we require that
  \texttt{forall\ T\ t\ idc\ f,\ @eta\_ident\_cps\ T\ t\ idc\ f\ =\ f\ t\ idc}.
\item
  We can now carefully define the function that turns
  \texttt{eval\_rewrite\_rules} into a thing that can be plugged into
  \texttt{rewrite\_head}. We take care to preserve thunked computation
  in \texttt{rValue} nodes, while describing the alternative structure
  via \texttt{reify}. In general, the stored values are only
  interp-related to the same things that the ``unrevealed structure''
  expressions are interp-related to. There is no other relation (that
  we've found) between the values and the expressions, and this caused a
  great deal of pain when trying to specify the interpretation
  correctness properties.

\begin{verbatim}
Section with_do_again.
  Context (dtree : decision_tree)
          (rewrite_rules : rewrite_rulesT)
          (default_fuel : nat)
          (do_again : forall t : base.type, @expr.expr base.type ident value t -> UnderLets (expr t)).

  Let dorewrite1 (e : rawexpr) : UnderLets (expr (type_of_rawexpr e))
    := eval_rewrite_rules do_again dtree rewrite_rules e.

  Fixpoint assemble_identifier_rewriters' (t : type) : forall e : rawexpr, (forall P, P (type_of_rawexpr e) -> P t) -> value_with_lets t
    := match t return forall e : rawexpr, (forall P, P (type_of_rawexpr e) -> P t) -> value_with_lets t with
       | type.base _
         => fun e k => k (fun t => UnderLets (expr t)) (dorewrite1 e)
       | type.arrow s d
         => fun f k (x : value' _ _)
            => let x' := reify x in
               @assemble_identifier_rewriters' d (rApp f (rValueOrExpr2 x x') (k _ (expr_of_rawexpr f) @ x'))%expr (fun _ => id)
       end%under_lets.

  Definition assemble_identifier_rewriters {t} (idc : ident t) : value_with_lets t
    := eta_ident_cps _ _ idc (fun t' idc' => assemble_identifier_rewriters' t' (rIdent true idc' #idc') (fun _ => id)).
End with_do_again.
\end{verbatim}

  \begin{itemize}
  \tightlist
  \item
    The \texttt{wf}-correctness condition for
    \texttt{assemble\_identifier\_rewriters\textquotesingle{}} says that
    if two \texttt{rawexpr}s are \texttt{wf}-related, and both
    continuations are extensionally/pointwise equal to the identity
    function transported across the appropriate equality proof, then the
    results of
    \texttt{assemble\_identifier\_rewriters\textquotesingle{}} are
    \texttt{wf}-related, under the assumption that the ``rewrite again''
    functions are appropriately \texttt{wf}-related and the list of
    rewrite rules is good. ```coq Section with\_do\_again. ~ Context
    (dtree : @decision\_tree raw\_pident) ~ ~ ~ ~ ~ (rew1 :
    rewrite\_rulesT1) ~ ~ ~ ~ ~ (rew2 : rewrite\_rulesT2) ~ ~ ~ ~ ~
    (Hrew : rewrite\_rules\_goodT rew1 rew2) ~ ~ ~ ~ ~ (do\_again1 :
    forall t : base.type, @expr.expr base.type ident (@value var1) t
    -\textgreater{} @UnderLets var1 (@expr var1 t)) ~ ~ ~ ~ ~
    (do\_again2 : forall t : base.type, @expr.expr base.type ident
    (@value var2) t -\textgreater{} @UnderLets var2 (@expr var2 t)) ~ ~
    ~ ~ ~ (wf\_do\_again : forall G G' (t : base.type) e1 e2, ~ ~ ~ ~ ~
    ~ ~ (forall t v1 v2, List.In (existT \_ t (v1, v2)) G'
    -\textgreater{} Compile.wf\_value G v1 v2) ~ ~ ~ ~ ~ ~ ~
    -\textgreater{} expr.wf G' e1 e2 ~ ~ ~ ~ ~ ~ ~ -\textgreater{}
    UnderLets.wf (fun G' =\textgreater{} expr.wf G') G (@do\_again1 t
    e1) (@do\_again2 t e2)).
  \end{itemize}

  ~ Lemma wf\_assemble\_identifier\_rewriters' G t re1 e1 re2 e2 ~ ~ ~ ~
  K1 K2 ~ ~ ~ ~ (He : @wf\_rawexpr G t re1 e1 re2 e2) ~ ~ ~ ~ (HK1 :
  forall P v, K1 P v = rew {[}P{]} (proj1 (eq\_type\_of\_rawexpr\_of\_wf
  He)) in v) ~ ~ ~ ~ (HK2 : forall P v, K2 P v = rew {[}P{]} (proj2
  (eq\_type\_of\_rawexpr\_of\_wf He)) in v) ~ ~ : wf\_value\_with\_lets
  ~ ~ ~ ~ G ~ ~ ~ ~ (@assemble\_identifier\_rewriters`var1 rew1
  do\_again1 t re1 K1) ~ ~ ~ ~ (@assemble\_identifier\_rewriters' var2
  rew2 do\_again2 t re2 K2).
  \texttt{-\ The\ `wf`-correctness\ condition\ for\ `assemble\_identifier\_rewriters`\ merely\ says\ that\ the\ outputs\ are\ always\ `wf`-related,\ again\ under\ the\ assumption\ that\ the\ "rewrite\ again"\ functions\ are\ appropriately\ `wf`-related\ and\ the\ list\ of\ rewrite\ rules\ is\ good.}coq
  Lemma wf\_assemble\_identifier\_rewriters G t (idc : ident t) ~ :
  wf\_value\_with\_lets ~ ~ ~ G ~ ~ ~ (@assemble\_identifier\_rewriters
  var1 rew1 do\_again1 t idc) ~ ~ ~ (@assemble\_identifier\_rewriters
  var2 rew2 do\_again2 t idc). Proof.
  \texttt{-\ The\ interpretation\ correctness\ condition\ says\ that\ for\ a\ good\ "rewrite\ again"\ function,\ a\ good-for-interpretation\ list\ of\ rewrite\ rules,\ a\ `rawexpr`\ `re`\ whose\ types\ are\ ok\ and\ which\ is\ interp-related\ to\ an\ interpreted\ value\ `v`,\ the\ result\ of\ `assemble\_identifier\_rewriters\textquotesingle{}`\ is\ interp-related\ to\ `v`.\ \ The\ actual\ statement\ is\ slightly\ more\ obscure,\ parameterizing\ over\ types\ which\ are\ equal\ to\ computed\ things,\ primarily\ for\ ease\ of\ induction\ in\ the\ proof.}coq
  Lemma interp\_assemble\_identifier\_rewriters' ~ ~ ~ (do\_again :
  forall t : base.type, @expr.expr base.type ident value t
  -\textgreater{} UnderLets (expr t)) ~ ~ ~ (dt : decision\_tree) ~ ~ ~
  (rew\_rules : rewrite\_rulesT) ~ ~ ~ t re K ~ ~ ~ (res :=
  @assemble\_identifier\_rewriters' dt rew\_rules do\_again t re K) ~ ~
  ~ (Hre : rawexpr\_types\_ok re (type\_of\_rawexpr re)) ~ ~ ~ (Ht :
  type\_of\_rawexpr re = t) ~ ~ ~ v ~ ~ ~ (HK : K = (fun P v
  =\textgreater{} rew {[}P{]} Ht in v)) ~ ~ ~ (Hdo\_again : forall t e
  v, ~ ~ ~ ~ ~ expr.interp\_related\_gen ident\_interp (fun t
  =\textgreater{} value\_interp\_related) e v ~ ~ ~ ~ ~ -\textgreater{}
  UnderLets\_interp\_related (do\_again t e) v) ~ ~ ~ (Hrew\_rules :
  rewrite\_rules\_interp\_goodT rew\_rules) ~ ~ ~ (Hr :
  rawexpr\_interp\_related re v) ~ : value\_interp\_related res (rew Ht
  in v).
  \texttt{-\ The\ interpretation\ correctness\ condition\ for\ `assemble\_identifier\_rewriters`\ is\ very\ similar,\ where\ the\ `rawexpr\_interp\_related`\ hypothesis\ is\ replaced\ by\ an\ pointwise\ equality\ between\ the\ interpretation\ of\ the\ identifier\ and\ the\ interpreted\ value.}coq
  Lemma interp\_assemble\_identifier\_rewriters ~ ~ ~ (do\_again :
  forall t : base.type, @expr.expr base.type ident value t
  -\textgreater{} UnderLets (expr t)) ~ ~ ~ (d : decision\_tree) ~ ~ ~
  (rew\_rules : rewrite\_rulesT) ~ ~ ~ t idc v ~ ~ ~ (res :=
  @assemble\_identifier\_rewriters d rew\_rules do\_again t idc) ~ ~ ~
  (Hdo\_again : forall t e v, ~ ~ ~ ~ ~ expr.interp\_related\_gen
  ident\_interp (fun t =\textgreater{} value\_interp\_related) e v ~ ~ ~
  ~ ~ -\textgreater{} UnderLets\_interp\_related (do\_again t e) v) ~ ~
  ~ (Hrew\_rules : rewrite\_rules\_interp\_goodT rew\_rules) ~ ~ ~ (Hv :
  ident\_interp t idc == v) ~ : value\_interp\_related res v. ```
\item
  We have not talked about correctness conditions for the functions we
  looked at in the very beginning, \texttt{rewrite\_bottomup} and
  \texttt{repeat\_rewrite}, but the correctness conditions for these two
  are straightforward, so we state them without explanation.

  \begin{itemize}
  \tightlist
  \item
    The \texttt{wf} correctness conditions are ```coq Section
    with\_rewrite\_head. ~ Context (rewrite\_head1 : forall t (idc :
    ident t), @value\_with\_lets var1 t) ~ ~ ~ ~ ~ (rewrite\_head2 :
    forall t (idc : ident t), @value\_with\_lets var2 t) ~ ~ ~ ~ ~
    (wf\_rewrite\_head : forall G t (idc1 idc2 : ident t), ~ ~ ~ ~ ~ ~ ~
    idc1 = idc2 -\textgreater{} wf\_value\_with\_lets G (rewrite\_head1
    t idc1) (rewrite\_head2 t idc2)).
  \end{itemize}

  ~ Local Notation rewrite\_bottomup1 := (@rewrite\_bottomup var1
  rewrite\_head1). ~ Local Notation rewrite\_bottomup2 :=
  (@rewrite\_bottomup var2 rewrite\_head2).

  ~ Lemma wf\_rewrite\_bottomup G G' \{t\} e1 e2 (Hwf : expr.wf G e1 e2)
  ~ ~ ~ ~ (HG : forall t v1 v2, List.In (existT \_ t (v1, v2)) G
  -\textgreater{} wf\_value G' v1 v2) ~ ~ : wf\_value\_with\_lets G'
  (@rewrite\_bottomup1 t e1) (@rewrite\_bottomup2 t e2). End
  with\_rewrite\_head.

  Local Notation nbe var := (@rewrite\_bottomup var (fun t idc
  =\textgreater{} reflect (expr.Ident idc))).

  Lemma wf\_nbe G G' \{t\} e1 e2 ~ ~ ~ (Hwf : expr.wf G e1 e2) ~ ~ ~ (HG
  : forall t v1 v2, List.In (existT \_ t (v1, v2)) G -\textgreater{}
  wf\_value G' v1 v2) ~ : wf\_value\_with\_lets G' (@nbe var1 t e1)
  (@nbe var2 t e2).

  Section with\_rewrite\_head2. ~ Context (rewrite\_head1 : forall
  (do\_again : forall t : base.type, @expr (@value var1) (type.base t)
  -\textgreater{} @UnderLets var1 (@expr var1 (type.base t))) ~ ~ ~ ~ ~
  ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ t (idc : ident t), @value\_with\_lets var1 t)
  ~ ~ ~ ~ ~ (rewrite\_head2 : forall (do\_again : forall t : base.type,
  @expr (@value var2) (type.base t) -\textgreater{} @UnderLets var2
  (@expr var2 (type.base t))) ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ t (idc :
  ident t), @value\_with\_lets var2 t) ~ ~ ~ ~ ~ (wf\_rewrite\_head ~ ~
  ~ ~ ~ ~: forall ~ ~ ~ ~ ~ ~ ~ do\_again1 ~ ~ ~ ~ ~ ~ ~ do\_again2 ~ ~
  ~ ~ ~ ~ ~ (wf\_do\_again ~ ~ ~ ~ ~ ~ ~ ~: forall G' G (t : base.type)
  e1 e2 ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ (HG : forall t v1 v2, List.In (existT \_
  t (v1, v2)) G -\textgreater{} wf\_value G' v1 v2), ~ ~ ~ ~ ~ ~ ~ ~ ~
  expr.wf G e1 e2 ~ ~ ~ ~ ~ ~ ~ ~ ~ -\textgreater{} UnderLets.wf (fun G'
  =\textgreater{} expr.wf G') G' (do\_again1 t e1) (do\_again2 t e2)) ~
  ~ ~ ~ ~ ~ ~ G t (idc1 idc2 : ident t), ~ ~ ~ ~ ~ ~ ~ idc1 = idc2
  -\textgreater{} wf\_value\_with\_lets G (rewrite\_head1 do\_again1 t
  idc1) (rewrite\_head2 do\_again2 t idc2)).

  ~ Lemma wf\_repeat\_rewrite fuel ~ ~ : forall \{t\} G G' e1 e2 ~ ~ ~ ~
  ~ ~ ~(Hwf : expr.wf G e1 e2) ~ ~ ~ ~ ~ ~ ~(HG : forall t v1 v2,
  List.In (existT \_ t (v1, v2)) G -\textgreater{} wf\_value G' v1 v2),
  ~ ~ ~ wf\_value\_with\_lets G' (@repeat\_rewrite var1 rewrite\_head1
  fuel t e1) (@repeat\_rewrite var2 rewrite\_head2 fuel t e2).
  \texttt{-\ The\ interpretation\ correctness\ conditions\ are}coq
  Section with\_rewrite\_head. ~ Context (rewrite\_head : forall t (idc
  : ident t), value\_with\_lets t) ~ ~ ~ ~ ~ (interp\_rewrite\_head :
  forall t idc v, ident\_interp idc == v -\textgreater{}
  value\_interp\_related (rewrite\_head t idc) v).

  ~ Lemma interp\_rewrite\_bottomup \{t e v\} ~ ~ ~ ~ (He :
  expr.interp\_related\_gen (@ident\_interp) (fun t =\textgreater{}
  value\_interp\_related) e v) ~ ~ : value\_interp\_related
  (@rewrite\_bottomup var rewrite\_head t e) v. End with\_rewrite\_head.

  Local Notation nbe := (@rewrite\_bottomup var (fun t idc
  =\textgreater{} reflect (expr.Ident idc))).

  Lemma interp\_nbe \{t e v\} ~ ~ ~ (He : expr.interp\_related\_gen
  (@ident\_interp) (fun t =\textgreater{} value\_interp\_related) e v) ~
  : value\_interp\_related (@nbe t e) v.

  Lemma interp\_repeat\_rewrite ~ ~ ~ \{rewrite\_head fuel t e v\} ~ ~ ~
  (retT := value\_interp\_related (@repeat\_rewrite \_ rewrite\_head
  fuel t e) v) ~ ~ ~ (Hrewrite\_head ~ ~ ~ ~: forall do\_again ~ ~ ~ ~ ~
  ~ ~ ~ (Hdo\_again : forall t e v, ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
  expr.interp\_related\_gen (@ident\_interp) (fun t =\textgreater{}
  value\_interp\_related) e v ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ -\textgreater{}
  UnderLets.interp\_related (@ident\_interp) (expr.interp\_related
  (@ident\_interp)) (do\_again t e) v) ~ ~ ~ ~ ~ ~ ~ ~ t idc v, ~ ~ ~ ~
  ~ ident\_interp idc == v ~ ~ ~ ~ ~ -\textgreater{}
  value\_interp\_related (@rewrite\_head do\_again t idc) v) ~ ~ ~ (He :
  expr.interp\_related\_gen (@ident\_interp) (fun t =\textgreater{}
  value\_interp\_related) e v) ~ : retT. ```
\end{itemize}
