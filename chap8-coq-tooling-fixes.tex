\chapter{A Retrospective on Performance Improvements} \label{ch:coq-tooling-fixes}
Throughout this thesis, we've looked at the problem of performance in proof assistants, especially those based on dependent type theory, with Coq as our primary tool under investigation.
\autoref{part:introduction} aimed to convince the reader that this problem is interesting, important, challenging, and understudied, as it differs in non-trivial ways from performance bottlenecks in non-dependently-typed languages.
\autoref{part:design} discussed design principles to avoid performance pitfalls, and \autoref{part:rewriting} took a deep dive into a particular set of performance bottlenecks and presented a tool, and, we hope, exposed the underlying design methodology, that allows eliminating asymptotic bottlenecks in one important part of proof assistant systems.

In this chapter, we will look instead at the successes of the past decade\footnote{%
  Actually, the time span we're considering is the course of the author's experience with Coq, which is a bit less than a decade.%
}%
, ways in which performance has improved in major ways.
\autoref{sec:fixes:minutiae} will discuss specific improvements in the implementation of Coq which resulted in performance gains, paying special attention to the underlying bottleneck being addressed.
Those without special interest in the low-level details of proof assistant implementation may want to skip to \autoref{sec:fixes:coq-theory}, which will discuss changes to the underlying type theory of Coq which make possible drastic performance improvements.
While we will again have our eye on Coq in \autoref{sec:fixes:coq-theory}, we will broaden our perspective in \autoref{sec:fixes:theory} to discuss new discoveries of the past decade or so in dependent type theory which enable performance improvements but have not yet made their way into Coq.

\section{Concrete Performance Advancements in Coq}\label{sec:fixes:minutiae}
$\left.\right.$
\subsection{Removing Pervasive Evar Normalization}\label{sec:econstr}
$\left.\right.$
\subsection{The \Ltac\space Profiler}\label{sec:ltac-prof}
$\left.\right.$
\subsection{Compilation to Native Code}\label{sec:native-compiler}
$\left.\right.$
\subsection{Primitive Integers and Arrays}\label{sec:prim-ints-arrays}
$\left.\right.$

% https://github.com/coq/coq/issues/1169 - fixed 2007, ring doing unnecessary reductions in the goal

\section{Performance-Enhancing Advancements in the Type Theory of Coq}\label{sec:fixes:coq-theory}
$\left.\right.$
\subsection{Universe Polymorphism}\label{sec:fixes:theory:univ-poly}\label{sec:univ-poly}
$\left.\right.$
\subsection{Judgmental Î· for Record Types}\label{sec:fixes:theory:record-eta}\label{sec:record-eta}
$\left.\right.$
\subsection{Primitive Projections for Record Types}\label{sec:fixes:theory:primitive-projections}\label{sec:primitive-projections}
$\left.\right.$

\section{Performance-Enhancing Advancements in Type Theory at Large}\label{sec:fixes:theory}
$\left.\right.$
\subsection{Univalence and Isomorphism Transport}\label{sec:fixes:theory:univalence}\label{sec:univalence}
$\left.\right.$
\subsection{Higher Inductive Types: Setoids for Free}\label{sec:fixes:theory:HITs}\label{sec:HITs}
$\left.\right.$
\subsection{Cubical Type Theory}\label{sec:fixes:theory:cubical}\label{sec:cubical}
$\left.\right.$


In this chapter, we'll take a look at ways that
The purpose of this chapter is to convince the reader that the issue of performance in proof assistants is non-trivial in ways that differ from performance bottlenecks in non-dependently-typed languages.


\todo{Mention how ever single tactic used to be slow}

\begin{subappendices}
    \section{Fragments from the category theory paper}
    For reasons that we present in the course of the paper, we were unsatisfied with the feature set of released Coq version 8.4.  We wound up adopting the Coq version under development by homotopy type theorists~\cite{HoTT/coq}, making critical use of its stronger universe polymorphism (\autoref{sec:category-of-categories}) and higher inductive types (\autoref{sec:hit}).  We hope that our account here provides useful data points for proof assistant designers about which features can have serious impact on proving convenience or performance in very abstract developments.  The two features we mentioned earlier in the paragraph can simplify the Coq user experience dramatically, while a number of other features, at various stages of conception or implementation by Coq team members, can make proving much easier or improve proof script performance by orders of magnitude, generally by reducing term size (\autoref{sec:term-size}): primitive record projections (\autoref{sec:prim-record-proj}), internalized proof irrelevance for equalities (\autoref{sec:equality-reflection}), and $\eta$ rules for records (\autoref{sec:no-judgmental-eta}) and equality proofs (\autoref{sec:compute-match}).

    \hrule


    \section{transcript bits from Adam}
    Ah a sort of like preconclusion chapter that's like let's now look at how cock is evolved performance wise over the years like here places that we've actually improved performance and this will be one that draws a bunch of other examples from the category theory paper, like look universe polymorphism is a thing that was implemented and helps here and like sort of like presenting a bunch of little things.
\section{transcript bits from Rajee}
So those are the two main sections the thesis. And then there's another section of other small. Miscellaneous things that come up better like performance bottlenecks. Through like can or performance concerns, let's say these are things like decide design decisions that can have quadratic impacts. Um, Decisions about like what parts of cop to use for what and like why some bits might be more or less slow than others.

Yeah, that's that's that section and then I think I'm going to have seconds last section. Be a sort of retrospective of like places where cocks performance has gotten better in the past like decade or so of like I started with a bunch of ways that solving performance issues improved systems is heard but here are some successes and things where like we've managed to improve things and you can actually like, Leverage this for faster performance.


\todo{this chapter}
\end{subappendices}
