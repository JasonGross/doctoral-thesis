% Encoding: UTF-8

@InProceedings{ReflectionTACS97,
  author    = {Boutin, Samuel},
  booktitle = {Theoretical Aspects of Computer Software},
  date      = {1997},
  title     = {Using reflection to build efficient and certified decision procedures},
  doi       = {10.1007/bfb0014565},
  editor    = {Abadi, Mart{\'i}n and Ito, Takayasu},
  isbn      = {978-3-540-69530-1},
  location  = {Berlin, Heidelberg},
  pages     = {515--529},
  publisher = {Springer Berlin Heidelberg},
}

@InProceedings{reification-by-parametricity,
  author          = {Jason Gross and Andres Erbsen and Adam Chlipala},
  booktitle       = {Proceedings of the \href{https://itp2018.inria.fr/}{9th International Conference on Interactive Theorem Proving (ITP'18)}},
  date            = {2018-07},
  title           = {Reification by Parametricity: Fast Setup for Proof by Reflection, in Two Lines of {L}tac},
  doi             = {10.1007/978-3-319-94821-8_17},
  url             = {https://people.csail.mit.edu/jgross/personal-website/papers/2018-reification-by-parametricity-itp-camera-ready.pdf},
  abstract        = {We present a new strategy for performing reification in Coq.
That is, we show how to generate first-class abstract syntax trees from ``native'' terms of Coq's logic, suitable as inputs to verified compilers or procedures in the \emph{proof-by-reflection} style.
Our new strategy, based on simple generalization of subterms as variables, is straightforward, short, and fast.
In its pure form, it is only complete for constants and function applications, but ``let'' binders, eliminators, lambdas, and quantifiers can be accommodated through lightweight coding conventions or preprocessing.

We survey the existing methods of reification across multiple Coq metaprogramming facilities, describing various design choices and tricks that can be used to speed them up, as well as various limitations.
We report benchmarking results for 18 variants, in addition to our own, finding that our own reification outperforms 16 of these methods in all cases, and one additional method in some cases; writing an OCaml plugin is the only method tested to be faster.
Our method is the most concise of the strategies we considered, reifying terms using only two to four lines of \texttt{Ltac}---beyond lists of the identifiers to reify and their reified variants.
Additionally, our strategy automatically provides error messages that are no less helpful than Coq's own error messages.},
  artifact-github = {https://github.com/mit-plv/reification-by-parametricity},
  artifact-tar-gz = {https://people.csail.mit.edu/jgross/personal-website/papers/2018-reification-by-parametricity-itp-camera-ready-supplementary.tar.gz},
  original-url    = {https://people.csail.mit.edu/jgross/personal-website/papers/2018-reification-by-parametricity-itp-draft.pdf},
  owner           = {Jason},
}

@Misc{coq-pr-fast-rel-lookup,
  author = {Pierre-Marie P\'edrot},
  date   = {2017-12},
  title  = {Fast rel lookup \#6506},
  url    = {https://github.com/coq/coq/pull/6506},
}

@Book{cpdt,
  author    = {Adam Chlipala},
  date      = {2013-12},
  title     = {Certified Programming with Dependent Types: A Pragmatic Introduction to the {C}oq Proof Assistant},
  doi       = {10.7551/mitpress/9153.001.0001},
  isbn      = {9780262026659},
  publisher = {MIT Press},
  url       = {http://adam.chlipala.net/cpdt/},
}

@TechReport{gonthier2016small,
  author      = {Gonthier, Georges and Mahboubi, Assia and Tassi, Enrico},
  date        = {2016-11},
  institution = {Inria Saclay Ile de France},
  title       = {A Small Scale Reflection Extension for the {C}oq system},
  url         = {https://hal.inria.fr/inria-00258384/},
  school      = {Inria Saclay Ile de France},
}

@InProceedings{HOAS,
  author    = {Frank Pfenning and Conal Elliot},
  booktitle = {Proc. PLDI},
  date      = {1988},
  title     = {Higher-order abstract syntax},
  doi       = {10.1145/53990.54010},
  location  = {Atlanta, Georgia, United States},
  pages     = {199--208},
  url       = {https://www.cs.cmu.edu/~fp/papers/pldi88.pdf},
}

@Article{lessadhoc,
  author       = {Gonthier, Georges and Ziliani, Beta and Nanevski, Aleksandar and Dreyer, Derek},
  date         = {2013},
  journaltitle = {Journal of Functional Programming},
  title        = {How to Make Ad Hoc Proof Automation Less Ad Hoc},
  doi          = {10.1017/S0956796813000051},
  number       = {4},
  pages        = {357--401},
  url          = {https://people.mpi-sws.org/~beta/lessadhoc/lessadhoc-extended.pdf},
  volume       = {23},
  publisher    = {Cambridge University Press},
}

@InProceedings{MirrorShardITP14,
  author    = {Gregory Malecha and Adam Chlipala and Thomas Braibant},
  booktitle = {ITP'14: Proceedings of the 5th International Conference on Interactive Theorem Proving},
  date      = {2014},
  title     = {Compositional Computational Reflection},
  doi       = {10.1007/978-3-319-08970-6_24},
  url       = {http://adam.chlipala.net/papers/MirrorShardITP14/},
}

@InProceedings{PhoasICFP08,
  author    = {Adam Chlipala},
  booktitle = {ICFP'08: Proceedings of the 13th ACM SIGPLAN International Conference on Functional Programming},
  date      = {2008-09},
  title     = {Parametric Higher-Order Abstract Syntax for Mechanized Semantics},
  doi       = {10.1145/1411204.1411226},
  location  = {Victoria, British Columbia, Canada},
  url       = {http://adam.chlipala.net/papers/PhoasICFP08/},
}

@InBook{primitive-projections,
  author    = {{Coq Development Team}},
  date      = {2017},
  title     = {The {C}oq Proof Assistant Reference Manual},
  chapter   = {2.1.1 Extensions of \texorpdfstring{\textsc{Gallina}}{Gallina}, Record Types (Primitive Projections)},
  edition   = {8.7.1},
  publisher = {INRIA},
  url       = {https://coq.inria.fr/distrib/V8.7.1/refman/gallina-ext.html#sec65},
}

@InBook{quote-plugin,
  author    = {{Coq Development Team}},
  date      = {2017},
  title     = {The {C}oq Proof Assistant Reference Manual},
  chapter   = {10.3 Detailed examples of tactics (quote)},
  edition   = {8.7.1},
  publisher = {INRIA},
  url       = {https://coq.inria.fr/distrib/V8.7.1/refman/tactic-examples.html#quote-examples},
}

@Article{sozeau2008first,
  author       = {Sozeau, Matthieu and Oury, Nicolas},
  date         = {2008},
  journaltitle = {Lecture Notes in Computer Science},
  title        = {First-class type classes},
  doi          = {10.1007/978-3-540-71067-7_23},
  pages        = {278--293},
  url          = {https://www.irif.fr/~sozeau/research/publications/First-Class_Type_Classes.pdf},
  volume       = {5170},
  publisher    = {Springer},
}

@Article{ziliani2015mtac,
  author       = {Beta Ziliani and Derek Dreyer and Neelakantan R Krishnaswami and Aleksandar Nanevski and Viktor Vafeiadis},
  date         = {2015},
  journaltitle = {Journal of Functional Programming},
  title        = {Mtac: A Monad for Typed Tactic Programming in {C}oq},
  url          = {http://plv.mpi-sws.org/mtac/journal-draft.pdf},
  volume       = {25},
  publisher    = {Cambridge University Press},
}

@Article{ziliani2017comprehensible,
  author       = {Ziliani, Beta and Sozeau, Matthieu},
  date         = {2017},
  journaltitle = {Journal of Functional Programming},
  title        = {A Comprehensible Guide to a New Unifier for {CIC} Including Universe Polymorphism and Overloading},
  url          = {https://people.mpi-sws.org/~beta/papers/unicoq-journal.pdf},
  volume       = {27},
  publisher    = {Cambridge University Press},
}

@InProceedings{maranget2008compiling,
  author       = {Maranget, Luc},
  booktitle    = {Proceedings of the 2008 ACM SIGPLAN workshop on ML},
  date         = {2008},
  title        = {Compiling Pattern Matching to Good Decision Trees},
  doi          = {10.1145/1411304.1411311},
  organization = {ACM},
  pages        = {35--46},
  url          = {http://moscova.inria.fr/~maranget/papers/ml05e-maranget.pdf},
  owner        = {jgross},
  timestamp    = {2019.04.15},
}

@Misc{coq-pr-floats,
  author    = {Erik Martin-Dorel},
  date      = {2018-08},
  title     = {Implementing primitive floats (binary64 floating-point numbers) - Issue \#8276 - coq/coq},
  url       = {https://github.com/coq/coq/issues/8276},
  owner     = {jgross},
  timestamp = {2019.04.22},
}

@Article{Compcert,
  author       = {Leroy, Xavier},
  date         = {2009-12},
  journaltitle = {J. Autom. Reason.},
  title        = {A Formally Verified Compiler Back-end},
  doi          = {10.1007/s10817-009-9155-4},
  issn         = {0168-7433},
  number       = {4},
  pages        = {363--446},
  url          = {http://gallium.inria.fr/~xleroy/publi/compcert-backend.pdf},
  volume       = {43},
  acmid        = {1666216},
  issue_date   = {December 2009},
  keywords     = {Compiler transformations and optimizations, Compiler verification, Formal methods, Program proof, Semantic preservation, The Coq theorem prover},
  location     = {Secaucus, NJ, USA},
  numpages     = {84},
  publisher    = {Springer-Verlag New York, Inc.},
}

@InProceedings{seL4SOSP09,
  author    = {Gerwin Klein and Kevin Elphinstone and Gernot Heiser and June Andronick and David Cock and Philip Derrin and Dhammika Elkaduwe and Kai Engelhardt and Rafal Kolanski and Michael Norrish and Thomas Sewell and Harvey Tuch and Simon Winwood},
  booktitle = {Proc. SOSP},
  date      = {2009},
  title     = {{seL4}: Formal Verification of an {OS} Kernel},
  doi       = {10.1145/1629575.1629596},
  pages     = {207--220},
  publisher = {ACM},
}

@Book{PartialEvaluation,
  author    = {N.D. Jones and C.K. Gomard and P. Sestoft},
  date      = {1993-06},
  title     = {Partial Evaluation and Automatic Program Generation},
  isbn      = {0-13-020249-5},
  publisher = {Prentice Hall International},
}

@Article{LMS,
  author       = {Tiark Rompf and Martin Odersky},
  date         = {2010},
  journaltitle = {Proceedings of GPCE},
  title        = {Lightweight modular staging: {A} pragmatic approach to runtime code generation and compiled {DSL}s},
  doi          = {10.1145/2184319.2184345},
  url          = {https://infoscience.epfl.ch/record/150347/files/gpce63-rompf.pdf},
}

@InProceedings{NbE,
  author    = {U. Berger and H. Schwichtenberg},
  booktitle = {[1991] Proceedings Sixth Annual IEEE Symposium on Logic in Computer Science},
  date      = {1991-07},
  title     = {An inverse of the evaluation functional for typed $\lambda$--calculus},
  doi       = {10.1109/LICS.1991.151645},
  pages     = {203--211},
  url       = {http://www.mathematik.uni-muenchen.de/~schwicht/papers/lics91/paper.pdf},
  keywords  = {formal logic;inverse;evaluation functional;typed lambda -calculus;typed lambda -terms;normalization algorithm;lambda -calculi;constants;natural deduction proofs;completeness theorem;recursive functions;Calculus;Arithmetic;Computer languages},
}

@InProceedings{Aehlig,
  author    = {Klaus Aehlig and Florian Haftmann and Tobias Nipkow},
  booktitle = {Proc. TPHOLs},
  date      = {2008},
  title     = {A Compiled Implementation of Normalization by Evaluation},
  doi       = {10.1007/978-3-540-71067-7_8},
}

@InProceedings{CodeGen,
  author    = {Florian Haftmann and Tobias Nipkow},
  booktitle = {Proc. TPHOLs},
  date      = {2007},
  title     = {A Code Generator Framework for {I}sabelle/{HOL}},
}

@InProceedings{vale,
  author    = {Barry Bond and Chris Hawblitzel and Manos Kapritsos and Rustan Leino and Jay Lorch and Bryan Parno and Ashay Rane and Srinath Setty and Laure Thompson},
  booktitle = {Proc. USENIX Security},
  date      = {2017},
  title     = {Vale: Verifying High-Performance Cryptographic Assembly Code},
  url       = {http://www.cs.cornell.edu/~laurejt/papers/vale-2017.pdf},
}

@InProceedings{nativecompute,
  author    = {Mathieu Boespflug and Maxime Dénès and Benjamin Grégoire},
  booktitle = {Proc. CPP},
  date      = {2011},
  title     = {Full Reduction at Full Throttle},
  doi       = {10.1007/978-3-642-25379-9_26},
}

@InProceedings{LMSVerify,
  author    = {Nada Amin and Tiark Rompf},
  booktitle = {Proc. POPL},
  date      = {2017},
  title     = {{LMS-Verify}: Abstraction without Regret for Verified Systems Programming},
  doi       = {10.1145/3093333.3009867},
}

@InProceedings{TemplateCoq,
  author    = {Abhishek Anand and Simon Boulier and Cyril Cohen and Matthieu Sozeau and Nicolas Tabareau},
  booktitle = {Proc. ITP},
  date      = {2018},
  title     = {Towards Certified Meta-Programming with Typed {Template-Coq}},
  doi       = {10.1007/978-3-319-94821-8_2},
}

@InBook{rtac,
  author    = {Malecha, Gregory and Bengtson, Jesper},
  date      = {2016},
  title     = {Programming Languages and Systems: 25th European Symposium on Programming, ESOP 2016, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2016, Eindhoven, The Netherlands, April 2-8, 2016, Proceedings},
  chapter   = {Extensible and Efficient Automation Through Reflective Tactics},
  doi       = {10.1007/978-3-662-49498-1_21},
  editor    = {Thiemann, Peter},
  isbn      = {978-3-662-49498-1},
  location  = {Berlin, Heidelberg},
  pages     = {532--559},
  publisher = {Springer Berlin Heidelberg},
}

@Conference{denes2013prim-ints-arrays,
  author    = {Maxime D\'en\`es},
  booktitle = {The {C}oq Workshop 2013},
  date      = {2013-04-06},
  title     = {Towards primitive data types for {C}OQ},
  subtitle  = {63-bits integers and persistent arrays},
  url       = {https://coq.inria.fr/files/coq5_submission_2.pdf},
  year      = {2013},
}

@PhdThesis{malecha2015thesis,
  author      = {Gregory Michael Malecha},
  date        = {2014-11},
  institution = {Harvard University},
  title       = {Extensible Proof Engineering in Intensional Type Theory},
  url         = {http://gmalecha.github.io/publication/2015/02/01/extensible-proof-engineering-in-intensional-type-theory.html},
}

@InProceedings{debruijn1972,
  author       = {de Bruijn, Nicolaas Govert},
  booktitle    = {Indagationes Mathematicae (Proceedings)},
  date         = {1972},
  title        = {Lambda calculus notation with nameless dummies, a tool for automatic formula manipulation, with application to the {C}hurch-{R}osser theorem},
  doi          = {10.1016/1385-7258(72)90034-0},
  number       = {5},
  organization = {Elsevier},
  pages        = {381--392},
  url          = {http://www.sciencedirect.com/science/article/pii/1385725872900340},
  volume       = {75},
}

@Article{aczel1993galois,
  author      = {Aczel, Peter},
  date        = {1993},
  title       = {Galois: a theory development project},
  url         = {http://www.cs.man.ac.uk/~petera/galois.ps.gz},
  booktitle   = {A report on work in progress for the Turin meeting on the Representation of Logical Frameworks},
  journal-old = {A report on work in progress for the Turin meeting on the Representation of Logical Frameworks},
  local-url   = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/galois.pdf},
  owner       = {Jason},
  pdf         = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/galois.pdf},
  timestamp   = {2013.12.12},
}

@Article{agerholm1995experiments,
  author       = {Agerholm, Sten},
  date         = {1995-12},
  journaltitle = {Draft manuscript},
  title        = {Experiments in formalizing basic category theory in higher order logic and set theory},
  doi          = {10.1.1.22.8437},
  url          = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.8437&rep=rep1&type=pdf},
  local-url    = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/download-doi=10.1.1.22.8437.pdf},
  owner        = {Jason},
  publisher    = {Citeseer},
  timestamp    = {2014.03.28},
}

@Electronic{benediktahrens/coinductives,
  author    = {Benedikt Ahrens},
  title     = {Coinductives},
  url       = {https://github.com/benediktahrens/coinductives},
  owner     = {Jason},
  timestamp = {2013.12.31},
}

@Electronic{benediktahrens-Foundations-typesystems,
  author    = {Benedikt Ahrens},
  title     = {{benediktahrens/Foundations typesystems}},
  url       = {https://github.com/benediktahrens/Foundations/tree/typesystems},
  owner     = {Jason},
  timestamp = {2013.12.12},
}

@Misc{ahrens2010categorical,
  author    = {Ahrens, Benedikt},
  date      = {2010},
  title     = {Categorical semantics of programming languages (in {C}OQ)},
  url       = {http://math.unice.fr/~ahrens/edsfa/ahrens_edsfa.pdf},
  local-url = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/ahrens_edsfa.pdf},
  owner     = {Jason},
  publisher = {Citeseer},
  timestamp = {2013.12.24},
}

@Electronic{benediktahrens/rezk-completion,
  author    = {Benedikt Ahrens and Chris Kapulkin and Michael Shulman},
  title     = {{benediktahrens/rezk\_completion}},
  url       = {https://github.com/benediktahrens/rezk_completion},
  owner     = {Jason},
  timestamp = {2013.12.12},
}

@Article{Ahrens2013,
  author         = {Benedikt Ahrens and Chris Kapulkin and Michael Shulman},
  date           = {2013-03},
  journaltitle   = {Ar{X}iv e-prints},
  title          = {Univalent categories and the {R}ezk completion},
  doi            = {10.1017/s0960129514000486},
  eprint         = {1303.0584},
  eprintclass    = {math.CT},
  eprinttype     = {arxiv},
  abstract       = {We develop category theory within Univalent Foundations, which is
	a foundational system for mathematics based on a homotopical interpretation
	of dependent type theory. In this system, we propose a definition
	of "category" for which equality and equivalence of categories agree.
	Such categories satisfy a version of the Univalence Axiom, saying
	that the type of isomorphisms between any two objects is equivalent
	to the identity type between these objects; we call them "saturated"
	or "univalent" categories. Moreover, we show that any category is
	weakly equivalent to a univalent one in a universal way. In homotopical
	and higher-categorical semantics, this construction corresponds to
	a truncated version of the Rezk completion for Segal spaces, and
	also to the stack completion of a prestack.},
  adsnote        = {Provided by the SAO/NASA Astrophysics Data System},
  adsurl         = {http://adsabs.harvard.edu/abs/2013arXiv1303.0584A},
  archiveprefix  = {ar{X}iv},
  comments       = {27 pages, ancillary files contain formalized proofs in the proof assistant Coq},
  keywords       = {Mathematics - Category Theory, Mathematics - Logic, 18A15},
  oai2identifier = {1303.0584},
  owner          = {Jason},
  timestamp      = {2013.12.12},
}

@Article{altenkirch2006towards,
  author       = {Altenkirch, Thorsten and McBride, Conor},
  date         = {2006},
  journaltitle = {Manuscript, available online},
  title        = {Towards observational type theory},
  url          = {http://www.strictlypositive.org/ott.pdf},
  local-url    = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/ott.pdf},
  owner        = {Jason},
  timestamp    = {2014.04.10},
}

@InProceedings{altenkirch2007observational,
  author       = {Altenkirch, Thorsten and McBride, Conor and Swierstra, Wouter},
  booktitle    = {Proceedings of the 2007 workshop on Programming languages meets program verification},
  date         = {2007},
  title        = {Observational equality, now!},
  doi          = {10.1145/1292597.1292608},
  organization = {ACM},
  pages        = {57--68},
  url          = {http://www.strictlypositive.org/obseqnow.pdf},
  local-url    = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/obseqnow.pdf},
  owner        = {Jason},
  timestamp    = {2014.04.10},
}

@InProceedings{altucher1990mechanically,
  author       = {Altucher, James A and Panangaden, Prakash},
  booktitle    = {10th International Conference on Automated Deduction},
  date         = {1990},
  title        = {A mechanically assisted constructive proof in category theory},
  doi          = {10.1007/3-540-52885-7_110},
  organization = {Springer},
  pages        = {500--513},
  owner        = {Jason},
  timestamp    = {2013.12.12},
}

@Book{awodey2010category,
  author    = {Awodey, Steve},
  title     = {Category theory},
  doi       = {10.1093/acprof:oso/9780198568612.001.0001},
  edition   = {Second Edition},
  publisher = {Oxford University Press},
  owner     = {Jason},
  timestamp = {2013.12.22},
  year-old  = {2010},
}

@InProceedings{barras2008implicit,
  author    = {Barras, Bruno and Bernardo, Bruno},
  booktitle = {FoSSaCS},
  date      = {2008},
  title     = {The implicit calculus of constructions as a programming language with dependent types},
  doi       = {10.1007/978-3-540-78499-9_26},
  url       = {http://hal.archives-ouvertes.fr/docs/00/43/26/58/PDF/icc_barras_bernardo-tpr07.pdf},
  local-url = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/icc_barras_bernardo-tpr07.pdf},
  owner     = {Jason},
  pages-old = {365--379},
  timestamp = {2014.01.08},
}

@Electronic{Bertot2013,
  author    = {Yves Bertot},
  date      = {2013-04},
  title     = {Private Inductive Types: Proposing a language extension},
  url       = {http://coq.inria.fr/files/coq5_submission_3.pdf},
  abstract  = {For the Coq system, we propose to add the possibility to declare an
	inductive type as private to the module where it is defined. The
	effect is to preserve the possibility to compute with a restricted
	set of functions, but to disallow uses of the more powerful pattern-matching
	constructs. Such a private type has fruitful applications in homotopy
	type theory.},
  local-url = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/coq5_submission_3.pdf},
  owner     = {Jason},
  timestamp = {2014.03.28},
}

@Book{bishop1967foundations,
  author    = {Errett Bishop},
  date      = {1967},
  title     = {Foundations of Constructive Analysis},
  doi       = {10.2307/2314383},
  publisher = {McGraw-Hill},
  series    = {McGraw-Hill series in higher mathematics},
  url       = {http://books.google.com/books?id=o2mmAAAAIAAJ},
  lccn      = {lc67022952},
  owner     = {Jason},
  timestamp = {2014.01.15},
}

@InCollection{caccamo2001higher,
  author    = {C{\'a}ccamo, Mario Jose and Winskel, Glynn},
  booktitle = {Theorem Proving in Higher Order Logics},
  date      = {2001-06},
  title     = {A Higher-Order Calculus for Categories},
  doi       = {10.1007/3-540-44755-5_11},
  editor    = {Boulton, Richard J. and Jackson, Paul B.},
  isbn      = {978-3-540-42525-0},
  language  = {English},
  pages     = {136-153},
  publisher = {Springer Berlin Heidelberg},
  series    = {Lecture Notes in Computer Science},
  url       = {ftp://ftp.daimi.au.dk/BRICS/Reports/RS/01/27/BRICS-RS-01-27.pdf},
  volume    = {2152},
  abstract  = {A calculus for a fragment of category theory is presented. The types
	in the language denote categories and the expressions functors. The
	judgements of the calculus systematise categorical arguments such
	as: an expression is functorial in its free variables; two expressions
	are naturally isomorphic in their free variables. There are special
	binders for limits and more general ends. The rules for limits and
	ends support an algebraic manipulation of universal constructions
	as opposed to a more traditional diagrammatic approach. Duality within
	the calculus and applications in proving continuity are discussed
	with examples. The calculus gives a basis for mechanising a theory
	of categories in a generic theorem prover like Isabelle.},
  local-url = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/BRICS-RS-01-27.pdf},
  owner     = {Jason},
  timestamp = {2014.01.12},
}

@Electronic{pcapriotti/agda-categories,
  author    = {Paolo Capriotti},
  title     = {{pcapriotti/agda-categories}},
  url       = {https://github.com/pcapriotti/agda-categories/},
  owner     = {Jason},
  timestamp = {2013.12.12},
}

@TechReport{Carvalho1998,
  author               = {Carvalho, Alexandra and Mateus, Paulo},
  date                 = {1998},
  title                = {Category Theory in {C}oq},
  doi                  = {10.1.1.29.9846},
  location             = {1049-001 Lisboa, Portugal},
  url                  = {http://sqig.math.ist.utl.pt/pub/CarvalhoA/98-C-DiplomaThesis/maintext.ps},
  abstract             = {{Herein we formalize a segment of category theory using the implementation
	of Calculus of Inductive Construction in Coq. Adopting the axiomatization
	proposed by Huet and Saibi we start by presenting basic concepts,
	examples and results of category theory in Coq. Next we define adjunction
	and cocartesian lifting and establish some results using the Coq
	proof assistant. Finally we remark that the axiomatization proposed
	by Huet and Saibi is not good when dealing with the equality for
	objects. 1...}},
  citeulike-article-id = {1286396},
  citeulike-linkout-0  = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.29.9846},
  institution-old      = {Instituto Superior Técnico},
  keywords             = {category-theory, formalization},
  local-url            = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/maintext.pdf},
  owner                = {Jason Gross},
  pdf                  = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/maintext.pdf},
  posted-at            = {2007-05-09 22:07:25},
  timestamp            = {2013.06.19},
}

@Electronic{jmchapman/restriction-categories,
  author    = {James Chapman},
  title     = {jmchapman/restriction-categories},
  url       = {https://github.com/jmchapman/restriction-categories},
  owner     = {Jason},
  timestamp = {2013.12.12},
}

@TechReport{dyckhoff1985category,
  author          = {Dyckhoff, Roy},
  date            = {1985},
  title           = {Category Theory as an Extension of Martin-L\"{o}f Type Theory},
  url             = {http://rd.host.cs.st-andrews.ac.uk/publications/CTMLTT.pdf},
  institution-old = {University of St. Andrews},
  local-url       = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/CTMLTT.pdf},
  owner           = {Jason Gross},
  timestamp       = {2013.06.19},
}

@InCollection{Garillot2009,
  author     = {Garillot, Fran\c{c}ois and Gonthier, Georges and Mahboubi, Assia and Rideau, Laurence},
  booktitle  = {Theorem Proving in Higher Order Logics},
  date       = {2009},
  title      = {Packaging Mathematical Structures},
  doi        = {10.1007/978-3-642-03359-9_23},
  publisher  = {Springer Berlin Heidelberg},
  url        = {http://hal.inria.fr/docs/00/36/84/03/PDF/main.pdf},
  abstract   = {This paper proposes generic design patterns to define and combine
	algebraic structures, using dependent records, coercions and type
	inference, inside the Coq system. This alternative to telescopes
	in particular supports multiple inheritance, maximal sharing of notations
	and theories, and automated structure inference. Our methodology
	is robust enough to handle a hierarchy comprising a broad variety
	of algebraic structures, from types with a choice operator to algebraically
	closed fields. Interfaces for the structures enjoy the convenience
	of a classical setting, without requiring any axiom. Finally, we
	present two applications of our proof techniques: a key lemma for
	characterising the discrete logarithm, and a matrix decomposition
	problem.},
  editor-old = {Berghofer, Stefan and Nipkow, Tobias and Urban, Christian and Wenzel, Makarius},
  isbn-old   = {978-3-642-03358-2},
  keywords   = {Formalization of Algebra; Coercive subtyping; Type inference; Coq; SSReflect},
  local-url  = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/main.pdf},
  owner      = {Jason},
  pages-old  = {327-342},
  series-old = {Lecture Notes in Computer Science},
  timestamp  = {2014.04.10},
  volume-old = {5674},
}

@InProceedings{gonthier2011make,
  author           = {Gonthier, Georges and Ziliani, Beta and Nanevski, Aleksandar and Dreyer, Derek},
  booktitle        = {ACM SIGPLAN Notices},
  date             = {2011},
  title            = {How to Make Ad Hoc Proof Automation Less Ad Hoc},
  doi              = {10.1145/2034574.2034798},
  organization     = {ACM},
  pages            = {163--175},
  url              = {http://www.mpi-sws.org/~beta/lessadhoc/lessadhoc.pdf},
  volume           = {46},
  local-url        = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/lessadhoc.pdf},
  number-duplicate = {9},
  owner            = {Jason},
  timestamp        = {2014.01.08},
}

@Article{Harper1991107,
  author       = {Robert Harper and Robert Pollack},
  date         = {1991},
  journaltitle = {Theoretical Computer Science},
  title        = {Type checking with universes},
  doi          = {10.1016/0304-3975(90)90108-T},
  issn         = {0304-3975},
  number       = {1},
  pages        = {107 - 136},
  url          = {http://www.sciencedirect.com/science/article/pii/030439759090108T},
  volume       = {89},
  abstract     = {Various formulations of constructive type theories have been proposed
	to serve as the basis for machine-assisted proof and as a theoretical
	basis for studying programming languages. Many of these calculi include
	a cumulative hierarchy of ``universes'', each a type of types closed
	under a collection of type-forming operations. Universes are of interest
	for a variety of reasons, some philosophical (predicative vs. impredicative
	type theories), some theoretical (limitations on the closure properties
	of type theories) and some practical (to achieve some of the advantages
	of a type of all types without sacrificing consistency.) The Generalized
	Calculus of Constructions (CC$^\omega$) is a formal theory of types
	that includes such a hierarchy of universes. Although essential to
	the formalization of constructive mathematics, universes are tedious
	to use in practice, for one is required to make specific choices
	of universe levels and to ensure that all choices are consistent.
	In this paper we study several problems associated with type checking
	in the presence of universes in the context of CC$^\omega$. First,
	we consider the basic type checking and well-typedness problems for
	this calculus. Second, we consider a formulation of Russell and Whitehead's
	``typical ambiguity'' convention whereby universe levels may be elided,
	provided that some consistent assignment of levels leads to a correct
	derivation. Third, we consider the introduction of definitions to
	both the basic calculus and the calculus with typical ambiguity.
	This extension leads to a notion of ``universe polymorphism'' analogous
	to the type polymorphism of ML. Although our study is conducted for
	CC$^\omega$, we expect that our methods will apply to other variants
	of the Calculus of Constructions and to type theories such as Constable's
	V3.},
  local-url    = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/1-s2.0-030439759090108T-main.pdf},
  owner        = {Jason},
  timestamp    = {2013.12.24},
}

@Book{harrison1996formalized,
  author      = {Harrison, John},
  date        = {1996},
  title       = {Formalized mathematics},
  doi         = {10.1.1.47.8842},
  isbn        = {9789516508132},
  publisher   = {Turku Centre for Computer Science},
  series      = {TUCS technical report},
  url         = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.47.8842&rep=rep1&type=pdf},
  institution = {Turku Centre for Computer Science},
  local-url   = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/download-doi=10.1.1.47.8842.pdf},
  owner       = {Jason},
  timestamp   = {2013.12.24},
}

@Article{hofmann1998groupoid,
  author       = {Hofmann, Martin and Streicher, Thomas},
  date         = {1998-08},
  journaltitle = {Twenty-five years of constructive type theory (Venice, 1995)},
  title        = {The groupoid interpretation of type theory},
  pages        = {83--111},
  url          = {http://www.tcs.ifi.lmu.de/mitarbeiter/martin-hofmann/pdfs/agroupoidinterpretationoftypetheroy.pdf},
  volume       = {36},
  local-url    = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/agroupoidinterpretationoftypetheroy.pdf},
  owner        = {Jason},
  timestamp    = {2014.04.15},
}

@InProceedings{huet2000constructive,
  author       = {Huet, G{\'e}rard and Sa{\"i}bi, Amokrane},
  booktitle    = {Proof, language, and interaction},
  date         = {2000},
  title        = {Constructive category theory},
  doi          = {10.1.1.39.4193},
  organization = {MIT Press},
  pages        = {239--275},
  url          = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.4193},
  local-url    = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/download-doi=10.1.1.39.4193.pdf},
  owner        = {Jason},
  timestamp    = {2013.12.24},
}

@Electronic{konn/category-agda,
  author    = {Hiromi Ishii},
  title     = {{konn/category-agda}},
  url       = {https://github.com/konn/category-agda},
  owner     = {Jason},
  timestamp = {2013.12.12},
}

@Article{Category2-AFP,
  author       = {Alexander Katovsky},
  date         = {2010-06},
  journaltitle = {Archive of Formal Proofs},
  title        = {Category Theory},
  issn         = {2150-914x},
  note         = {\url{http://afp.sf.net/entries/Category2.shtml}, Formal proof development},
  abstract     = {This article presents a development of Category Theory in Isabelle/HOL.
	A Category is defined using records and locales. Functors and Natural
	Transformations are also defined. The main result that has been formalized
	is that the Yoneda functor is a full and faithful embedding. We also
	formalize the completeness of many sorted monadic equational logic.
	Extensive use is made of the HOLZF theory in both cases.},
  local-url    = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/Cat.pdf},
  owner        = {Jason},
  pdf          = {http://apk32.user.srcf.net/Isabelle/Category/Cat.pdf},
  timestamp    = {2014.01.19},
}

@Electronic{Komendantsky,
  author       = {Vladimir Komendantsky and Alexander Konovalov and Steve Linton},
  title        = {Connecting {C}oq theorem prover to {GAP}},
  url          = {http://www.symcomp.org/sciencehome-view/images/e/e9/CICM_2010_Komendantsky.pdf},
  organization = {SCIEnce/CICM'10; University of St Andrews, UK},
  local-url    = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/CICM_2010_Komendantsky.pdf},
  owner        = {Jason},
  timestamp    = {2014.04.10},
}

@InCollection{kozen2006automating,
  author    = {Kozen, Dexter and Kreitz, Christoph and Richter, Eva},
  booktitle = {Automated Reasoning},
  date      = {2006},
  title     = {Automating Proofs in Category Theory},
  doi       = {10.1007/11814771_34},
  pages     = {392--407},
  publisher = {Springer},
  url       = {http://www.cs.uni-potsdam.de/ti/kreitz/PDF/06ijcar-categories.pdf},
  file      = {Automating Proofs in Category Theory:http\://www.cs.uni-potsdam.de/ti/kreitz/PDF/06ijcar-categories.pdf:URL},
  local-url = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/06ijcar-categories.pdf},
  owner     = {Jason Gross},
  timestamp = {2013.06.19},
}

@Electronic{MathClasses,
  author       = {Robbert Krebbers and Bas Spitters and Eelis van der Weegen},
  title        = {Math Classes},
  howpublished = {\url{http://coq.inria.fr/pylons/pylons/contribs/view/MathClasses/v8.4}},
  owner        = {Jason},
  timestamp    = {2013.12.12},
}

@Book{Leinster2007,
  author         = {Tom Leinster},
  title          = {Higher Operads, Higher Categories},
  doi            = {10.1017/cbo9780511525896},
  eprint         = {math/0305049},
  eprinttype     = {arxiv},
  publisher      = {Cambridge Univ.~Press},
  abstract       = {Higher-dimensional category theory is the study of n-categories, operads,
	braided monoidal categories, and other such exotic structures. It
	draws its inspiration from areas as diverse as topology, quantum
	algebra, mathematical physics, logic, and theoretical computer science.
	This is the first book on the subject and lays its foundations. Many
	examples are given throughout. There is also an introductory chapter
	motivating the subject for topologists.},
  adsnote        = {Provided by the SAO/NASA Astrophysics Data System},
  adsurl         = {http://adsabs.harvard.edu/abs/2004hohc.book.....L},
  comments       = {Book, 410 pages},
  isbn-bak       = {0521532159},
  month-bak      = {8},
  oai2identifier = {math/0305049},
  owner          = {Jason},
  publisher-bak  = {Cambridge University Press},
  timestamp      = {2014.01.19},
  year-bak       = {2007},
  year-old       = {2007},
}

@Book{mac1998categories,
  author        = {Mac Lane, Saunders},
  title         = {Categories for the working mathematician},
  doi           = {10.1007/978-1-4612-9839-7},
  url           = {http://books.google.com/books?id=MXboNPdTv7QC},
  owner         = {Jason},
  publisher-old = {Springer verlag},
  timestamp     = {2013.12.23},
  volume-old    = {5},
  year-old      = {1998},
}

@Book{martin1984intuitionistic,
  author    = {Martin-L\"of, Per and Sambin, Giovanni},
  date      = {1984},
  title     = {Intuitionistic type theory},
  publisher = {Bibliopolis},
  url       = {http://www.cs.cmu.edu/afs/cs/Web/People/crary/819-f09/Martin-Lof80.pdf},
  volume    = {17},
  local-url = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/Martin-Lof80.pdf},
  owner     = {Jason},
  timestamp = {2014.01.17},
}

@Electronic{megacz-coq-categories,
  author    = {Adam Megacz},
  title     = {Category Theory Library for {C}oq},
  url       = {http://www.cs.berkeley.edu/~megacz/coq-categories/},
  language  = {Coq},
  owner     = {Jason},
  timestamp = {2013.12.12},
}

@InProceedings{logical2001implicit,
  author       = {Alexandre Miquel},
  booktitle    = {Typed Lambda Calculi and Applications},
  date         = {2001},
  title        = {The Implicit Calculus of Constructions},
  organization = {Springer},
  pages        = {344},
  url          = {http://www.pps.univ-paris-diderot.fr/~miquel/publis/tlca01.pdf},
  volume       = {2044},
  local-url    = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/tlca01.pdf},
  owner        = {Jason},
  timestamp    = {2014.01.08},
}

@MastersThesis{mohri1995formalization,
  author       = {Mohri, Takahisa},
  date         = {1995},
  institution  = {University of Tokyo},
  title        = {On formalization of category theory},
  doi          = {10.1007/bfb0028395},
  url          = {http://aleteya.cs.buap.mx/~jlavalle/papers/categorias/ST.ps},
  journaltitle = {A senior thesis},
  local-url    = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/ST.pdf},
  owner        = {Jason},
  pdf          = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/ST.pdf},
  timestamp    = {2013.12.24},
}

@Electronic{Coalgebras,
  author    = {Milad Niqui},
  date      = {2010-01},
  title     = {Coalgebras, bisimulation and lambda-coiteration},
  url       = {http://coq.inria.fr/pylons/pylons/contribs/view/Coalgebras/v8.4},
  owner     = {Jason},
  timestamp = {2013.12.12},
}

@Electronic{Norell,
  author    = {Ulf Norell},
  date      = {2011-08},
  title     = {{A}gda performance improvements},
  url       = {https://lists.chalmers.se/pipermail/agda/2011/003266.html},
  owner     = {Jason},
  timestamp = {2014.05.10},
}

@Misc{nuo2013second,
  author    = {Nuo, Li},
  date      = {2013-07},
  title     = {Second-Year Annual Report},
  url       = {http://www.cs.nott.ac.uk/~nzl/Home_Page/Homepage_files/AR2-8Jul2013.pdf},
  local-url = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/AR2-8Jul2013.pdf},
  owner     = {Jason},
  timestamp = {2014.01.01},
}

@Article{o2004towards,
  author       = {Greg O'Keefe},
  date         = {2004},
  journaltitle = {Electronic Notes in Theoretical Computer Science},
  title        = {Towards a readable formalisation of category theory},
  doi          = {10.1016/j.entcs.2003.12.014},
  pages        = {212--228},
  url          = {http://users.cecs.anu.edu.au/~okeefe/work/fcat4cats04.pdf},
  volume       = {91},
  comment      = {Has survey of existing formalizations},
  local-url    = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/fcat4cats04.pdf},
  owner        = {Jason},
  publisher    = {Elsevier},
  timestamp    = {2013.12.12},
}

@Electronic{copumpkin/categories,
  author    = {Daniel Peebles and James Deikun and Andrea Vezzosi and James Cook},
  title     = {{copumpkin/categories}},
  url       = {https://github.com/copumpkin/categories},
  owner     = {Jason},
  timestamp = {2013.12.12},
}

@TechReport{pierce1988taste,
  author          = {Pierce, B.},
  title           = {A taste of category theory for computer scientists},
  url             = {http://repository.cmu.edu/cgi/viewcontent.cgi?article=2846&context=compsci},
  institution-old = {Carnegie Mellon University},
  journal-old     = {Computer Science Department},
  local-url       = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/repository.cmu.edu__cgi__viewcontent.cgi_article=2846_context=compsci.pdf},
  owner           = {Jason},
  timestamp       = {2014.01.17},
  year-old        = {1988},
}

@Electronic{Algebra,
  author    = {Lo\"ic Pottier},
  title     = {Algebra},
  url       = {http://coq.inria.fr/pylons/pylons/contribs/view/Algebra/v8.4},
  owner     = {Jason},
  timestamp = {2014.01.01},
}

@Electronic{crypto-agda/crypto-agda,
  author    = {Nicolas Pouillard},
  title     = {{crypto-agda/crypto-agda}},
  url       = {https://github.com/crypto-agda/crypto-agda/tree/master/FunUniverse},
  owner     = {Jason},
  timestamp = {2013.12.12},
}

@Electronic{ConCaT,
  author    = {Amokrane Sa{\"i}bi},
  title     = {Constructive Category Theory},
  url       = {http://coq.inria.fr/pylons/pylons/contribs/view/ConCaT/v8.4},
  owner     = {Jason},
  timestamp = {2013.12.12},
}

@Electronic{interval-implies-funext,
  author    = {Michael Shulman},
  title     = {An Interval Type Implies Function Extensionality},
  url       = {http://homotopytypetheory.org/2011/04/04},
  month-old = {4},
  owner     = {Jason},
  timestamp = {2014.01.01},
  year-old  = {2011},
}

@Electronic{CatsInZFC,
  author    = {Carlos Simpson},
  title     = {{C}ats{I}n{ZFC}},
  url       = {http://coq.inria.fr/pylons/pylons/contribs/view/CatsInZFC/v8.4},
  owner     = {Jason},
  timestamp = {2013.12.12},
}

@Electronic{mattam82/coq-polyproj,
  author    = {Matthieu Sozeau},
  title     = {{mattam82/coq polyproj}},
  url       = {https://github.com/mattam82/coq/tree/polyproj},
  owner     = {Jason},
  timestamp = {2014.01.03},
}

@Electronic{mattam82-cat,
  author    = {Matthieu Sozeau},
  title     = {Cat},
  url       = {http://mattam.org/repos/coq/cat/},
  owner     = {Jason},
  timestamp = {2013.12.12},
}

@Electronic{HoTT/coq,
  author    = {Matthieu Sozeau and Hugo Herbelin and Pierre Letouzey and Jean-Christophe Filli\^{a}tre and Matthieu Sozeau and anonymous and Pierre-Marie P\'edrot and Bruno Barras and Jean-Marc Notin and Pierre Boutillier and Enrico Tassi and St\'ephane Glondu and Arnaud Spiwack and Claudio Sacerdoti Coen and Christine Paulin and Olivier Desmettre and Yves Bertot and Julien Forest and David Delahaye and Pierre Corbineau and Julien Narboux and Matthias Puech and Benjamin Monate and Elie Soubiran and Pierre Courtieu and Vincent Gross and Judica\"el Courant and Lionel Elie Mamane and Cl\'ement Renard and Evgeny Makarov and Claude March\'e and Guillaume Melquiond and Micaela Mayero and Yann R\'egis-Gianas and Benjamin Gr\'egoire and Vincent Siles and Fr\'ed\'eric Besson and Laurent Th\'ery and Florent Kirchner and Maxime D\'en\`es and Xavier Clerc and Lo\"ic Pottier and Russel O'Connor and Assia Mahboubi and Benjamin Werner and xclerc and Huang Guan-Shieng and Jason Gross and Tom Hutchinson and Cezary Kaliszyk and Pierre and Daniel De Rauglaudre and Alexandre Miquel and Damien Doligez and Gregory Malecha and Stephane Glondu and Andrej Bauer},
  title     = {{HoTT/coq}},
  url       = {https://github.com/HoTT/coq},
  owner     = {Jason},
  timestamp = {2014.01.16},
}

@InCollection{spitters2010developing,
  author    = {Spitters, Bas and van der Weegen, Eelis},
  booktitle = {Interactive Theorem Proving},
  date      = {2010},
  title     = {Developing the algebraic hierarchy with type classes in {C}oq},
  doi       = {10.1007/978-3-642-14052-5_35},
  publisher = {Springer},
  url       = {http://www.eelis.net/research/math-classes/mathclasses-diamond.pdf},
  local-url = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/mathclasses-diamond.pdf},
  owner     = {Jason},
  pages-old = {490--493},
  timestamp = {2013.12.24},
}

@MastersThesis{spiwackverified,
  author      = {Spiwack, Arnaud},
  date        = {2011},
  institution = {\'Ecole Polytechnique},
  title       = {Verified Computing in Homological Algebra},
  type        = {PhD thesis},
  url         = {http://assert-false.net/arnaud/papers/thesis.spiwack.pdf},
  local-url   = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/thesis.spiwack.pdf},
  owner       = {Jason},
  timestamp   = {2013.12.20},
}

@MastersThesis{weber02program,
  author      = {Tjark Weber},
  date        = {2002-08},
  institution = {University of Wyoming},
  title       = {Program Transformations in {Nuprl}},
  location    = {Laramie, WY},
  url         = {http://user.it.uu.se/~tjawe125/publications/weber02program.html},
  local-url   = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/weber02program.pdf},
  owner       = {Jason},
  pdf         = {http://user.it.uu.se/~tjawe125/publications/weber02program.pdf},
  timestamp   = {2013.12.24},
}

@Article{wilander2012constructing,
  author       = {Wilander, Olov},
  date         = {2012},
  journaltitle = {Mathematical Structures in Computer Science},
  title        = {Constructing a small category of setoids},
  number       = {1},
  pages        = {103--121},
  url          = {http://www.diva-portal.org/smash/get/diva2:399799/FULLTEXT01.pdf},
  volume       = {22},
  local-url    = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/FULLTEXT01.pdf},
  owner        = {Jason},
  publisher    = {Cambridge Univ Press},
  timestamp    = {2014.01.01},
}

@TechReport{wilander2005bicategory,
  author      = {Wilander, Olov},
  date        = {2005},
  institution = {Technical report, University of Uppsala},
  title       = {An {E}-bicategory of {E}-categories exemplifying a type-theoretic approach to bicategories},
  local-url   = {http://people.csail.mit.edu/jgross/personal-website/papers/academic-papers-local/download_doi=10.1.1.63.5498.pdf},
  owner       = {Jason},
  pdf         = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.5498&rep=rep1&type=pdf},
  timestamp   = {2013.12.24},
}

@Electronic{coq,
  title        = {The {C}oq Proof Assistant},
  url          = {http://coq.inria.fr},
  organization = {{INRIA}},
  key-old      = {Coq},
  owner        = {Jason},
  timestamp    = {2013.12.24},
}

@Electronic{HoTT/HoTT-categories,
  title      = {{HoTT/HoTT} Categories},
  url        = {https://github.com/HoTT/HoTT/tree/master/theories/categories},
  author-old = {Jason Gross},
  owner      = {Jason},
  timestamp  = {2014.01.01},
}

@Electronic{wiki:adjoint-functors:universal-morphisms,
  date         = {2013-12},
  title        = {Adjoint functors: Formal definitions: Universal morphisms},
  url          = {http://en.wikipedia.org/wiki/Adjoint_functors#Universal_morphisms},
  organization = {Wikipedia, the free encyclopedia},
  author-old   = {Wikipedia},
  owner        = {Jason},
  timestamp    = {2014.01.07},
}

@Electronic{ncatlab:adjoint+functor:UniversalArrows,
  date         = {2012-11},
  title        = {adjoint functor: in terms of universal arrows / universal factorization through unit and counit},
  url          = {http://ncatlab.org/nlab/show/adjoint+functor#UniversalArrows},
  organization = {nCatLab},
  author-old   = {nCatLab},
  owner        = {Jason},
  timestamp    = {2014.01.07},
}

@Electronic{ncatlab:subobject+classifier,
  date         = {2012-09},
  title        = {subobject classifier},
  url          = {http://ncatlab.org/nlab/show/subobject+classifier},
  organization = {nLab},
  author-old   = {nCatLab},
  owner        = {Jason},
  timestamp    = {2013.12.22},
}

@Book{HoTTBook,
  author        = {{The Univalent Foundations Program}},
  date          = {2013},
  title         = {Homotopy Type Theory: {U}nivalent Foundations of Mathematics},
  url           = {http://homotopytypetheory.org/book/},
  file          = {:hott-ebook.pdf:PDF},
  institute     = {Institute for Advanced Study},
  publisher-old = {{L}ulu {M}arketplace},
}

@Electronic{math-overflow-formalizations,
  title        = {Formalizations of category theory in proof assistants},
  url          = {http://mathoverflow.net/questions/152497/formalizations-of-category-theory-in-proof-assistants},
  organization = {MathOverflow},
  key-old      = {MathOverflow},
  owner        = {Jason},
  timestamp    = {2014.03.28},
}

@InProceedings{adt-synthesis,
  author            = {Ben Delaware and Cl\'ement Pit--Claudel and Jason Gross and Adam Chlipala},
  booktitle         = {Proceedings of the \href{http://popl.mpi-sws.org/2015/}{42nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL'15)}},
  date              = {2015-01},
  title             = {Fiat: Deductive Synthesis of Abstract Data Types in a Proof Assistant},
  doi               = {10.1145/2676726.2677006},
  url               = {https://people.csail.mit.edu/jgross/personal-website/papers/2015-adt-synthesis.pdf},
  abstract          = {We present Fiat, a library for the Coq proof assistant supporting refinement of declarative specifications into efficient functional programs with a high degree of automation. Each refinement process leaves a proof trail, checkable by the normal Coq kernel, justifying its soundness. We focus on the synthesis of abstract data types that package methods with private data. We demonstrate the utility of our framework by applying it to the synthesis of \textit{query structures} -- abstract data types with SQL-like query and insert operations. Fiat includes a library for writing specifications of query structures in SQL-inspired notation, expressing operations over relations (tables) in terms of mathematical sets. This library includes a set of tactics for automating the refinement of these specifications into efficient, correct-by-construction OCaml code. Using these tactics, a programmer can generate such an implementation completely automatically by only specifying the equivalent of SQL indexes, data structures capturing useful views of the abstract data. We conclude by speculating on the new programming modularity possibilities enabled by an automated refinement system with proved-correct rules.},
  acm-authorize-url = {https://dl.acm.org/authorize?N20774},
  artifact-tar-gz   = {https://people.csail.mit.edu/jgross/personal-website/media/2015-popl/fiat-20141031.tar.gz},
  owner             = {Jason},
  project-homepage  = {http://plv.csail.mit.edu/fiat/},
  timestamp         = {2014.10.07},
}

@Misc{coqpl-15-coq-bug-minimizer,
  author    = {Jason Gross},
  date      = {2015-01},
  title     = {Coq Bug Minimizer},
  note      = {Presented at \href{https://coqpl.cs.washington.edu/2014/07/31/}{The First International Workshop on Coq for PL (CoqPL'15)}},
  url       = {https://people.csail.mit.edu/jgross/personal-website/papers/2015-coq-bug-minimizer.pdf},
  abstract  = {Are bugs the bane of your existence? Do you dread Coq upgrades, because they mean you'll have to spend days tracking down subtle failures deep in your developments? Have you ever hit an anomaly that just wouldn't go away, and wished you understood what triggered it? Have you ever been tormented by two blocks of code that looked identical, but behaved differently? Do you wish you submit more helpful error reports, but don't want to put in the time to construct minimal examples? If you answered ``yes'' to any of these questions, then the Coq Bug Minimizer is for you! Clone your own copy at \url{https://github.com/JasonGross/coq-bug-finder}.},
  owner     = {Jason},
  reviews   = {https://people.csail.mit.edu/jgross/personal-website/papers/2015-coq-bug-minimizer-reviews.txt},
  timestamp = {2014.10.07},
}

@MastersThesis{jgross-masters-thesis,
  author      = {Jason Gross},
  date        = {2015-09},
  institution = {Massachusetts Institute of Technology},
  title       = {An Extensible Framework for Synthesizing Efficient, Verified Parsers},
  url         = {https://people.csail.mit.edu/jgross/personal-website/papers/2015-jgross-thesis.pdf},
  abstract    = {Parsers have a long history in computer science. This thesis proposes a novel approach to synthesizing efficient, verified parsers by refinement, and presents a demonstration of this approach in the Fiat framework by synthesizing a parser for arithmetic expressions. The benefits of this framework may include more flexibility in the parsers that can be described, more control over the low-level details when necessary for performance, and automatic or mostly automatic correctness proofs.},
}

@InProceedings{category-coq-experience,
  author                      = {Jason Gross and Adam Chlipala and David I. Spivak},
  booktitle                   = {Proceedings of the \href{http://www.cs.uwyo.edu/~ruben/itp-2014}{5th International Conference on Interactive Theorem Proving (ITP'14)}},
  date                        = {2014-07},
  title                       = {Experience Implementing a Performant Category-Theory Library in {C}oq},
  doi                         = {10.1007/978-3-319-08970-6_18},
  eprint                      = {1401.7694},
  url                         = {https://people.csail.mit.edu/jgross/personal-website/papers/category-coq-experience-itp-submission-final.pdf},
  abstract                    = {We describe our experience implementing a broad category-theory library in Coq. Category theory and computational performance are not usually mentioned in the same breath, but we have needed substantial engineering effort to teach Coq to cope with large categorical constructions without slowing proof script processing unacceptably. In this paper, we share the lessons we have learned about how to represent very abstract mathematical objects and arguments in Coq and how future proof assistants might be designed to better support such reasoning. One particular encoding trick to which we draw attention allows category-theoretic arguments involving \emph{duality} to be internalized in Coq's logic with definitional equality. Ours may be the largest Coq development to date that uses the relatively new Coq version developed by homotopy type theorists, and we reflect on which new features were especially helpful.},
  full-bibliography           = {https://people.csail.mit.edu/jgross/personal-website/papers/category-coq-experience.html},
  original-url                = {https://people.csail.mit.edu/jgross/personal-website/papers/category-coq-experience-itp-submission.pdf},
  owner                       = {Jason},
  presentation-annotated-pptx = {https://people.csail.mit.edu/jgross/personal-website/presentations/itp-2014/category-coq-experience.pptx},
  presentation-pdf            = {https://people.csail.mit.edu/jgross/personal-website/presentations/itp-2014/category-coq-experience.pdf},
  published-url-springer      = {http://link.springer.com/chapter/10.1007/978-3-319-08970-6_18},
  reviews                     = {https://people.csail.mit.edu/jgross/personal-website/papers/category-coq-experience-itp-2014-reviews.txt},
  timestamp                   = {2014.01.19},
}

@Misc{coqpl-15-ltac-profiler,
  author    = {Tobias Tebbi and Jason Gross},
  date      = {2015-01},
  title     = {A Profiler for {L}tac},
  note      = {Presented at \href{https://coqpl.cs.washington.edu/2014/07/31/}{The First International Workshop on Coq for PL (CoqPL'15)}},
  url       = {https://people.csail.mit.edu/jgross/personal-website/papers/2015-ltac-profiler.pdf},
  abstract  = {We present a simple profiler for the Ltac tactic language of the Coq Proof Assistent. It measures the time spent in invocations of primitive tactics as well as tactics defined in Ltac and their inner invocations. The profiler is controlled using Vernacular commands and prints an aggregated view that differentiates between tactic invocations depending on their call tree location.},
  owner     = {Jason},
  timestamp = {2014.10.17},
}

@InProceedings{FiatCryptoSP19,
  author      = {Andres Erbsen and Jade Philipoom and Jason Gross and Robert Sloan and Adam Chlipala},
  booktitle   = {IEEE Security \& Privacy},
  date        = {2019-05},
  title       = {Simple High-Level Code For Cryptographic Arithmetic -- With Proofs, Without Compromises},
  doi         = {10.1109/sp.2019.00005},
  location    = {San Francisco, CA, USA},
  url         = {http://adam.chlipala.net/papers/FiatCryptoSP19/},
  abstract    = {We introduce a new approach for implementing cryptographic arithmetic in short high-level code with machine-checked proofs of functional correctness.
We further demonstrate that simple partial evaluation is sufficient to transform into the fastest-known C code, breaking the decades-old pattern that the only fast implementations are those whose instruction-level steps were written out by hand.

These techniques were used to build an elliptic-curve library that achieves competitive performance for 80 prime fields and multiple CPU architectures, showing that implementation and proof effort scales with the number and complexity of conceptually different algorithms, not their use cases.
As one outcome, we present the first verified high-performance implementation of P-256, the most widely used elliptic curve.
Implementations from our library were included in BoringSSL to replace existing specialized code, for inclusion in several large deployments for Chrome, Android, and CloudFlare.},
  code-github = {https://github.com/mit-plv/fiat-crypto},
  owner       = {jgross},
  timestamp   = {2018.06.01},
}

@Article{ringer2020qed,
  author       = {Talia Ringer and Karl Palmskog and Ilya Sergey and Milos Gligoric and Zachary Tatlock},
  date         = {2020-03-13},
  journaltitle = {Foundations and Trends in Programming Languages, Vol. 5, No. 2-3 (Sept. 2019), pp. 102-281},
  title        = {{QED} at Large: A Survey of Engineering of Formally Verified Software},
  doi          = {10.1561/2500000045},
  eprint       = {2003.06458v1},
  eprintclass  = {cs.LO},
  eprinttype   = {arXiv},
  url          = {https://arxiv.org/abs/2003.06458},
  abstract     = {Development of formal proofs of correctness of programs can increase actual and perceived reliability and facilitate better understanding of program specifications and their underlying assumptions. Tools supporting such development have been available for over 40 years, but have only recently seen wide practical use. Projects based on construction of machine-checked formal proofs are now reaching an unprecedented scale, comparable to large software projects, which leads to new challenges in proof development and maintenance. Despite its increasing importance, the field of proof engineering is seldom considered in its own right; related theories, techniques, and tools span many fields and venues. This survey of the literature presents a holistic understanding of proof engineering for program correctness, covering impact in practice, foundations, proof automation, proof organization, and practical proof development.},
  file         = {:http\://arxiv.org/pdf/2003.06458v1:PDF},
  keywords     = {cs.LO, cs.PL, F.3.1; D.2.4; I.2.3},
}

@Article{georges2007statistically,
  author       = {Georges, Andy and Buytaert, Dries and Eeckhout, Lieven},
  date         = {2007},
  journaltitle = {ACM SIGPLAN Notices},
  title        = {Statistically Rigorous Java Performance Evaluation},
  doi          = {10.1145/1297027.1297033},
  number       = {10},
  pages        = {57--76},
  volume       = {42},
  publisher    = {ACM New York, NY, USA},
}

@Article{mytkowicz-wrong-data,
  author       = {Mytkowicz, Todd and Diwan, Amer and Hauswirth, Matthias and Sweeney, Peter F},
  date         = {2009},
  journaltitle = {ACM Sigplan Notices},
  title        = {Producing Wrong Data Without Doing Anything Obviously Wrong!},
  doi          = {10.1145/1508284.1508275},
  number       = {3},
  pages        = {265--276},
  url          = {https://users.cs.northwestern.edu/~robby/courses/322-2013-spring/mytkowicz-wrong-data.pdf},
  volume       = {44},
  abstract     = {This paper presents a surprising result: changing a seemingly
innocuous aspect of an experimental setup can cause a systems researcher to draw wrong conclusions from an experiment. What appears to be an innocuous aspect in the experimental setup may in fact introduce a significant bias in an
evaluation. This phenomenon is called \emph{measurement bias} in
the natural and social sciences.
Our results demonstrate that measurement bias is significant and commonplace in computer system evaluation. By
\emph{significant} we mean that measurement bias can lead to a performance analysis that either over-states an effect or even
yields an incorrect conclusion. By \emph{commonplace} we mean
that measurement bias occurs in all architectures that we
tried (Pentium 4, Core 2, and m5 O3CPU), both compilers
that we tried (gcc and Intel’s C compiler), and most of the
SPEC CPU2006 C programs. Thus, we cannot ignore measurement bias. Nevertheless, in a literature survey of 133 recent papers from ASPLOS, PACT, PLDI, and CGO, we determined that none of the papers with experimental results
adequately consider measurement bias.
Inspired by similar problems and their solutions in other
sciences, we describe and demonstrate two methods, one
for detecting (causal analysis) and one for avoiding (setup
randomization) measurement bias.},
  publisher    = {ACM New York, NY, USA},
}

@InProceedings{CelikETAL17iCoq,
  author       = {Celik, Ahmet and Palmskog, Karl and Gligoric, Milos},
  booktitle    = {2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)},
  date         = {2017},
  title        = {{ɪCᴏǫ}: Regression Proof Selection forLarge-Scale Verification Projects},
  doi          = {10.1109/ase.2017.8115630},
  organization = {IEEE},
  pages        = {171--182},
  url          = {https://users.ece.utexas.edu/~gligoric/papers/CelikETAL17iCoq.pdf},
  abstract     = {Proof assistants such as Coq are used to construct
and check formal proofs in many large-scale verification projects.
As proofs grow in number and size, the need for tool support
to quickly find failing proofs after revising a project increases.
We present a technique for large-scale regression proof selection,
suitable for use in continuous integration services, e.g., Travis CI.
We instantiate the technique in a tool dubbed \textsc{iCoq}. \textsc{iCoq} tracks
fine-grained dependencies between Coq definitions, propositions,
and proofs, and only checks those proofs affected by changes
between two revisions. \textsc{iCoq} additionally saves time by ignoring
changes with no impact on semantics. We applied \textsc{iCoq} to track
dependencies across many revisions in several large Coq projects
and measured the time savings compared to proof checking from
scratch and when using Coq’s timestamp-based toolchain for
incremental checking. Our results show that proof checking with
\textsc{iCoq} is up to 10 times faster than the former and up to 3 times
faster than the latter.},
}

@InProceedings{PalmskogETAL18piCoq,
  author    = {Palmskog, Karl and Celik, Ahmet and Gligoric, Milos},
  booktitle = {Proceedings of the 27th ACM SIGSOFT International Symposium on Software Testing and Analysis},
  date      = {2018},
  title     = {{ᴘɪCᴏǫ}: Parallel regression proving for large-scale verification projects},
  doi       = {10.1145/3213846.3213877},
  pages     = {344--355},
  url       = {http://users.ece.utexas.edu/~gligoric/papers/PalmskogETAL18piCoq.pdf},
  abstract  = {Large-scale verification projects using proof assistants typically
contain many proofs that must be checked at each new project
revision. While proof checking can sometimes be parallelized at
the coarse-grained file level to save time, recent changes in some
proof assistant in the LCF family, such as Coq, enable fine-grained
parallelism at the level of proofs. However, these parallel techniques
are not currently integrated with regression proof selection, a technique that checks only the subset of proofs affected by a change. We
present techniques that blend the power of parallel proof checking
and selection to speed up regression proving in verification projects,
suitable for use both on users’ own machines and in workflows
involving continuous integration services. We implemented the
techniques in a tool, \textsc{piCoq}, which supports Coq projects. \textsc{piCoq}
can track dependencies between files, definitions, and lemmas and
perform parallel checking of only those files or proofs affected
by changes between two project revisions. We applied \textsc{piCoq} to
perform regression proving over many revisions of several large
open source projects and measured the proof checking time. While
gains from using proof-level parallelism and file selection can be
considerable, our results indicate that proof-level parallelism and
proof selection is consistently much faster than both sequential
checking from scratch and sequential checking with proof selection.
In particular, 4-way parallelization is up to 28.6 times faster than
the former, and up to 2.8 times faster than the latter.},
}

@Article{lean-tactic-language,
  author       = {Ebner, Gabriel and Ullrich, Sebastian and Roesch, Jared and Avigad, Jeremy and de Moura, Leonardo},
  date         = {2017},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  title        = {A Metaprogramming Framework for Formal Verification},
  doi          = {10.1145/3110278},
  number       = {ICFP},
  pages        = {1--29},
  url          = {https://leanprover.github.io/papers/tactic.pdf},
  volume       = {1},
  publisher    = {ACM New York, NY, USA},
}

@Article{Implementing1998Shao,
  author       = {Shao, Zhong and League, Christopher and Monnier, Stefan},
  date         = {1998},
  journaltitle = {ACM SIGPLAN Notices},
  title        = {Implementing Typed Intermediate Languages},
  doi          = {10.1145/291251.289460},
  number       = {1},
  pages        = {313--323},
  volume       = {34},
  publisher    = {ACM New York, NY, USA},
}

@InProceedings{Inductive2003Brady,
  author       = {Brady, Edwin and McBride, Conor and McKinna, James},
  booktitle    = {International Workshop on Types for Proofs and Programs},
  date         = {2003},
  title        = {Inductive Families Need Not Store Their Indices},
  doi          = {10.1007/978-3-540-24849-1_8},
  organization = {Springer},
  pages        = {115--129},
  url          = {https://eb.host.cs.st-andrews.ac.uk/writings/types2003.pdf},
}

@Book{thesis-nogin,
  author    = {Nogin, Aleksey Yuryevich},
  date      = {2002},
  title     = {Theory and Implementation of an Efficient Tactic-Based Logical Framework},
  publisher = {Cornell University},
  url       = {http://www.nuprl.org/documents/Nogin/thesis-nogin.pdf},
  abstract  = {Formal methods are successfully used in a wide range of applications — from hardware and software verification to formalizing mathematics and education. However their impact is limited and is very far from realizing the full potential of formal methods. Our investigation of these limitations shows that they can not be avoided by simply fine-tuning existing tools and methods. We demonstrate the need to concentrate on improving and extending the underlying theory and methodology of computer-aided formal reasoning.

This thesis explores both practical and theoretical aspects of achieving these improvements; we present solutions for some of the outstanding problems and substantial improvements for others. In particular, we improve axiomatizations of the extant logics to make them more accessible to both users of the system and proof automating procedures. We also present methods for very significant speedup of the proof search process. Such additional speed means not only that the theorem prover will work faster, but also users can now take advantage of more advanced proof automation procedures that would have been prohibitively slow otherwise.

This thesis also demonstrates how these wide ranging practical and theoretical results can be brought together in a more efficient and more generic tactic-based formal system. In particular, we present a generic derived rules mechanism and explain how such a mechanism can facilitate practical modularization of a formal system. We also present several approaches to establishing a generic layer of proof automation procedures (tactics) that apply to a wide variety of logical theories. Most of the ideas presented in this thesis were implemented in the MetaPRL logical framework taking advantage of an existing modular flexible design and making it even more modular and more flexible.

After implementing these ideas in the MetaPRL logical framework, we use that system to improve a formalization of NuPRL intuitionistic type theory. In particular, we show how to modularize an axiomatization of a quotient type thus creating a formalization capable of expressing important concepts that were impossible to express in the original monolithic axiomatization. We also show how to add a limited form of classical reasoning to an intuitionistic type theory in a way that preserves many constructive aspects of the theory. Several theorems in this thesis were formally proven in the MetaPRL system.},
}

@InProceedings{Gregoire-Leroy-02,
  author       = {Benjamin Gr{\'e}goire and Xavier Leroy},
  booktitle    = {ICFP 2002: International Conference on Functional Programming},
  date         = {2002},
  title        = {A compiled implementation of strong reduction},
  doi          = {10.1145/581478.581501},
  pages        = {235--246},
  publisher    = {ACM},
  abstract     = {Motivated by applications to proof assistants based on dependent
types, we develop and prove correct a strong reducer and
$\beta$-equivalence checker for the $\lambda$-calculus with products,
sums, and guarded fixpoints.  Our approach is based on compilation to
the bytecode of an abstract machine performing weak reductions on
non-closed terms, derived with minimal modifications from the ZAM
machine used in the Objective Caml bytecode interpreter, and
complemented by a recursive ``read back'' procedure.  An
implementation in the Coq proof assistant demonstrates important
speed-ups compared with the original interpreter-based implementation
of strong reduction in Coq.},
  urllocal     = {http://xavierleroy.org/publi/strong-reduction.pdf},
  urlpublisher = {http://dx.doi.org/10.1145/581478.581501},
  xranking     = {top},
  xtopic       = {caml},
}

@PhdThesis{Strongly2011Kleeblatt,
  author      = {Kleeblatt, Dirk},
  date        = {2011},
  institution = {Technischen Universität Berlin},
  title       = {On a Strongly Normalizing {STG} Machine},
  subtitle    = {With an Application to Dependent Type Checking},
  type        = {phdthesis},
  url         = {https://depositonce.tu-berlin.de/bitstream/11303/3095/1/Dokument_9.pdf},
}

@Software{smallttKovacs,
  author = {András Kovács},
  title  = {smalltt: Demo for high-performance type theory elaboration},
  url    = {https://github.com/AndrasKovacs/smalltt},
}

@Misc{FastKovacs,
  author   = {András Kovács},
  date     = {2019-02-24},
  title    = {Fast Elaboration for Dependent Type Theories},
  location = {EUTypes WG Meeting, Krakow},
  url      = {https://github.com/AndrasKovacs/smalltt/blob/fb56723b098cb1a95e8a5f3f9f5fce30bbcc67da/krakow-pres.pdf},
}

@Software{NormalizationKovacs,
  author = {András Kovács},
  title  = {Normalization Bench},
  url    = {https://github.com/AndrasKovacs/normalization-bench},
}

@Article{GluedEvalKovacs,
  author = {András Kovács},
  title  = {Non-deterministic normalization-by-evaluation in Olle Fredriksson's flavor},
  url    = {https://gist.github.com/AndrasKovacs/a0e0938113b193d6b9c1c0620d853784},
}

@Article{Tabled2020Selsam,
  author      = {Daniel Selsam and Sebastian Ullrich and Leonardo de Moura},
  date        = {2020-01-13},
  title       = {Tabled Typeclass Resolution},
  eprint      = {2001.04301v2},
  eprintclass = {cs.PL},
  eprinttype  = {arXiv},
  abstract    = {Typeclasses provide an elegant and effective way of managing ad-hoc polymorphism in both programming languages and interactive proof assistants. However, the increasingly sophisticated uses of typeclasses within proof assistants, especially within Lean's burgeoning mathematics library, mathlib, have elevated once-theoretical limitations of existing typeclass resolution procedures into major impediments to ongoing progress. The two most devastating limitations of existing procedures are exponential running times in the presence of diamonds and divergence in the presence of cycles. We present a new procedure, tabled typeclass resolution, that solves both problems by tabling, which is a generalization of memoizing originally introduced to address similar limitations of early logic programming systems. We have implemented our procedure for the upcoming version (v4) of Lean, and have confirmed empirically that our implementation is exponentially faster than existing systems in the presence of diamonds. Although tabling is notoriously difficult to implement, our procedure is notably lightweight and could easily be implemented in other systems. We hope our new procedure facilitates even more sophisticated uses of typeclasses in both software development and interactive theorem proving.},
  file        = {:http\://arxiv.org/pdf/2001.04301v2:PDF},
  keywords    = {cs.PL, cs.LO},
}

@Article{Interaction1994Asperti,
  author       = {Asperti, Andrea and Laneve, Cosimo},
  date         = {1994},
  journaltitle = {Mathematical Structures in Computer Science},
  title        = {Interaction Systems {I}: The theory of optimal reductions},
  doi          = {10.1017/s0960129500000566},
  number       = {4},
  pages        = {457--504},
  url          = {https://hal.inria.fr/docs/00/07/69/88/PDF/RR-1748.pdf},
  volume       = {4},
  publisher    = {Cambridge University Press},
}

@InProceedings{asperti1995deltao,
  author       = {Asperti, Andrea},
  booktitle    = {International Conference on Rewriting Techniques and Applications},
  date         = {1995},
  title        = {$\delta$$\omicron$!$\epsilon$=1 Optimizing optimal $\lambda$-calculus implementations},
  editor       = {Hsiang, Jieh},
  isbn         = {978-3-540-49223-8},
  location     = {Berlin, Heidelberg},
  organization = {Springer},
  pages        = {102--116},
  publisher    = {Springer Berlin Heidelberg},
  abstract     = {In [As94], a correspondence between Lamping-Gonthier's operators for Optimal Reduction of the $\lambda$-calculus [Lam90, GAL92a] and the operations associated with the comonad ``!'' of Linear Logic was established. In this paper, we put this analogy at work, adding new rewriting rules directly suggested by the categorical equations of the comonad. These rules produce an impressive improvement of the performance of the reduction system, and provide a first step towards the solution of the well known and crucial problem of accumulation of control operators.},
}

@TechReport{Bologna1995Asperti,
  author      = {Asperti, Andrea and Giovannetti, Cecilia and Naletto, Andrea},
  date        = {1995-03},
  institution = {University of Bologna},
  title       = {The Bologna Optimal Higher-order Machine},
  doi         = {10.1017/s0956796800001994},
  url         = {https://pdfs.semanticscholar.org/3517/03af066fd2e65ad64c63108672d960b9d8fb.pdf},
  year        = {1995},
}

@InProceedings{algorithm1989Lamping,
  author    = {Lamping, John},
  booktitle = {Proceedings of the 17th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
  date      = {1989},
  title     = {An algorithm for optimal lambda calculus reduction},
  doi       = {10.1145/96709.96711},
  pages     = {16--30},
}

@Misc{geometry1992Gonthier,
  author = {Georges Gonthier and Martín Abadi and Jean-Jacques Lévy},
  date   = {1992},
  title  = {The geometry of optimal lambda reduction},
  doi    = {10.1145/143165.143172},
}

@InCollection{Optimal1980Levy,
  author    = {Jean-Jacques Lévy},
  booktitle = {To {H}.~{B}.~{C}urry: Essays on Combinatory Logic, Lambda Calculus and Formalism},
  date      = {1980},
  title     = {Optimal reductions in the lambda-calculus},
  editor    = {J. P. Seldin and J. R. Hindley},
  publisher = {Academic Press},
  url       = {http://pauillac.inria.fr/~levy/pubs/80curry.pdf},
}

@Electronic{SOOnlineTTReferenceKovacs,
  author = {András Kovács},
  date   = {2019-12-10},
  title  = {Online reference book for *implementing* concepts in type theory.},
  url    = {https://math.stackexchange.com/a/3468022/22982},
}

@Misc{SharingKovacs,
  author   = {András Kovács},
  date     = {2018-01},
  title    = {Sharing-Preserving Elaboration with Precisely Scoped Metavariables},
  location = {Agda Implementors’ Meeting XXVI},
  url      = {https://github.com/AndrasKovacs/elaboration-zoo/blob/0c7f8a676c0964cc05c247879393e97729f59e5b/AIMprez/AIMprez.pdf},
}

@InProceedings{Programming2000Barras,
  author    = {Barras, Bruno},
  booktitle = {Theorem Proving in Higher Order Logics},
  date      = {2000},
  title     = {Programming and Computing in {HOL}},
  doi       = {10.1007/3-540-44659-1_2},
  editor    = {Aagaard, Mark and Harrison, John},
  isbn      = {978-3-540-44659-0},
  location  = {Berlin, Heidelberg},
  pages     = {17--37},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {This article describes a set of derived inference rules and an abstract reduction machine using them that allow the inplementation of an interpreter for HOL terms, with the same complexity as with ML code. The latter fact allows us to use HOL as a computer algebra system in which the user can implement algorithms, provided he proved them correct.},
}

@Book{Efficiency1994Boulton,
  author    = {Boulton, Richard},
  date      = {1994-11},
  title     = {Efficiency in a Fully-Expansive Theorem Prover},
  publisher = {University of Cambridge, Computer Laboratory},
  series    = {Computer Laboratory Cambridge: Technical report},
  url       = {https://books.google.com/books?id=7DAkAQAAIAAJ},
}

@Article{LCF2019Paulson,
  author      = {Lawrence C. Paulson and Tobias Nipkow and Makarius Wenzel},
  date        = {2019-07-05},
  title       = {From {LCF} to {I}sabelle/{HOL}},
  doi         = {10.1007/s00165-019-00492-1},
  eprint      = {1907.02836v2},
  eprintclass = {cs.LO},
  eprinttype  = {arXiv},
  abstract    = {Interactive theorem provers have developed dramatically over the past four decades, from primitive beginnings to today's powerful systems. Here, we focus on Isabelle/HOL and its distinctive strengths. They include automatic proof search, borrowing techniques from the world of first order theorem proving, but also the automatic search for counterexamples. They include a highly readable structured language of proofs and a unique interactive development environment for editing live proof documents. Everything rests on the foundation conceived by Robin Milner for Edinburgh LCF: a proof kernel, using abstract types to ensure soundness and eliminate the need to store proofs. Compared with the research prototypes of the 1970s, Isabelle is a practical and versatile tool. It is used by system designers, mathematicians and many others.},
  file        = {:http\://arxiv.org/pdf/1907.02836v2:PDF},
  keywords    = {cs.LO},
}

@Misc{TrustedSlind,
  author   = {Konrad Slind},
  date     = {2010-08},
  title    = {Trusted Extensions of Interactive Theorem Provers: Workshop Summary},
  location = {Cambridge, England},
  url      = {http://www.cs.utexas.edu/users/kaufmann/itp-trusted-extensions-aug-2010/summary/summary.pdf},
  xurl     = {http://www.cs.utexas.edu/users/kaufmann/itp-trusted-extensions-aug-2010/summary/summary.pdf},
}

@Article{Should1999Lamport,
  author       = {Lamport, Leslie and Paulson, Lawrence C.},
  date         = {1999-05},
  journaltitle = {ACM Trans. Program. Lang. Syst.},
  title        = {Should Your Specification Language Be Typed?},
  doi          = {10.1145/319301.319317},
  issn         = {0164-0925},
  number       = {3},
  pages        = {502–526},
  url          = {https://lamport.azurewebsites.net/pubs/lamport-types.pdf},
  volume       = {21},
  issue_date   = {May 1999},
  keywords     = {specification, types, set theory},
  location     = {New York, NY, USA},
  numpages     = {25},
  publisher    = {Association for Computing Machinery},
}

@Article{Formalising2018Paulson,
  author      = {Lawrence C. Paulson},
  date        = {2018-04-20},
  title       = {Formalising Mathematics In Simple Type Theory},
  doi         = {10.1007/978-3-030-15655-8_20},
  eprint      = {1804.07860v1},
  eprintclass = {cs.LO},
  eprinttype  = {arXiv},
  abstract    = {Despite the considerable interest in new dependent type theories, simple type theory (which dates from 1940) is sufficient to formalise serious topics in mathematics. This point is seen by examining formal proofs of a theorem about stereographic projections. A formalisation using the HOL Light proof assistant is contrasted with one using Isabelle/HOL. Harrison's technique for formalising Euclidean spaces is contrasted with an approach using Isabelle/HOL's axiomatic type classes. However, every formal system can be outgrown, and mathematics should be formalised with a view that it will eventually migrate to a new formalism.},
  file        = {:http\://arxiv.org/pdf/1804.07860v1:PDF},
  keywords    = {cs.LO, 03A05},
}

@Article{Sealing2020Selsam,
  author      = {Daniel Selsam and Simon Hudon and Leonardo de Moura},
  date        = {2020-03-03},
  title       = {Sealing Pointer-Based Optimizations Behind Pure Functions},
  eprint      = {2003.01685v1},
  eprintclass = {cs.PL},
  eprinttype  = {arXiv},
  abstract    = {Functional programming languages are particularly well-suited for building automated reasoning systems, since (among other reasons) a logical term is well modeled by an inductive type, traversing a term can be implemented generically as a higher-order combinator, and backtracking is dramatically simplified by persistent datastructures. However, existing pure functional programming languages all suffer a major limitation in these domains: traversing a term requires time proportional to the tree size of the term as opposed to its graph size. This limitation would be particularly devastating when building automation for interactive theorem provers such as Lean and Coq, for which the exponential blowup of term-tree sizes has proved to be both common and difficult to prevent. All that is needed to recover the optimal scaling is the ability to perform simple operations on the memory addresses of terms, and yet allowing these operations to be used freely would clearly violate the basic premise of referential transparency. We show how to use dependent types to seal the necessary pointer-address manipulations behind pure functional interfaces while requiring only a negligible amount of additional trust. We have implemented our approach for the upcoming version (v4) of Lean, and our approach could be adopted by other languages based on dependent type theory as well.},
  file        = {:http\://arxiv.org/pdf/2003.01685v1:PDF},
  keywords    = {cs.PL},
}

@Electronic{CC++Performance2017,
  date         = {2017-11-11},
  title        = {A Performance-Based Comparison of C/C++ Compilers},
  url          = {https://colfaxresearch.com/compiler-comparison/},
  organization = {Colfax Research},
}

@InProceedings{Coqoon2016Faithfull,
  author    = {Faithfull, Alexander and Bengtson, Jesper and Tassi, Enrico and Tankink, Carst},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
  date      = {2016},
  title     = {Coqoon},
  doi       = {10.1007/s10009-017-0457-2},
  editor    = {Chechik, Marsha and Raskin, Jean-Fran{\c{c}}ois},
  isbn      = {978-3-662-49674-9},
  location  = {Berlin, Heidelberg},
  pages     = {316--331},
  publisher = {Springer Berlin Heidelberg},
  subtitle  = {An {IDE} for Interactive Proof Development in {C}oq},
  url       = {https://hal.inria.fr/hal-01242295/document},
  abstract  = {User interfaces for interactive proof assistants have always lagged behind those for mainstream programming languages. Whereas integrated development environments---IDEs---have support for features like project management, version control, dependency analysis and incremental project compilation, ``IDE''s for proof assistants typically only operate on files in isolation, relying on external tools to integrate those files into larger projects. In this paper we present Coqoon, an IDE for Coq developments integrated into Eclipse. Coqoon manages proofs as projects rather than isolated source files, and compiles these projects using the Eclipse common build system. Coqoon takes advantage of the latest features of Coq, including asynchronous and parallel processing of proofs, and---when used together with a third-party OCaml extension for Eclipse---can even be used to work on large developments containing Coq plugins.},
}

@Electronic{TypedUntyped2018Malecha,
  author = {Gregory Malecha},
  date   = {2018-02-20},
  title  = {To Be Typed and Untyped},
  url    = {https://gmalecha.github.io/reflections/2018/to-be-typed-or-untyped},
}

@Electronic{Speeding2017Malecha,
  author = {Gregory Malecha},
  date   = {2017-06-05},
  title  = {Speeding Up Proofs with Computational Reflection},
  url    = {https://gmalecha.github.io/reflections/2017/speeding-up-proofs-with-computational-reflection},
}

@Article{malecha2013mirror-shard,
  author       = {Gregory Malecha and Adam Chlipala and Thomas Braibant and Patrick Hulin and Edward Z. Yang},
  date         = {2013},
  journaltitle = {CoRR},
  title        = {MirrorShard: Proof by Computational Reflection with Verified Hints},
  eprint       = {1305.6543},
  eprinttype   = {arxiv},
  volume       = {abs/1305.6543},
  bibsource    = {dblp computer science bibliography, http://dblp.org},
  biburl       = {http://dblp.uni-trier.de/rec/bib/journals/corr/abs-1305-6543},
  timestamp    = {Sun, 02 Jun 2013 20:48:21 +0200},
}

@InBook{LCF2000Gordon,
  author    = {Michael John Caldwell Gordon},
  booktitle = {Proof, Language, and Interaction: Essays in Honour of Robin Milner},
  title     = {From {LCF} to {HOL}: A Short History},
  isbn      = {0262161885},
  pages     = {169--185},
  publisher = {MIT Press},
  url       = {https://www.cl.cam.ac.uk/archive/mjcg/papers/HolHistory.pdf},
  address   = {Cambridge, MA, USA},
  numpages  = {17},
  year      = {2000},
}

@Article{Tactics2015Gordon,
  author    = {Michael John Caldwell Gordon},
  title     = {Tactics for mechanized reasoning: a commentary on Milner (1984) `The use of machines to assist in rigorous proof'},
  doi       = {10.1098/rsta.2014.0234},
  number    = {2039},
  pages     = {20140234},
  volume    = {373},
  journal   = {Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences},
  publisher = {The Royal Society Publishing},
  year      = {2015},
}

@InProceedings{Role2005Barras,
  author    = {Barras, Bruno and Gr{\'e}goire, Benjamin},
  booktitle = {Computer Science Logic},
  date      = {2005},
  title     = {On the Role of Type Decorations in the Calculus of Inductive Constructions},
  doi       = {10.1007/11538363_12},
  editor    = {Ong, Luke},
  isbn      = {978-3-540-31897-2},
  pages     = {151--166},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {In proof systems like Coq [16], proof-checking involves comparing types modulo $\beta$-conversion, which is potentially a time-consuming task. Significant speed-ups are achieved by compiling proof terms, see [9]. Since compilation erases some type information, we have to show that convertibility is preserved by type erasure. This article shows the equivalence of the Calculus of Inductive Constructions (formalism of Coq) and its domain-free version where parameters of inductive types are also erased. It generalizes and strengthens significantly a similar result by Barthe and S{\o}rensen [5] on the class of functional Domain-free Pure Type Systems.},
  address   = {Berlin, Heidelberg},
  year      = {2005},
}

@Electronic{Idris2Faster2020Brady,
  author = {Edwin Brady},
  date   = {2020-05-20},
  title  = {Why is {I}dris 2 so much faster than {I}dris 1?},
  url    = {https://www.type-driven.org.uk/edwinb/why-is-idris-2-so-much-faster-than-idris-1.html},
}

@Electronic{NewCoqTactics2016Pedrot,
  author = {Pierre-Marie Pédrot},
  date   = {2016-02-14},
  title  = {{C}oq{HoTT}-minute: Ticking like a Clockwork: the New {C}oq Tactics},
  url    = {http://coqhott.gforge.inria.fr/blog/coq-tactic-engine/},
}

@Article{Nominal2003Pitts,
  author       = {Andrew M. Pitts},
  date         = {2003},
  journaltitle = {Information and Computation},
  title        = {Nominal logic, a first order theory of names and binding},
  doi          = {10.1016/S0890-5401(03)00138-X},
  issn         = {0890-5401},
  note         = {Theoretical Aspects of Computer Software (TACS 2001)},
  number       = {2},
  pages        = {165--193},
  url          = {https://www.sciencedirect.com/science/article/pii/S089054010300138X},
  volume       = {186},
  abstract     = {This paper formalises within first-order logic some common practices in computer science to do with representing and reasoning about syntactical structures involving lexically scoped binding constructs. It introduces Nominal Logic, a version of first-order many-sorted logic with equality containing primitives for renaming via name-swapping, for freshness of names, and for name-binding. Its axioms express properties of these constructs satisfied by the FM-sets model of syntax involving binding, which was recently introduced by the author and M.J. Gabbay and makes use of the Fraenkel–Mostowski permutation model of set theory. Nominal Logic serves as a vehicle for making two general points. First, name-swapping has much nicer logical properties than more general, non-bijective forms of renaming while at the same time providing a sufficient foundation for a theory of structural induction/recursion for syntax modulo α-equivalence. Secondly, it is useful for the practice of operational semantics to make explicit the equivariance property of assertions about syntax – namely that their validity is invariant under name-swapping.},
  keywords     = {Abstract syntax, Variable binding, Permutation, Fresh names},
}

@Article{Locally2012Chargueraud,
  author       = {Arthur Charguéraud},
  date         = {2012-10},
  journaltitle = {Journal of Automated Reasoning},
  title        = {The Locally Nameless Representation},
  doi          = {10.1007/s10817-011-9225-2},
  language     = {English},
  number       = {3},
  pages        = {363--408},
  url          = {https://www.chargueraud.org/research/2009/ln/main.pdf},
  volume       = {49},
  abstract     = {This paper provides an introduction to the locally nameless approach to the representation of syntax with variable binding, focusing in particular on the use of this technique in formal proofs. First, we explain the benefits of representing bound variables with de Bruijn indices while retaining names for free variables. Then, we explain how to describe and manipulate syntax in that form, and show how to define and reason about judgments on locally nameless terms.},
  isbn         = {01687433},
  keywords     = {Computers--Automation},
}

@Comment{jabref-meta: databaseType:biblatex;}
