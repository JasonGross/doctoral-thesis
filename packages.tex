\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage[svgnames]{xcolor}
\usepackage{xstring}
\usepackage{bussproofs}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{marvosym}
\usepackage{mathtools}
%\usepackage[utf8x]{inputenc}
\usepackage{float}
%\usepackage{microtype}
\usepackage{textcomp}
\usepackage{attachfile2}
\usepackage{etoolbox}
\usepackage[backend=bibtex,maxbibnames=99]{biblatex}
%\usepackage{embedfile}
%\usepackage{hypgotoe}
\floatstyle{boxed}
\restylefloat{figure}

\renewcommand{\chapterautorefname}{Chapter}
\renewcommand{\sectionautorefname}{Section}
\renewcommand{\subsectionautorefname}{Subsection}
\renewcommand{\subsubsectionautorefname}{Subsubsection}
\newcommand{\appendixautoref}[1]{\bgroup
\def\chapterautorefname{Appendix}%
\def\sectionautorefname{Appendix}%
\def\subsectionautorefname{Appendix}%
\def\subsubsectionautorefname{Appendix}%
\autoref{#1}%
\egroup}

{\catcode`\_=12 \gdef\textunderscore{_}}
\def\_{\textunderscore}

% from http://tex.stackexchange.com/a/218441/2066
\makeatletter
\newcommand{\dashover}[2][\mathop]{#1{\mathpalette\df@over{{\dashfill}{#2}}}}
\newcommand{\fillover}[2][\mathop]{#1{\mathpalette\df@over{{\solidfill}{#2}}}}
\newcommand{\df@over}[2]{\df@@over#1#2}
\newcommand\df@@over[3]{%
  \vbox{
    \offinterlineskip
    \ialign{##\cr
      #2{#1}\cr
      \noalign{\kern1pt}
      $\m@th#1#3$\cr
    }
  }%
}
\newcommand{\dashfill}[1]{%
  \kern-.5pt
  \xleaders\hbox{\kern.5pt\vrule height.4pt width \dash@width{#1}\kern.5pt}\hfill
  \kern-.5pt
}
\newcommand{\dash@width}[1]{%
  \ifx#1\displaystyle
    2pt
  \else
    \ifx#1\textstyle
      1.5pt
    \else
      \ifx#1\scriptstyle
        1.25pt
      \else
        \ifx#1\scriptscriptstyle
          1pt
        \fi
      \fi
    \fi
  \fi
}
\newcommand{\solidfill}[1]{\leaders\hrule\hfill}
\makeatother

\newcommand{\aswidthof}[2]{\rlap{#1}\hphantom{#2}}

\newcommand{\kw}[1]{{\fontfamily{pcr}\selectfont\textbf{#1}}}
\newcommand{\tactic}[1]{\texttt{#1}}
\newcommand{\finishingtactic}[1]{\tactic{#1}}
\newcommand{\tacREFLEXIVITY}{\finishingtactic{reflexivity}}
\newcommand{\strcolored}[1]{\texttt{\textcolor{DarkGreen}{#1}}}
\newcommand{\stropen}{\texttt{"}}
\newcommand{\strclose}{\texttt{"}}
\newcommand{\str}[1]{\stropen\strcolored{#1}\strclose}
\newcommand{\regex}[1]{\texttt{#1}}
\newcommand{\nt}[1]{\texttt{#1}}
\newcommand{\terminal}[1]{\texttt{\textquotesingle\textcolor{DarkGreen}{#1}\textquotesingle}}
\newcommand{\production}[1]{[#1]}
\newcommand{\productions}[1]{#1}
\newcommand{\coqtype}[1]{\texttt{#1}}
\newcommand{\False}{\ensuremath{\bot}}
\newcommand{\True}{\ensuremath{\top}}
\newcommand{\Unit}{\ensuremath{\top}}
\newcommand{\true}{\texttt{true}}
\newcommand{\false}{\texttt{false}}
\newcommand{\unittt}{\texttt{()}}
\newcommand{\String}{\texttt{String}}
\newcommand{\Bool}{\texttt{Bool}}
\newcommand{\nat}{\ensuremath{\mathbb{N}}}
\newcommand{\textnbsp}{\ifmmode\else~\fi}
\newcommand{\typeprodsep}{\ensuremath{\times}}
\newcommand{\typeprod}[2]{#1\textnbsp\typeprodsep\textnbsp#2}
\newcommand{\typesumsep}{\ensuremath{+}}
\newcommand{\typesum}[2]{#1\textnbsp\typesumsep\textnbsp#2}
\newcommand{\fname}[1]{\texttt{#1}}
\newcommand{\farg}[1]{\textcolor{violet}{\texttt{#1}}}
\newcommand{\oftypesep}{:}
\newcommand{\oftype}[2]{#1\textnbsp\oftypesep\textnbsp#2}
\newcommand{\nil}{\texttt{[]}}
\newcommand{\cons}[2]{#1::#2}
\newcommand{\hole}{\texttt{\_}}
\newcommand{\termhole}{\texttt{\_}}
\newcommand{\defeq}{\coloneqq}
\newcommand{\testeq}{=}
\newcommand{\booland}{\mathrel{\texttt{\&\&}}}
\newcommand{\boolor}{\mathrel{\texttt{||}}}
\newcommand{\letinlet}{\kw{let}~}
\newcommand{\letin}[1]{\letinlet#1~\kw{in}}
\newcommand{\strcat}[2]{#1#2}
\newcommand{\llstrcat}[2]{#1 \ensuremath{\cdot} #2}
\newcommand{\afun}[2]{\ensuremath{\lambda~#1.~#2}}
\newcommand{\typeto}{\ensuremath{\to}}
\newcommand{\indname}[1]{\texttt{#1}}
\newcommand{\Type}{\kw{Type}}
\newcommand{\Prop}{\kw{Prop}}
\newcommand{\constructorname}[1]{\texttt{#1}}
\newcommand{\Nonterminal}{\indname{Nonterminal}}
\newcommand{\Terminal}{\texttt{Char}}
\newcommand{\parsetreetype}[2]{\ensuremath{\dashover[]{#2 \in #1}}}
\newcommand{\minparsetreeannot}[2]{\ensuremath{<(#1,#2)}}
\newcommand{\minparsetreetype}[4]{\ensuremath{\dashover[]{#4 \in #3}^{~\minparsetreeannot{#1}{#2}}}}
\newcommand{\typelist}[1]{\texttt{[}#1\texttt{]}}
\newcommand{\typelistp}[1]{\typelist{#1}} % parenthesized \typelist, if need be (so, `list (foo)` instead of `list foo`)
\newcommand{\valuelist}[1]{\texttt{[}#1\texttt{]}}
\newcommand{\valuelistm}[1]{\ensuremath{\big[#1\big]}} % math mode
\newcommand{\typeoption}[2][~~]{\indname{option}#1#2}
\newcommand{\typeoptionp}[1]{\typeoption[~]{(#1)}} % parenthesized \typeoption, if need be
\newcommand{\None}{\constructorname{None}}
\newcommand{\Some}[1]{\constructorname{Some}~#1}
\newcommand{\Somep}[1]{\constructorname{Some}~(#1)}
\newcommand{\ParseQuery}{\indname{ParseQuery}}
\newcommand{\inl}[1]{\constructorname{inl}~#1}
\newcommand{\inlp}[1]{\inl{(#1)}}
\newcommand{\inr}[1]{\constructorname{inr}~#1}
\newcommand{\inrp}[1]{\inr{(#1)}}
\newcommand{\fst}[1]{\texttt{fst}~#1}
\newcommand{\snd}[1]{\texttt{snd}~#1}
\newcommand{\proj}[2]{#2\ensuremath{_{\kw{#1}}}}
\newcommand{\precaseof}{\kw{case}~~~}
\newcommand{\caseof}[1]{\precaseof#1~~~\kw{of}}
\newcommand{\acase}[3][\big]{~#1|{~{#2}~~\ensuremath{\to}~~{#3}}}
\newcommand{\cif}{\kw{if}~~~}
\newcommand{\cifindent}[1][]{\aswidthof{#1}{\kw{then}}~~~}
\newcommand{\cthen}{\cifindent[\kw{then}]}
\newcommand{\celse}{\cifindent[\kw{else}]}
\newcommand{\cancomputeto}[2]{#1~~\ensuremath{\rightsquigarrow}~~#2}
\newcommand{\Ltac}{\ensuremath{\mathcal{L}_{\text{\textit{tac}}}}}
\newcommand{\coqgroupb}[1]{\texttt{\ensuremath{\left(\text{#1}\right)}}}
\newcommand{\coqgroup}[1]{\texttt{(#1)}}
\newcommand{\functiondefeq}{~\ensuremath{\operatorname{\texttt{\ensuremath{\defeq}}}}~}

\usepackage[all]{xy}
% highlight overfull hboxes
%\overfullrule=5pt


% http://tex.stackexchange.com/a/183682/2066
\makeatletter

% define a macro \Autoref to allow multiple references to be passed to \autoref
\newcommand\Autoref[1]{\@first@ref#1,@}
\def\@throw@dot#1.#2@{#1}% discard everything after the dot
\def\@set@refname#1{%    % set \@refname to autoefname+s using \getrefbykeydefault
    \edef\@tmp{\getrefbykeydefault{#1}{anchor}{}}%
    \def\@refname{\@nameuse{\expandafter\@throw@dot\@tmp.@autorefname}s}%
}
\def\@first@ref#1,#2{%
  \ifx#2@\autoref{#1}\let\@nextref\@gobble% only one ref, revert to normal \autoref
  \else%
    \@set@refname{#1}%  set \@refname to autoref name
    \@refname~\ref{#1}% add autoefname and first reference
    \let\@nextref\@next@ref% push processing to \@next@ref
  \fi%
  \@nextref#2%
}
\def\@next@ref#1,#2{%
   \ifx#2@ and~\ref{#1}\let\@nextref\@gobble% at end: print and+\ref and stop
   \else, \ref{#1}% print  ,+\ref and continue
   \fi%
   \@nextref#2%
}

\makeatother
\allowdisplaybreaks