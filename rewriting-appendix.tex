\chapter{Appendices for \autocommanameref{ch:rewriting}}\label{ch:appendix:rewriting}

% We put this figure here so that the layout is better.
\begin{figure}
\newcommand{\PlusZeroTreeMValSubfloat}[1]{%
  \def\mval{#1}%
  \subfloat[No binders ($m=\mval$)]{%
  \resizebox{0.4\textwidth}{!}{\beginTikzpictureStamped[only marks]{
    \einput{rewriting/perf-Plus0Tree-only-m-\mval-cbv;rewrite-strat(bottomup).txt}
    \einput{rewriting/perf-Plus0Tree-only-m-\mval-cbv;setoid-rewrite.txt}
    \einput{rewriting/perf-Plus0Tree-only-m-\mval-cbv;rewrite-strat(topdown).txt}
    \einput{rewriting/perf-Plus0Tree-only-m-\mval-cbv;rewrite!.txt}
    \einput{rewriting/perf-Plus0Tree-only-m-\mval-Rewrite-for.txt}
    \einput{rewriting/perf-Plus0Tree-only-m-\mval-rewriting.txt}
    \mval
  }
    \pgfplotsset{every axis legend/.append style={
        at={(0.5,-0.2)},
        anchor=north}}
    \begin{axis}[xlabel=$n$,ylabel=time (s),ymode=log,ymin=0.002,ymax=110]
      \addplot[mark=square,color=red] table{rewriting/perf-Plus0Tree-only-m-\mval-cbv;rewrite-strat(bottomup).txt};
      \addplot[mark=*,color=red] table{rewriting/perf-Plus0Tree-only-m-\mval-cbv;setoid-rewrite.txt};
      \addplot[mark=triangle,color=red] table{rewriting/perf-Plus0Tree-only-m-\mval-cbv;rewrite-strat(topdown).txt};
      \addplot[mark=o,color=red] table{rewriting/perf-Plus0Tree-only-m-\mval-cbv;rewrite!.txt};
      \addplot[mark=+,color=blue] table{rewriting/perf-Plus0Tree-only-m-\mval-Rewrite-for.txt};
      \addplot[mark=x,color=ForestGreen] table{rewriting/perf-Plus0Tree-only-m-\mval-rewriting.txt};
      \legend{rewrite\_strat bottomup,setoid\_rewrite,rewrite\_strat topdown,rewrite!,{Our approach including reification, cbv, etc.},Our approach (only rewriting)}
    \end{axis}
  \end{tikzpicture}}%
  \label{fig:timing-Plus0Tree-m=\mval}}%
}%
\PlusZeroTreeMValSubfloat{1}\qquad
\PlusZeroTreeMValSubfloat{2}\qquad
\PlusZeroTreeMValSubfloat{3}
  \caption{Timing of different partial-evaluation implementations for code with no binders for fixed $m$.  Note that we have a logarithmic time scale, because term size is proportional to $2^n$.}\label{fig:timing-Plus0Tree-fixed-m}
\end{figure}


% We put this figure here so that the layout is better.
\begin{figure}
\newcommand{\PlusZeroTreeNValSubfloat}[1]{%
  \def\nval{#1}%
  \subfloat[No binders ($n=\nval$)]{%
  \resizebox{0.4\textwidth}{!}{\beginTikzpictureStamped[only marks]{
      \einput{rewriting/perf-Plus0Tree-only-n-\nval-cbv;rewrite-strat(bottomup).txt}
      \einput{rewriting/perf-Plus0Tree-only-n-\nval-cbv;setoid-rewrite.txt}
      \einput{rewriting/perf-Plus0Tree-only-n-\nval-cbv;rewrite-strat(topdown).txt}
      \einput{rewriting/perf-Plus0Tree-only-n-\nval-cbv;rewrite!.txt}
      \einput{rewriting/perf-Plus0Tree-only-n-\nval-Rewrite-for.txt}
      \einput{rewriting/perf-Plus0Tree-only-n-\nval-rewriting.txt}
      \nval
  }
    \pgfplotsset{every axis legend/.append style={
        at={(0.5,-0.2)},
        anchor=north}}
    \begin{axis}[xlabel=$m$,ylabel=time (s),ymax=10]
      \addplot[mark=square,color=red] table{rewriting/perf-Plus0Tree-only-n-\nval-cbv;rewrite-strat(bottomup).txt};
      \addplot[mark=*,color=red] table{rewriting/perf-Plus0Tree-only-n-\nval-cbv;setoid-rewrite.txt};
      \addplot[mark=triangle,color=red] table{rewriting/perf-Plus0Tree-only-n-\nval-cbv;rewrite-strat(topdown).txt};
      \addplot[mark=o,color=red] table{rewriting/perf-Plus0Tree-only-n-\nval-cbv;rewrite!.txt};
      \addplot[mark=+,color=blue] table{rewriting/perf-Plus0Tree-only-n-\nval-Rewrite-for.txt};
      \addplot[mark=x,color=ForestGreen] table{rewriting/perf-Plus0Tree-only-n-\nval-rewriting.txt};
      \legend{rewrite\_strat bottomup,setoid\_rewrite,rewrite\_strat topdown,rewrite!,{Our approach including reification, cbv, etc.},Our approach (only rewriting)}
    \end{axis}
  \end{tikzpicture}}%
  \label{fig:timing-Plus0Tree-n=\nval}}%
}%
\PlusZeroTreeNValSubfloat{1}\qquad
\PlusZeroTreeNValSubfloat{2}\qquad
\PlusZeroTreeNValSubfloat{3}\qquad
%\PlusZeroTreeNValSubfloat{4}\qquad
%\PlusZeroTreeNValSubfloat{5}\qquad
%\PlusZeroTreeNValSubfloat{6}\qquad
%\PlusZeroTreeNValSubfloat{7}\qquad
%\PlusZeroTreeNValSubfloat{8}\qquad
\PlusZeroTreeNValSubfloat{9}
  \caption{Timing of different partial-evaluation implementations for code with no binders for fixed $n$ (1, 2, 3, and then we jump to 9)}\label{fig:timing-Plus0Tree-fixed-n}
\end{figure}

% \begin{figure}
%   \begin{tikzpicture}[only marks]
%   \pgfplotsset{every axis legend/.append style={
%       at={(0.5,-0.2)},
%       anchor=north}}
%     \begin{axis}[xlabel=$\text{term size} = (m+1)\cdot 2^{n+1}-m$,ylabel=time (s)]
%       \addplot[mark=+,color=blue] table{rewriting/perf-Plus0Tree-Rewrite-for.txt};
%       \addplot[mark=x,color=ForestGreen] table{rewriting/perf-Plus0Tree-rewriting.txt};
%       \addplot[mark=o,color=red] table{rewriting/perf-Plus0Tree-cbv;rewrite!.txt};
%       \addplot[mark=*,color=red] table{rewriting/perf-Plus0Tree-cbv;setoid-rewrite.txt};
%       \addplot[mark=square,color=red] table{rewriting/perf-Plus0Tree-cbv;rewrite-strat(bottomup).txt};
%       \addplot[mark=triangle,color=red] table{rewriting/perf-Plus0Tree-cbv;rewrite-strat(topdown).txt};
%       \legend{Our approach including reification,Our approach (only rewriting),rewrite!,setoid\_rewrite,rewrite\_strat bottomup,rewrite\_strat topdown}
%     \end{axis}
%   \end{tikzpicture}
%   \caption{\label{fig:timing-Plus0Tree}Timing of different partial-evaluation implementations for code with no binders}
% \end{figure}


\section{Additional Benchmarking Plots}\label{sec:additionalPlots}

\subsection{Rewriting Without Binders}\label{sec:additionalPlots:Plus0Tree}

The code in \autoref{fig:micro:Plus0Tree:code} in \autoref{sec:micro:Plus0Tree} is parameterized on both $n$, the height of the tree, and $m$, the number of rewriting occurrences per node.
The plot in \autoref{fig:timing-Plus0Tree} displays only the case of $n=\NoBindersSubfloatNval$.
The plots in \autoref{fig:timing-Plus0Tree-fixed-m} display how performance scales as a factor of $n$ for fixed $m$, and the plots in \autoref{fig:timing-Plus0Tree-fixed-n} display how performance scales as a factor of $m$ for fixed $n$.
Note the logarithmic scaling on the time axis in the plots in \autoref{fig:timing-Plus0Tree-fixed-m}, as term size is proportional to $m\cdot 2^n$.

We can see from these graphs and the ones in \autoref{fig:timing-Plus0Tree-fixed-n} that
(a) we incur constant overhead over most of the other methods, which dominates on small examples;
(b) when the term is quite large and there are few opportunities for rewriting relative to the term size (i.e., $m \le 2$), we are worse than \mintinline{coq}{rewrite !Z.add_0_r} but still better than the other methods; and
(c) when there are many opportunities for rewriting relative to the term size ($m > 2$), we thoroughly dominate the other methods.

\clearpage

\subsection{Additional Information on the Fiat Cryptography Benchmark}\label{sec:additionalPlots:FiatCrypto}\label{sec:additionalMacro}

\begin{figure}[b]
  \newcommand{\MacroSubfloat}[3]{%
    \subfloat[Timing of different partial-evaluation implementations for Fiat Cryptography as prime modulus grows (only #2 #3)]{%
  \resizebox{0.45\textwidth}{!}{\beginTikzpictureStamped[only marks]{
      \einput{rewriting/perf-new-vm-times--only-#1-#3.txt}
      \einput{rewriting/perf-old-vm-times--only-#1-#3.txt}
      \einput{rewriting/perf-new-extraction-times--only-#1-#3.txt}
  }
    \pgfplotsset{every axis legend/.append style={
        at={(0.5,-0.2)},
        anchor=north}}
    \begin{axis}[xlabel=prime,ylabel=time (s),xmode=log, ymode=log,log basis x={2}]
      \addplot[mark=+] table{rewriting/perf-new-vm-times--only-#1-#3.txt};
      \addplot[mark=o] table{rewriting/perf-old-vm-times--only-#1-#3.txt};
      \addplot[mark=*] table{rewriting/perf-new-extraction-times--only-#1-#3.txt};
      \legend{Our approach w/ Coq's VM,Old approach (handwritten-CPS+VM),Our approach w/ extracted OCaml}
    \end{axis}
  \end{tikzpicture}}%
  \label{fig:timing--only-#1-#3}}%
  }%
  \MacroSubfloat{UnsaturatedSolinas}{unsaturated Solinas}{x32}\qquad
  \MacroSubfloat{UnsaturatedSolinas}{unsaturated Solinas}{x64}\\
  \MacroSubfloat{WordByWordMontgomery}{word-by-word Montgomery}{x32}\qquad
  \MacroSubfloat{WordByWordMontgomery}{word-by-word Montgomery}{x64}%
  \caption{\label{fig:timing-macro-various}Timing of different partial-evaluation implementations for Fiat Cryptography vs.\ prime modulus}
\end{figure}

It may also be useful to see performance results with absolute times, rather than normalized execution ratios vs.\ the original Fiat Cryptography implementation.
Furthermore, the benchmarks fit into four quite different groupings: elements of the cross product of two algorithms (unsaturated Solinas and word-by-word Montgomery) and bitwidths of target architectures (32-bit or 64-bit).
Here we provide absolute-time graphs by grouping in \autoref{fig:timing-macro-various}.

\clearpage
%\supplement

\section{Additional Information on Microbenchmarks}\label{sec:additionalMicro}

We performed all benchmarks on a 3.5 GHz Intel Haswell running Linux and Coq 8.10.0.
We name the subsections here with the names that show up in the code which is available at \href{https://github.com/mit-plv/rewriter/tree/v0.0.1}{the v0.0.1 tag of the \texttt{mit-plv/rewriter} repository on GitHub} and \href{https://github.com/mit-plv/fiat-crypto/tree/v0.0.5}{the v0.0.5 tag of the \texttt{mit-plv/fiat-crypto} repository on GitHub}.

\subsection{UnderLetsPlus0}\label{sec:UnderLetsPlus0-more}

We provide more detail on the ``nested binders'' microbenchmark of \autoref{sec:micro:UnderLetsPlus0} displayed in \autoref{fig:timing-UnderLetsPlus0}.

Recall that we are removing all of the${}+0$s from
{\small \begin{align*}
  & \letin[{v_1 := v_0 + v_0 + 0}{}] \\
%  & \letin[{v_2 := v_1 + v_1 + 0}{}] \\
  & \vdots \\
  & \letin[{v_n := v_{n-1} + v_{n-1} + 0}{}] \\
  & v_n + v_n + 0
\end{align*}}%

The code used to define this microbenchmark is
\begin{minted}{coq}
Definition make_lets_def (n:nat) (v acc : Z) :=
 @nat_rect (fun _ => Z * Z -> Z)
   (fun '(v, acc) => acc + acc + v)
   (fun _ rec '(v, acc) =>
     dlet acc := acc + acc + v in rec (v, acc))
   n
   (v, acc).
\end{minted}
We note some details of the rewriting framework that were glossed over in the main body of \autoref{ch:rewriting}, which are useful for using the code:
Although the rewriting framework does not support dependently typed constants, we can automatically preprocess uses of eliminators like \mintinline{coq}{nat_rect} and \mintinline{coq}{list_rect} into nondependent versions.
The tactic that does this preprocessing is extensible via \Ltac{}'s reassignment feature.
Since pattern-matching compilation mixed with NbE requires knowing how many arguments a constant can be applied to, we must internally use a version of the recursion principle whose type arguments do not contain arrows; current preprocessing can handle recursion principles with either no arrows or one arrow in the motive.
Even though we will eventually plug in 0 for $v$, we jump through some extra hoops to ensure that our rewriter cannot cheat by rewriting away the ${}+0$ before reducing the recursion on $n$.

We can reduce this expression in three ways.

\subsubsection{Our Rewriter}
One lemma is required for rewriting with our rewriter:
\begin{minted}{coq}
Lemma Z.add_0_r : forall z, z + 0 = z.
\end{minted}

Creating the rewriter takes about 12 seconds on the machine we used for running the performance experiments:
\begin{minted}{coq}
Make myrew := Rewriter For (Z.add_0_r, eval_rect nat, eval_rect prod).
\end{minted}
Recall from \autoref{sec:explain-eval-rect} that \mintinline{coq}{eval_rect} is a definition provided by our framework for eagerly evaluating recursion associated with certain types.
It functions by triggering typeclass resolution for the lemmas reducing the recursion principle associated to the given type.
We provide instances for \texttt{nat}, \texttt{prod}, \texttt{list}, \texttt{option}, and \texttt{bool}.
Users may add more instances if they desire.

\subsubsection{\texorpdfstring{\texttt{setoid\_rewrite}}{setoid\_rewrite} and \texorpdfstring{\texttt{rewrite\_strat}}{rewrite\_strat}}
To give as many advantages as we can to the preexisting work on rewriting, we prereduce the recursion on \mintinline{coq}{nat}s using \texttt{cbv} before performing \texttt{setoid\_rewrite}.
(Note that \texttt{setoid\_rewrite} cannot itself perform reduction without generating large proof terms, and \texttt{rewrite\_strat} is not currently capable of sequencing reduction with rewriting internally due to bugs such as \coqbug{10923}.)
Rewriting itself is easy; we may use any of \texttt{repeat setoid\_rewrite Z.add\_0\_r}, \texttt{rewrite\_strat topdown Z.add\_0\_r}, or \texttt{rewrite\_strat bottomup Z.add\_0\_r}.

\subsection{Plus0Tree}\label{sec:Plus0Tree-more}

This is a version of \autoref{sec:UnderLetsPlus0-more} without any let binders, discussed in \autoref{sec:micro:Plus0Tree} but not displayed in \autoref{fig:multi-timing}.

We use two definitions for this microbenchmark:
\begin{minted}{coq}
Definition iter (m : nat) (acc v : Z) :=
  @nat_rect (fun _ => Z -> Z)
    (fun acc => acc)
    (fun _ rec acc => rec (acc + v))
    m
    acc.
Definition make_tree (n m : nat) (v acc : Z) :=
 Eval cbv [iter] in
  @nat_rect (fun _ => Z * Z -> Z)
    (fun '(v, acc) => iter m (acc + acc) v)
    (fun _ rec '(v, acc) =>
      iter m (rec (v, acc) + rec (v, acc)) v)
    n
    (v, acc).
\end{minted}

\subsection{LiftLetsMap}\label{sec:LiftLetsMap-more}

We now discuss in more detail the ``binders and recursive functions'' example from \autoref{sec:micro:LiftLetsMap}.

The expression we want to get out at the end looks like:
\begin{align*}
    & \letin[{v_{1,1} := v + v}{}] \\
    & \vdots \\
    & \letin[{v_{1,n} := v + v}{}] \\
    & \letin[{v_{2,1} := v_{1,1} + v_{1,1}}{}] \\
    & \vdots \\
    & \letin[{v_{2,n} := v_{1,n} + v_{1,n}}{}] \\
    & \vdots \\
    & [v_{m,1}, \ldots, v_{m,n}]
\end{align*}

Recall that we make this example with the code
\begin{minted}{coq}
Definition map_double (ls : list Z) :=
  list_rect _ [] (λ x xs rec, let y := x + x in y :: rec) ls.
Definition make (n : nat) (m : nat) (v : Z) :=
  nat_rect _ (List.repeat v n) (λ _ rec, map_double rec) m.
\end{minted}

We can perform this rewriting in four ways; see \autoref{fig:timing-LiftLetsMap}.

\subsubsection{Our Rewriter}
One lemma is required for rewriting with our rewriter:
\begin{minted}{coq}
Lemma eval_repeat A x n
: @List.repeat A x ('n)
  = ident.eagerly nat_rect _ [] (λ k repeat_k, x :: repeat_k) ('n).
\end{minted}
Recall that the apostrophe marker (\verb|'|) is explained in \autoref{sec:explain-'}.
Recall again from \autoref{sec:explain-ident.eagerly} that we use \mintinline{coq}{ident.eagerly} to ask the reducer to simplify a case of primitive recursion by complete traversal of the designated argument's constructor tree.
Our current version only allows a limited, hard-coded set of eliminators with \mintinline{coq}{ident.eagerly} (\texttt{nat\_rect} on return types with either zero or one arrows, \texttt{list\_rect} on return types with either zero or one arrows, and \texttt{List.nth\_default}), but nothing in principle prevents automatic generation of the necessary code.
% Note that we use eliminators in the \mintinline{coq}{Thunked} namespace, which we provide in our library, to encode a version of the eliminator whose non-function cases are thunked rather than eagerly evaluated.
% That is, the type of, e.g., \mintinline{coq}{Thunked.nat_rect} is \mintinline{coq}{forall P, (unit -> P) -> (nat -> P -> P) -> nat -> P}.
% This is required in general for good performance with a call-by-value strategy, where you don't want to compute recursive cases that are then thrown away.
% Note that we don't really support any dependently typed constants; the use of \mintinline{coq}{nat_rect} in the first lemma is turned into a \mintinline{coq}{Thunked.nat_rect} automatically.
% Finally, we will note that our rewriter does not support matching on $\lambda$s on the left-hand-side, which is why the thunking cannot be done entirely internally on the left-hand-side.
% (It is performed during a preprocessing stage internally on the right-hand-side.)
% That is, the rewrite rule \emph{must} bind the thunked cases as part of the pattern.

We construct our rewriter with
\begin{minted}{coq}
Make myrew := Rewriter For (eval_repeat, eval_rect list, eval_rect nat)
  (with extra idents (Z.add)).
\end{minted}
On the machine we used for running all our performance experiments, this command takes about 13 seconds to run.
Note that all identifiers which appear in any goal to be rewritten must either appear in the type of one of the rewrite rules or in the tuple passed to \texttt{with extra idents}.

Rewriting is relatively simple, now.
Simply invoke the tactic \mintinline{coq}{Rewrite_for myrew}.
We support rewriting on only the left-hand-side and on only the right-hand-side using either the tactic \mintinline{coq}{Rewrite_lhs_for myrew} or else the tactic \mintinline{coq}{Rewrite_rhs_for myrew}, respectively.

\subsubsection{\texorpdfstring{\texttt{rewrite\_strat}}{rewrite\_strat}}

To reduce adequately using \texttt{rewrite\_strat}, we need the following two lemmas:
\begin{minted}{coq}
Lemma lift_let_list_rect T A P N C (v : A) fls
: @list_rect T P N C (Let_In v fls)
  = Let_In v (fun v => @list_rect T P N C (fls v)).
Lemma lift_let_cons T A x (v : A) f
: @cons T x (Let_In v f) = Let_In v (fun v => @cons T x (f v)).
\end{minted}

To rewrite, we start with \mintinline{coq}{cbv [example make map_dbl]} to expose the underlying term to rewriting.
One would hope that one could just add these two hints to a database \mintinline{coq}{db} and then write \texttt{rewrite\_strat (repeat (eval cbn [list\_rect]; try bottomup hints db))}, but unfortunately this does not work due to a number of bugs in Coq: \coqbug[]{10934}, \coqbug[]{10923}, \coqbug[]{4175}, \coqbug[]{10955}, and the potential to hit \coqbug[]{10972}.
Instead, we must put the two lemmas in separate databases, and then write the code \texttt{repeat (cbn [list\_rect]; (rewrite\_strat (try repeat bottomup hints db1)); (rewrite\_strat (try repeat bottomup hints db2)))}.
Note that the rewriting with \mintinline{coq}{lift_let_cons} can be done either top-down or bottom-up, but \texttt{rewrite\_strat} breaks if the rewriting with \mintinline{coq}{lift_let_list_rect} is done top-down.

\subsubsection{CPS and the VM}
If we want to use Coq's built-in VM reduction without our rewriter, to achieve the prior state-of-the-art performance, we can do so on this example, because it only involves partial reduction and not equational rewriting.
However, we must (a) module-opacify the constants which are not to be unfolded, and (b) rewrite all of our code in CPS.

Then we are looking at
\begin{align*}
    \text{map\_dbl\_cps}(\ell,k) & \defeq \begin{cases} k([]) & \text{if }\ell = [] \\
        \letin[{y := h +_\text{ax} h}{}] & \text{if }\ell = h::t \\
        \text{map\_dbl\_cps}(t, \\
        \qquad(\lambda ys, k(y :: ys)))
    \end{cases} \\
    \text{make\_cps}(n, m, v, k) & \defeq \begin{cases} k([\underbrace{v, \ldots, v}_n]) & \text{if }m = 0 \\
        \text{make\_cps}(n, m-1, v, & \text{if }m > 0 \\
        \quad(\lambda \ell,\text{map\_dbl\_cps}(\ell, k))
    \end{cases} \\
    \text{example\_cps}_{n, m} & \defeq \forall v,\ \text{make\_cps}(n, m, v, \lambda x.\,x) = []
\end{align*}

Then we can just run \texttt{vm\_compute}.
Note that this strategy, while quite fast, results in a stack overflow when $n \cdot m$ is larger than approximately $2.5\cdot 10^4$.
This is unsurprising, as we are generating quite large terms.
Our framework can handle terms of this size but stack-overflows on only slightly larger terms.

\subsubsection{Takeaway}

From this example, we conclude that \texttt{rewrite\_strat} is unsuitable for computations involving large terms with many binders, especially in cases where reduction and rewriting need to be interwoven, and that the many bugs in \texttt{rewrite\_strat} result in confusing gymnastics required for success.
The prior state of the art---writing code in CPS---suitably tweaked by using module opacity to allow \texttt{vm\_compute}, remains the best performer here, though the cost of rewriting everything is CPS may be prohibitive.
Our method soundly beats \texttt{rewrite\_strat}.
We are additionally bottlenecked on \texttt{cbv}, which is used to unfold the goal post-rewriting and costs about a minute on the largest of terms; see \coqbug{11151} for a discussion on what is wrong with Coq's reduction here.

\subsection{SieveOfEratosthenes}\label{sec:Eratosthenes}

We define the sieve using \mintinline{coq}{PositiveMap.t} and \mintinline{coq}{list Z}:
\begin{minted}{coq}
Definition sieve' (fuel : nat) (max : Z) :=
 List.rev
  (fst
   (@nat_rect
    (λ _, list Z (* primes *) *
     PositiveSet.t (* composites *) *
     positive (* np (next_prime) *) ->
     list Z (* primes *) *
     PositiveSet.t (* composites *))
    (λ '(primes, composites, next_prime),
     (primes, composites))
    (λ _ rec '(primes, composites, np),
      rec
       (if (PositiveSet.mem np composites ||
            (Z.pos np >? max))%bool%Z
        then
         (primes, composites, Pos.succ np)
        else
         (Z.pos np :: primes,
          List.fold_right
           PositiveSet.add
           composites
           (List.map
            (λ n, Pos.mul (Pos.of_nat (S n)) np)
            (List.seq 0 (Z.to_nat(max/Z.pos np)))),
          Pos.succ np)))
    fuel
    (nil, PositiveSet.empty, 2%positive))).

Definition sieve (n : Z)
  := Eval cbv [sieve'] in sieve' (Z.to_nat n) n.
\end{minted}

We need four lemmas and an additional instance to create the rewriter:
\begin{minted}{coq}
Lemma eval_fold_right A B f x ls :
@List.fold_right A B f x ls
= ident.eagerly list_rect _ _
    x
    (λ l ls fold_right_ls, f l fold_right_ls)
    ls.

Lemma eval_app A xs ys :
xs ++ ys
= ident.eagerly list_rect A _
    ys
    (λ x xs app_xs_ys, x :: app_xs_ys)
    xs.

Lemma eval_map A B f ls :
@List.map A B f ls
= ident.eagerly list_rect _ _
    []
    (λ l ls map_ls, f l :: map_ls)
    ls.

Lemma eval_rev A xs :
@List.rev A xs
= (@list_rect _ (fun _ => _))
    []
    (λ x xs rev_xs, rev_xs ++ [x])%list
    xs.

Scheme Equality for PositiveSet.tree.

Definition PositiveSet_t_beq
   : PositiveSet.t -> PositiveSet.t -> bool
  := tree_beq.

Global Instance PositiveSet_reflect_eqb
 : reflect_rel (@eq PositiveSet.t) PositiveSet_t_beq
 := reflect_of_brel
      internal_tree_dec_bl internal_tree_dec_lb.
\end{minted}

We then create the rewriter with
\begin{minted}{coq}
Make myrew := Rewriter For
  (eval_rect nat, eval_rect prod, eval_fold_right,
   eval_map, do_again eval_rev, eval_rect bool,
   @fst_pair, eval_rect list, eval_app)
   (with extra idents (Z.eqb, orb, Z.gtb,
    PositiveSet.elements, @fst, @snd,
    PositiveSet.mem, Pos.succ, PositiveSet.add,
    List.fold_right, List.map, List.seq, Pos.mul,
    S, Pos.of_nat, Z.to_nat, Z.div, Z.pos, O,
    PositiveSet.empty))
  (with delta).
\end{minted}

To get \texttt{cbn} and \texttt{simpl} to unfold our term fully, we emit
\begin{minted}{coq}
Global Arguments Pos.to_nat !_ / .
\end{minted}


\section{Reading the Code}\label{sec:CodeSupplement-more}
\bgroup
% allow breaks after slashes, for long paths
\allowbreakafterslash

As mentioned in \autoref{sec:additionalMicro} the code described and used in \autoref{ch:rewriting} is available at \href{https://github.com/mit-plv/rewriter/tree/v0.0.1}{the v0.0.1 tag of the \texttt{mit-plv/rewriter} repository on GitHub} and \href{https://github.com/mit-plv/fiat-crypto/tree/v0.0.5}{the v0.0.5 tag of the \texttt{mit-plv/fiat-crypto} repository on GitHub}.
Both repositories build with Coq 8.9, 8.10, 8.11, and 8.12, and they require that whichever OCaml was used to build Coq be installed on the system to permit building plugins.
(If Coq was installed via opam, then the correct version of OCaml will automatically be available.)
Both code bases can be built by running \texttt{make} in the top-level directory.

The performance data for both repositories are included at the top level as \texttt{.txt} and \texttt{.csv} files on different branches.
The \texttt{rewriter} repository has performance data available on the branch \href{https://github.com/mit-plv/rewriter/tree/PLDI-2020-perf-data}{\texttt{PLDI-2020-perf-data}}, and the \texttt{fiat-crypto} repository has performance data available on the branch \href{https://github.com/mit-plv/fiat-crypto/tree/perf-testing-data-POPL-2021-rewriting}{\texttt{perf-testing-data-POPL-2021-rewriting}}.

The performance data for the microbenchmarks can be rebuilt using \texttt{make perf-SuperFast perf-Fast perf-Medium} followed by \texttt{make perf-csv} to get the \texttt{.txt} and \texttt{.csv} files.
The microbenchmarks should run in about 24 hours when run with \texttt{-j5} on a 3.5 GHz machine.
There also exist targets \texttt{perf-Slow} and \texttt{perf-VerySlow}, but these take significantly longer.

The performance data for the macrobenchmark can be rebuilt from the Fiat Cryptography repository by running \texttt{make perf -k}.
We ran this with \texttt{PERF\_MAX\_TIME=3600} to allow each benchmark to run for up to an hour; the default is 10 minutes per benchmark.
Expect the benchmarks to take over a week of time with an hour timeout and five cores.
Some tests are expected to fail, making \texttt{-k} a necessary flag.
Again, the \texttt{perf-csv} target will aggregate the logs and turn them into \texttt{.txt} and \texttt{.csv} files.

The entry point for the rewriter is the Coq source file \texttt{rewriter/src/Rewriter/Util/plugins/RewriterBuild.v}.

The rewrite rules used in Fiat Cryptography are defined in \texttt{fiat-crypto/src/Rewriter/Rules.v} and proven in \texttt{fiat-crypto/src/Rewriter/RulesProofs.v}.
Note that the Fiat Cryptography copy uses \verb|COQPATH| for dependency management, and \verb|.dir-locals.el| to set \verb|COQPATH| in emacs/PG; you must accept the setting when opening a file in the directory for interactive compilation to work.
Thus interactive editing either requires ProofGeneral or manual setting of \verb|COQPATH|.
The correct value of \verb|COQPATH| can be found by running \verb|make printenv|.

We will now go through \autoref{ch:rewriting} and describe where to find each reference in the code base.

\subsection{Code from \autocommanameref{sec:rewriting:intro}}
\reparskip
\subsubsection{Code from \autocommanameref{sec:motivating-example}}

The \texttt{prefixSums} example appears in the Coq source file \texttt{rewriter/src/Rewriter/Rewriter/Examples/PrefixSums.v}.
Note that we use \texttt{dlet} rather than \mintinline{coq}{let} in binding \texttt{acc'} so that we can preserve the \mintinline{coq}{let} binder even under $\iota$ reduction, which much of Coq's infrastructure performs eagerly.
Because we attempt to isolate the dependency on the axiom of functional extensionality as much as possible, we also in practice require \texttt{Proper} instances for each higher-order identifier saying that each constant respects function extensionality.
We hope to remove the dependency on function extensionality altogether in the future.
Although we glossed over this detail in the body of \autoref{ch:rewriting}, we also prove
\begin{minted}{coq}
Global Instance: forall A B,
 Proper ((eq ==> eq ==> eq) ==> eq ==> eq ==> eq)
        (@fold_left A B).
\end{minted}

The \mintinline{coq}{Make} command is exposed in \texttt{rewriter/src/Rewriter/Util/plugins/RewriterBuild.v} and defined in \texttt{rewriter/src/Rewriter/Util/plugins/rewriter\_build\_plugin.mlg}.
Note that one must run \texttt{make} to create this latter file; it is copied over from a version-specific file at the beginning of the build.

\label{sec:code:eval-rect}%
\label{sec:code:ident.eagerly}%
The \verb|do_again|, \verb|eval_rect|, and \verb|ident.eagerly| constants are defined at the bottom of module \verb|RewriteRuleNotations| in \texttt{rewriter/src/Rewriter/Language/Pre.v}.

\subsubsection{Code from \autocommanameref{sec:trusted-code-base-size}}

There is no code mentioned in this section.

\subsubsection{Code from \autocommanameref{sec:our-solution}}

We claimed that our solution meets five criteria.
We briefly justify each criterion with a sentence or a pointer to code:
\begin{itemize}
  \item
    We claimed that we \textbf{did not grow the trusted base} (excepting the axiom of functional extensionality).
    In any example file (of which a couple can be found in \texttt{rewriter/src/Rewriter/Rewriter/Examples/}), the \mintinline{coq}{Make} command creates a rewriter package.
    Running \texttt{Print Assumptions} on this new constant (often named \texttt{rewriter} or \texttt{myrew}) should demonstrate a lack of axioms other than functional extensionality.
    \texttt{Print Assumptions} may also be run on the proof that results from using the rewriter.
  \item
    We claimed \textbf{fast} partial evaluation with reasonable memory use; we assume that the performance graphs stand on their own to support this claim.
    Note that memory usage can be observed by making the benchmarks while passing \texttt{TIMED=1} to \texttt{make}.
  \item
    We claimed to allow reduction that \textbf{mixes} \emph{rules of the definitional equality} with \emph{equalities proven explicitly as theorems}; the ``rules of the definitional equality'' are, for example, $\beta$ reduction, and we assert that it should be self-evident that our rewriter supports this.
  \item
    We claimed common-subterm \textbf{sharing preservation}.
    This is implemented by supporting the use of the \texttt{dlet} notation which is defined in \texttt{rewriter/src/Rewriter/Util/LetIn.v} via the \texttt{Let\_In} constant.
    We will come back to the infrastructure that supports this.
  \item
    We claimed \textbf{extraction of standalone partial evaluators}.
    The extraction is performed in the Coq source files \texttt{perf\_unsaturated\_solinas.v} and \texttt{perf\_word\_by\_word\_montgomery.v}, and the Coq files \texttt{saturated\_solinas.v}, \texttt{unsaturated\_solinas.v}, and \texttt{word\_by\_word\_montgomery.v}, all in the directory \texttt{fiat-crypto/src/ExtractionOCaml/}.
    The OCaml code can be extracted and built using the target \texttt{make standalone-ocaml} (or \texttt{make perf-standalone} for the \texttt{perf\_} binaries).
    There may be some issues with building these binaries on Windows as some versions of \texttt{ocamlopt} on Windows seem not to support outputting binaries without the \texttt{.exe} extension.
\end{itemize}

The P-384 curve is mentioned.
This is the curve with modulus $2^{384} - 2^{128} - 2^{96} + 2^{32} - 1$; its benchmarks can be found in %files matching the glob
\texttt{fiat-crypto/src/Rewriter/PerfTesting/Specific/generated/p2384m2128m296p232m1\_\_*\_\_word\_by\_word\_montgomery\_*}.
The output \texttt{.log} files are included in the tarball; the \texttt{.v} and \texttt{.sh} files are automatically generated in the course of running \texttt{make perf -k}.

We mention integration with abstract interpretation; the abstract-interpretation pass is implemented in \texttt{fiat-crypto/src/AbstractInterpretation/}.

\subsection{Code from \autocommanameref{sec:trust}}

The individual rewritings mentioned are implemented via the \texttt{Rewrite\_*} tactics exported at the top of \texttt{rewriter/src/Rewriter/Util/plugins/RewriterBuild.v}.
These tactics bottom out in tactics defined at the bottom of \texttt{rewriter/src/Rewriter/Rewriter/AllTactics.v}.

\subsubsection{Code from \autocommanameref{sec:nine-steps}}\label{sec:code:nine-steps}

We match the nine steps with functions from the source code:
\begin{enumerate}
  \item
    The given lemma statements are scraped for which named functions and types the rewriter package will support.
    This is performed by \texttt{rewriter\_scrape\_data} in the file \texttt{rewriter/src/Rewriter/Util/plugins/rewriter\_build.ml} which invokes the \Ltac{} tactic named \texttt{make\_scrape\_data} in a submodule in the source file \texttt{rewriter/src/Rewriter/Language/IdentifiersBasicGenerate.v} on a goal headed by the constant we provide as \texttt{Pre.ScrapedData.t\_with\_args} in \texttt{rewriter/src/Rewriter/Language/PreCommon.v}.
  \item
    Inductive types enumerating all available primitive types and functions are emitted.
    This step is performed by \texttt{rewriter\_emit\_inductives} in file \texttt{rewriter/src/Rewriter/Util/plugins/rewriter\_build.ml} invoking tactics, such as \texttt{make\_base\_elim} in the Coq source file \texttt{rewriter/src/Rewriter/Language/IdentifiersBasicGenerate.v}, on goals headed by constants from \texttt{rewriter/src/Rewriter/Language/IdentifiersBasicLibrary.v}, including the constant \texttt{base\_elim\_with\_args} for example, to turn scraped data into eliminators for the inductives.
    The actual emitting of inductives is performed by code in the file \texttt{rewriter/src/Rewriter/Util/plugins/inductive\_from\_elim.ml}.
  \item
    Tactics generate all of the necessary definitions and prove all of the necessary lemmas for dealing with this particular set of inductive codes.
    This step is performed by the tactic \texttt{make\_rewriter\_of\_scraped\_and\_ind} in the source file \texttt{rewriter/src/Rewriter/Util/plugins/rewriter\_build.ml} which invokes the tactic \texttt{make\_rewriter\_all} defined in the file \texttt{rewriter/src/Rewriter/Rewriter/AllTactics.v} on a goal headed by the constant \texttt{VerifiedRewriter\_with\_ind\_args} defined in \texttt{rewriter/src/Rewriter/Rewriter/ProofsCommon.v}.
    The definitions emitted can be found by looking at the tactic \texttt{Build\_Rewriter} in \texttt{rewriter/src/Rewriter/Rewriter/AllTactics.v}, the \Ltac{} tactics \texttt{build\_package} in \texttt{rewriter/src/Rewriter/Language/IdentifiersBasicGenerate.v} and also in \texttt{rewriter/src/Rewriter/Language/IdentifiersGenerate.v} (there is a different tactic named \texttt{build\_package} in each of these files), and the \Ltac{} tactic \texttt{prove\_package\_proofs\_via} which can be found in \texttt{rewriter/src/Rewriter/Language/IdentifiersGenerateProofs.v}.
  \item
    The statements of rewrite rules are reified and soundness and syntactic-well-formedness lemmas are proven about each of them.
    This is done as part of the previous step, when the tactic \texttt{make\_rewriter\_all} transitively calls \texttt{Build\_Rewriter} from \texttt{rewriter/src/Rewriter/Rewriter/AllTactics.v}.
    Reification is handled by the tactic \texttt{Build\_RewriterT} in \texttt{rewriter/src/Rewriter/Rewriter/Reify.v}, while soundness and the syntactic-well-formedness proofs are handled by the tactics \texttt{prove\_interp\_good} and \texttt{prove\_good} respectively, both in \texttt{rewriter/src/Rewriter/Rewriter/ProofsCommonTactics.v}.
  \item
    The definitions needed to perform reification and rewriting and the lemmas needed to prove correctness are assembled into a single package that can be passed by name to the rewriting tactic.
    This step is also performed by the tactic \texttt{make\_rewriter\_of\_scraped\_and\_ind} in the source file \texttt{rewriter/src/Rewriter/Util/plugins/rewriter\_build.ml}.
\end{enumerate}

When we want to rewrite with a rewriter package in a goal, the following steps are performed, with code in the following places:
\begin{enumerate}
  \item
    We rearrange the goal into a closed logical formula: all free-variable quantification in the proof context is replaced by changing the equality goal into an equality between two functions (taking the free variables as inputs).
    Note that it is not actually an equality between two functions but rather an \texttt{equiv} between two functions, where \texttt{equiv} is a custom relation we define indexed over type codes that is equality up to function extensionality.
    This step is performed by the tactic \texttt{generalize\_hyps\_for\_rewriting} in \texttt{rewriter/src/Rewriter/Rewriter/AllTactics.v}.
  \item
    We reify the side of the goal we want to simplify, using the inductive codes in the specified package.  That side of the goal is then replaced with a call to a denotation function on the reified version.
    This step is performed by the tactic \texttt{do\_reify\_rhs\_with} in \texttt{rewriter/src/Rewriter/Rewriter/AllTactics.v}.
  \item
    We use a theorem stating that rewriting preserves denotations of well-formed terms to replace the denotation subterm with the denotation of the rewriter applied to the same reified term.
    We use Coq's built-in full reduction (\texttt{vm\_compute}) to reduce the application of the rewriter to the reified term.
    This step is performed by the tactic \texttt{do\_rewrite\_with} in \texttt{rewriter/src/Rewriter/Rewriter/AllTactics.v}.
  \item
    Finally, we run \texttt{cbv} (a standard call-by-value reducer) to simplify away the invocation of the denotation function on the concrete syntax tree from rewriting.
    This step is performed by the tactic \texttt{do\_final\_cbv} in \texttt{rewriter/src/Rewriter/Rewriter/AllTactics.v}.
\end{enumerate}
These steps are put together in the tactic \texttt{Rewrite\_for\_gen} in \texttt{rewriter/src/Rewriter/Rewriter/AllTactics.v}.

\subsubsection{Our Approach in More Than Nine Steps}

As the nine steps of \autoref{sec:nine-steps} do not exactly match the code, we describe here a more accurate version of what is going on.
For ease of readability, we do not clutter this description with references to the code, instead allowing the reader to match up the steps here with the more coarse-grained ones in \autoref{sec:nine-steps} or \autoref{sec:code:nine-steps}.

In order to allow easy invocation of our rewriter, a great deal of code (about 6500 lines) needed to be written.
Some of this code is about reifying rewrite rules into a form that the rewriter can deal with them in.
Other code is about proving that the reified rewrite rules preserve interpretation and are well-formed.
We wrote some plugin code to automatically generate the inductive type of base-type codes and identifier codes, as well as the two variants of the identifier-code inductive used internally in the rewriter.
One interesting bit of code that resulted was a plugin that can emit an inductive declaration given the Church encoding (or eliminator) of the inductive type to be defined.
We wrote a great deal of tactic code to prove basic properties about these inductive types, from the fact that one can unify two identifier codes and extract constraints on their type variables from this unification, to the fact that type codes have decidable equality.
Additional plugin code was written to invoke the tactics that construct these definitions and prove these properties, so that we could generate an entire rewriter from a single command, rather than having the user separately invoke multiple commands in sequence.

In order to build the precomputed rewriter, the following actions are performed:
\begin{enumerate}
    \item
    The terms and types to be supported by the rewriter package are scraped from the given lemmas.
    \item
    An inductive type of codes for the types is emitted, and then three different versions of inductive codes for the identifiers are emitted (one with type arguments, one with type arguments supporting pattern type variables, and one without any type arguments, to be used internally in pattern-matching compilation).
    \item
    Tactics generate all of the necessary definitions and prove all of the necessary lemmas for dealing with this particular set of inductive codes.
    Definitions cover categories like ``Boolean equality on type codes'' and ``how to extract the pattern type variables from a given identifier code,'' and lemma categories include ``type codes have decidable equality'' and ``the types being coded for have decidable equality'' and ``the identifiers all respect function extensionality.''
    \item
    The rewrite rules are reified, and we prove interpretation-correctness and well-formedness lemmas about each of them.
    \item
    The definitions needed to perform reification and rewriting and the lemmas needed to prove correctness are assembled into a single package that can be passed by name to the rewriting tactic.
    \item
    The denotation functions for type and identifier codes are marked for early expansion in the kernel via the \mintinline{coq}{Strategy} command;
    this is necessary for conversion at \mintinline{coq}{Qed}-time to perform reasonably on enormous goals.
\end{enumerate}

When we want to rewrite with a rewriter package in a goal, the following steps are performed:
\begin{enumerate}
    \item
    We use \mintinline{coq}{etransitivity} to allow rewriting separately on the left- and right-hand-sides of an equality.
    Note that we do not currently support rewriting in non-equality goals, but this is easily worked around using \texttt{let v := open\_constr:(\_) in replace <some term> with v} and then rewriting in the second goal.
    \item
    We revert all hypotheses mentioned in the goal, and change the form of the goal from a universally quantified statement about equality into a statement that two functions are extensionally equal.
    Note that this step will fail if any hypotheses are functions not known to respect function extensionality via typeclass search.
    \item
    We reify the side of the goal that is not an existential variable using the inductive codes in the specified package; the resulting goal equates the denotation of the newly reified term with the original evar.
    \item
    We use a lemma stating that rewriting preserves denotations of well-formed terms to replace the goal with the rewriter applied to our reified term.
    We use \texttt{vm\_compute} to prove the well-formedness side condition reflectively.
    We use \texttt{vm\_compute} again to reduce the application of the rewriter to the reified term.
    \item
    Finally, we run \texttt{cbv} to unfold the denotation function, and we instantiate the evar with the resulting rewritten term.
\end{enumerate}

There are a couple of steps that contribute to the trusted base.
We must trust that the rewriter package we generate from the rewrite rules in fact matches the rewrite rules we want to rewrite with.
This involves partially trusting the scraper, the reifier, and the glue code.
We must also trust the VM we use for reduction at various points in rewriting.
Otherwise, everything is checked by Coq.
We do, however, depend on the axiom of function extensionality in one place in the rewriter proof; after spending a couple of hours trying to remove this axiom, we temporarily gave up.


\subsection{Code from \autocommanameref{sec:structure}}

The expression language $e$ corresponds to the inductive \texttt{expr} type defined in module \texttt{Compilers.expr} in \texttt{rewriter/src/Rewriter/Language/Language.v}.

\subsubsection{Code from \autocommanameref{sec:pattern-matching-compilation-and-evaluation}}

The pattern-matching compilation step is done by the tactic \texttt{CompileRewrites} in \texttt{rewriter/src/Rewriter/Rewriter/Rewriter.v}, which just invokes the Gallina definition named \texttt{compile\_rewrites} with ever-increasing amounts of fuel until it succeeds.
(It should never fail for reasons other than insufficient fuel, unless there is a bug in the code.)
The workhorse function here is \texttt{compile\_rewrites\_step}.

The decision-tree evaluation step is done by the definition \texttt{eval\_rewrite\_rules}, also in the file \texttt{rewriter/src/Rewriter/Rewriter/Rewriter.v}.
The correctness lemmas are the theorem \texttt{eval\_rewrite\_rules\_correct} in the file \texttt{rewriter/src/Rewriter/Rewriter/InterpProofs.v} and the theorem \texttt{wf\_eval\_rewrite\_rules} in \texttt{rewriter/src/Rewriter/Rewriter/Wf.v}.
Note that the second of these lemmas, not mentioned in the \autoref{ch:rewriting}, is effectively saying that for two related syntax trees, \texttt{eval\_rewrite\_rules} picks the same rewrite rule for both.
(We actually prove a slightly weaker lemma, which is a bit harder to state in English.)

The third step of rewriting with a given rule is performed by the \texttt{rewrite\_with\_rule} definition in \texttt{rewriter/src/Rewriter/Rewriter/Rewriter.v}.
The correctness proof goes by the name \texttt{interp\_rewrite\_with\_rule} in the file \texttt{rewriter/src/Rewriter/Rewriter/InterpProofs.v}.
Note that the well-formedness-preservation proof for this definition in inlined into the proof of the lemma \verb|wf_eval_rewrite_rules| mentioned above.

The inductive description of decision trees is \verb|decision_tree| in \texttt{rewriter/src/Rewriter/Rewriter/Rewriter.v}.

The pattern language is defined as the inductive \verb|pattern| in \texttt{rewriter/src/Rewriter/Rewriter/Rewriter.v}.
Note that we have a \verb|Raw| version and a typed version; the pattern-matching compilation and decision-tree evaluation of \textcite{Aehlig} is an algorithm on untyped patterns and untyped terms.
We found that trying to maintain typing constraints led to headaches with dependent types.
Therefore when doing the actual decision-tree evaluation, we wrap all of our expressions in the dynamically typed \verb|rawexpr| type and all of our patterns in the dynamically typed \verb|Raw.pattern| type.
We also emit separate inductives of identifier codes for each of the \verb|expr|, \verb|pattern|, and \verb|Raw.pattern| type families.

We partially evaluate the partial evaluator defined by \verb|eval_rewrite_rules| in the \Ltac{} tactic \verb|make_rewrite_head| in \texttt{rewriter/src/Rewriter/Rewriter/Reify.v}.

\subsubsection{Code from \autocommanameref{sec:thunk-eval-subst-term}}

The type $\text{NbE}_t$ mentioned in \autoref{sec:NbE_t} is not actually used in the code; the version we have is described in \autoref{sec:under-lets} as the definition \verb|value'| in \texttt{rewriter/src/Rewriter/Rewriter/Rewriter.v}.

The functions \verb|reify| and \verb|reflect| are defined in \texttt{rewriter/src/Rewriter/Rewriter/Rewriter.v} and share names with the functions in \autoref{ch:rewriting}.
The function \texttt{reduce} is named \verb|rewrite_bottomup| in the code, and the closest match to NbE is \verb|rewrite|.


\subsection{Code from \autocommanameref{sec:scaling}}
\subsubsection{Code from \autocommanameref{sec:PHOAS}}

The inductives \verb|type|, \verb|base_type| (actually the inductive type \verb|base.type.type| in the linked code), and \verb|expr|, as well as the definition \verb|Expr|, are all defined in \texttt{rewriter/src/Rewriter/Language/Language.v}.
The definition \verb|denoteT| is \verb|type.interp| (the fixpoint \verb|interp| in the module \verb|type|) in \texttt{rewriter/src/Rewriter/Language/Language.v}.
The definition \verb|denoteE| is \verb|expr.interp|, and \verb|DenoteE| is the fixpoint \verb|expr.Interp|.

As mentioned above, \verb|nbeT| does not actually exist as stated but is close to \verb|value'| in \texttt{rewriter/src/Rewriter/Rewriter/Rewriter.v}.
The functions \verb|reify| and \verb|reflect| are defined in \texttt{rewriter/src/Rewriter/Rewriter/Rewriter.v} and share names with the functions in \autoref{ch:rewriting}.
The actual code is somewhat more complicated than the version presented in \autoref{ch:rewriting}, due to needing to deal with converting well-typed-by-construction expressions to dynamically typed expressions for use in decision-tree evaluation and also due to the need to support early partial evaluation against a concrete decision tree.
Thus the version of \verb|reflect| that actually invokes rewriting at base types is a separate definition \verb|assemble_identifier_rewriters|, while \verb|reify| invokes a version of \verb|reflect| (named \verb|reflect|) that does not call rewriting.
The function named \texttt{reduce} is what we call \verb|rewrite_bottomup| in the code; the name \verb|Rewrite| is shared between \autoref{ch:rewriting} and the code.
Note that we eventually instantiate the argument \verb|rewrite_head| of \verb|rewrite_bottomup| with a partially evaluated version of the definition named \verb|assemble_identifier_rewriters|.
Note also that we use fuel to support \verb|do_again|, and this is used in the definition \verb|repeat_rewrite| that calls \verb|rewrite_bottomup|.

The correctness proofs are \verb|InterpRewrite| in the Coq source file \texttt{rewriter/src/Rewriter/Rewriter/InterpProofs.v} and \verb|Wf_Rewrite| in \texttt{rewriter/src/Rewriter/Rewriter/Wf.v}.

Packages containing rewriters and their correctness theorems are in the record \verb|VerifiedRewriter| in \texttt{rewriter/src/Rewriter/Rewriter/ProofsCommon.v};
a package of this type is then passed to the tactic \verb|Rewrite_for_gen| from \texttt{rewriter/src/Rewriter/Rewriter/AllTactics.v} to perform the actual rewriting.
The correspondence of the code to the various steps in rewriting is described in the second list of \autoref{sec:code:nine-steps}.

\subsubsection{Code from \autocommanameref{sec:under-lets}}

To run the P-256 example in Fiat Cryptography, after building the library, run the code
\begin{minted}{coq}
Require Import Crypto.Rewriter.PerfTesting.Core.
Require Import Crypto.Util.Option.

Import WordByWordMontgomery.
Import Core.RuntimeDefinitions.

Definition p : params
  := Eval compute in invert_Some (of_string "2^256-2^224+2^192+2^96-1" 64).

Goal True.
  (* Successful run: *)
  Time let v := (eval cbv
    -[Let_In
      runtime_nth_default
      runtime_add runtime_sub runtime_mul runtime_opp runtime_div runtime_modulo
      RT_Z.add_get_carry_full RT_Z.add_with_get_carry_full RT_Z.mul_split]
    in (GallinaDefOf p)) in
    idtac.
  (* Unsuccessful OOM run: *)
  Time let v := (eval cbv
    -[(*Let_In*)
      runtime_nth_default
      runtime_add runtime_sub runtime_mul runtime_opp runtime_div runtime_modulo
      RT_Z.add_get_carry_full RT_Z.add_with_get_carry_full RT_Z.mul_split]
    in (GallinaDefOf p)) in
    idtac.
Abort.
\end{minted}

The \verb|UnderLets| monad is defined in the file \texttt{rewriter/src/Rewriter/Language/UnderLets.v}.

The definitions \verb|nbeT'|, \verb|nbeT|, and \verb|nbeT_with_lets| are in \texttt{rewriter/src/Rewriter/Rewriter/Rewriter.v} and are named \verb|value'|, \verb|value|, and \verb|value_with_lets|, respectively.

\subsubsection{Code from \autocommanameref{sec:side-conditions}}

The ``variant of pattern variable that only matches constants'' is actually special support for the reification of \verb|ident.literal| (defined in the module \verb|RewriteRuleNotations| in \texttt{rewriter/src/Rewriter/Language/Pre.v}) threaded throughout the rewriter.
The apostrophe notation \verb|'| is also introduced in the module \verb|RewriteRuleNotations| in \texttt{rewriter/src/Rewriter/Language/Pre.v}.
The support for side conditions is handled by permitting rewrite-rule-replacement expressions to return \verb|option expr| instead of \verb|expr|, allowing the function \verb|expr_to_pattern_and_replacement| in the file \texttt{rewriter/src/Rewriter/Rewriter/Reify.v} to fold the side conditions into a choice of whether to return \verb|Some| or \verb|None|.

\subsubsection{Code from \autocommanameref{sec:abs-int}}

The abstract-interpretation pass is defined in the source folder \texttt{fiat-crypto/src/AbstractInterpretation/}, and the rewrite rules handling abstract-interpretation results are the Gallina definitions \verb|arith_with_casts_rewrite_rulesT|, as well as \verb|strip_literal_casts_rewrite_rulesT|, \verb|fancy_with_casts_rewrite_rulesT|, and finally \verb|mul_split_rewrite_rulesT|, all defined in \texttt{fiat-crypto/src/Rewriter/Rules.v}.

The \verb|clip| function is the definition \verb|ident.cast| in \texttt{fiat-crypto/src/Language/PreExtra.v}.

\subsubsection{Code from \autocommanameref{sec:implementation-and-usage}}\label{sec:code-from-implementation-and-usage}

The \Ltac{} hooks for extending the preprocessing of eliminators are the \Ltac{} tactics \mintinline{coq}{reify_preprocess_extra} and \mintinline{coq}{reify_ident_preprocess_extra} in a submodule of \texttt{rewriter/src/Rewriter/Language/PreCommon.v}.
These hooks are called by \mintinline{coq}{reify_preprocess} and \mintinline{coq}{reify_ident_preprocess} in a submodule of \texttt{rewriter/src/Rewriter/Language/Language.v}.
Some recursion lemmas for use with these tactics are defined in the \verb|Thunked| module in \texttt{fiat-crypto/src/Language/PreExtra.v}.
These tactics are overridden in the Coq source file \texttt{fiat-crypto/src/Language/IdentifierParameters.v}.

The typeclass associated to \mintinline{coq}{eval_rect} ({c.f.} \autoref{sec:code:eval-rect}) is \mintinline{coq}{rules_proofs_for_eager_type} defined in \texttt{rewriter/src/Rewriter/Language/Pre.v}.
The instances we provide by default are defined in a submodule of \texttt{src/Rewriter/Language/PreLemmas.v}.

The hard-coding of the eliminators for use with \mintinline{coq}{ident.eagerly} ({c.f.} \autoref{sec:code:ident.eagerly}) is done in the tactics \mintinline{coq}{reify_ident_preprocess} and \mintinline{coq}{rewrite_interp_eager} in \texttt{rewriter/src/Rewriter/Language/Language.v}, in the inductive type \mintinline{coq}{restricted_ident} and the typeclass \mintinline{coq}{BuildEagerIdentT} in \texttt{rewriter/src/Rewriter/Language/Language.v}, and in the \Ltac{} tactic \mintinline{coq}{handle_reified_rewrite_rules_interp} defined in the file \texttt{rewriter/src/Rewriter/Rewriter/ProofsCommonTactics.v}.

The \mintinline{coq}{Let_In} constant is defined in \texttt{rewriter/src/Rewriter/Util/LetIn.v}.

\subsection{Code from \autocommanameref{sec:evaluation}}

\subsubsection{Code from \autocommanameref{sec:micro}}

This code is found in the files in \texttt{rewriter/src/Rewriter/Rewriter/Examples/}.
We ran the microbenchmarks using the code in \texttt{rewriter/src/Rewriter/Rewriter/Examples/PerfTesting/Harness.v} together with some \texttt{Makefile} cleverness.

The code from \autocommanameref{sec:micro:Plus0Tree} can be found in \texttt{Plus0Tree.v}.

The code from \autocommanameref{sec:micro:UnderLetsPlus0} can be found in \texttt{UnderLetsPlus0.v}.

The code used for the performance investigation described in \autocommanameref{sec:setoid-rewrite-bottlenecks} is not part of the framework we are presenting.

The code from \autocommanameref{sec:micro:LiftLetsMap} can be found in \texttt{LiftLetsMap.v}.

The code from \autocommanameref{sec:micro:Eratosthenes} can be found in \texttt{SieveOfEratosthenes.v}.

\subsubsection{Code from \autocommanameref{sec:macro}}

The rewrite rules are defined in \texttt{fiat-crypto/src/Rewriter/Rules.v} and proven in the file \texttt{fiat-crypto/src/Rewriter/RulesProofs.v}.
They are turned into rewriters in the various files in \texttt{fiat-crypto/src/Rewriter/Passes/}.
The shared inductives and definitions are defined in the Coq source file \texttt{fiat-crypto/src/Language/IdentifiersBasicGENERATED.v}, the Coq source file \texttt{fiat-crypto/src/Language/IdentifiersGENERATED.v}, and finally also the Coq source file \texttt{fiat-crypto/src/Language/IdentifiersGENERATEDProofs.v}.
Note that we invoke the subtactics of the \mintinline{coq}{Make} command manually to increase parallelism in the build and to allow a shared language across multiple rewriter packages.

\egroup
